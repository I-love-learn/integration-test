## 创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，***init命令有两个别名create、innit*** (init就是innit的缩写)。

npm init和npm create都是初始化一个package.json文件。

npm init -y 快速生成一个package.json文件。

yarn init也会初始化一个package.json。

 yarn create则会报错。因为yarn create需要跟包名

意思是

* **用指定的工具 创建新项目，但实际上做了两件事情：**
* a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
* b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于vite版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx  实际会去安装 create-xxx这个包 然后执行bin下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue项目编译和打包的时候都需要依据这个文件来进行ts的编译。

而jsconfig.json除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。
2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。
3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。
4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

快速上手Vue开发：在项目中如何配置 tsconfig.json 文件？

https://blog.csdn.net/sinat_27933301/article/details/132335904

tsconfigjson中的配置可以在运行vue-tsc命令的时候根据json中的配置项进行编译打包输出js，前提是设置了noEmit 为false 以及outDir。 如果不输出文件的话最终只做了ts代码检查。

## 一些依赖

@vitejs/plugin-vue  编译和解析.vue单文件组件。 他是vite与vue之间的桥梁。

typescript typescript依赖库。

vite 就是vite本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

* Vite仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对Vue3进行Typescript类型校验

这里没有发现解析编译typescript的依赖，可能是esbuild也可以编译ts吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite缓存

https://esbuild.github.io/ esbuild官网也说了 内置了js css ts 以及jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build的js代码没有被babel处理 因此如果需要兼容性则需要手动导入babel插件。

## SEO优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置webpack和页面实现预渲染方案，最终build出来多个html文件

不过需要history 路由模式

## vite+vue3+ts 手把手教你创建一个vue3项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

## 说说浏览器中的self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是WebWorker

WebWorker是运行在后台的javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时WebWorker在后台运行。
简单明了的一句话就是在javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker为Web应用程序提供了一种能在后台中运行的方法。通过WebWorker可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用WebWorker

* 解决一些页面的卡顿问题。
* 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

## 使用vite创建vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts中的reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types  env文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts和js混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些eslint规则

https://blog.csdn.net/qq_36305530/article/details/128342186

1. **`@babel/eslint-parser`** ：

* `@babel/eslint-parser`是一个ESLint解析器，它允许ESLint与Babel插件集成，以便在ESLint中使用Babel解析JavaScript代码。
* 通过使用 `@babel/eslint-parser`，可以确保ESLint能够正确解析使用了最新JavaScript语法或特性的代码，例如ES6/ES7语法、JSX等。

  这是一个代码检查插件。配置完成会自动安装相关依赖并生成 `.eslintrc.cjs` 文件
* `vite-plugin-eslint`允许在Vite项目中集成ESLint，实现对JavaScript和Vue等文件的代码检查。
* 通过该插件，可以在开发过程中实时检测代码风格和潜在问题，并及时提醒开发者进行修复，有助于提高代码质量和可维护性。

  [Prettier](https://so.csdn.net/so/search?q=Prettier&spm=1001.2101.3001.7020) 代码格式化工具，eslint是代码质量检查工具，二者可以搭配使用，一个负责检测代码书写错误，规范代码，一个用于自动修改代码中的错误。

  https://blog.csdn.net/m0_62762847/article/details/127072823

二者可以结合使用

https://zhuanlan.zhihu.com/p/659839223

https://zhuanlan.zhihu.com/p/337536349

https://blog.csdn.net/wangsenling/article/details/124944411

1. **eslint-config-prettier** ：

* `eslint-config-prettier`是一个ESLint配置，它的作用是关闭与Prettier重复的ESLint规则，避免ESLint和Prettier之间的冲突。
* 当使用 `eslint-config-prettier`时，它会禁用一些与Prettier冲突的ESLint规则，确保ESLint不会干扰Prettier对代码的格式化。

1. **eslint-plugin-prettier** ：

* `eslint-plugin-prettier`是一个ESLint插件，它的作用是在ESLint中运行Prettier进行代码格式化，并将格式化结果与原始代码进行比较。
* 当使用 `eslint-plugin-prettier`时，它会在ESLint检查代码之前运行Prettier，如果发现代码格式不符合规范，会将格式化后的代码与原始代码进行比较，并输出差异。
  eslint作用就是编辑一套适合团队的代码风格，而 `prettier`是自动格式化代码。

  https://blog.csdn.net/weixin_64051447/article/details/128262929
* eslint-config-prettier 会关闭ESLint中有关代码格式化的配置，具体参考这里。
* eslint-plugin-prettier 把Prettier配置成ESLint的一个插件，让其当做一个linter规则来运行，可参考其官网。

## npm cnpm yarn pnmp

https://zhuanlan.zhihu.com/p/457698236

https://blog.csdn.net/qq_68086484/article/details/127235359

总结 pnmp>yarn>npm3>npm2  cnpm是npm的国内镜像。

pnpm安装速度快且会有一个全局store来存储包，node_modules中是引用指向全局store中的包。

而yarn和npm是放到modules中把包。

## 使用TS时，解决.vue文件导入时报错说找不到类型

```typescript
// 声明一个模块，用于匹配所有以 ".vue" 结尾的文件
declare module "*.vue" {
// 从 "vue" 中导入 DefineComponent 类型
  import { App, defineComponent } from "vue";
// 定义一个类型为 DefineComponent 的变量 component
// 它具有三个泛型参数，分别表示组件的 props、组件的 data 和其他的类型。
// 在这里，我们使用空对象（{}）表示没有 props，使用空对象（{}）表示没有 data，使用 any 表示其他类型可以是任意值。
  const component: ReturnType<typeof defineComponent> & {
    install(app: App): void;
  };
// 导出 component 变量，这样其他地方在导入 ".vue" 文件时，TypeScript 编译器会将它识别为一个 Vue 组件
  export default component;
}
```

declare module typescript声明模块的语法。 上面的代码作用就是告诉ts .vue也是一个ts模块 而不是仅仅只是ts结尾的文件才是ts模块

d.ts文件是项目中的类型声明文件。如果想要ts能够获取默认类型则需要在d.ts文件中声明。

https://www.jianshu.com/p/85bd7e25e1e5

`declare module` 是在 TypeScript 中声明一个模块的语法。它通常用于为 JavaScript 模块（如 npm 包）或其他非 TypeScript 文件（如 Vue 的单文件组件）提供类型信息。这样，在 TypeScript 代码中引入这些模块时，编译器会使用你在 `.d.ts` 文件中定义的类型信息进行类型检查和代码提示。

## Typescript 中使用 ESLint 和 Prettier

https://www.jianshu.com/p/f363337e7c3e

```
npm i -d eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

这三个依赖分别是：

* eslint: ESLint 的核心代码；
* @typescript-eslint/parser：ESLint 的解析器，解析 TypeScript，检查和规范 TypeScript 代码；
* @typescript-eslint/eslint-plugin：ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

```
npm i -g prettier eslint-config-prettier eslint-plugin-prettier
```

* prettier：prettier 插件的核心代码；
* eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prettier 的样式规范为准，使 ESLint 中的样式规范自动失效；
* eslint-plugin-prettier：将 prettier 作为 ESLint 规范来使用。

暂时没有发现不写.prettierrc.js文件对代码格式化产生的问题，只要配置了eslint的配置文件就行.eslintrc.cjs

## ESlint插件

@vue/eslint-config-typescript   .vue文件支持eslint ts

@typescript-eslint/parser ts eslint解析器

@typescript-eslint/eslint-plugin ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

eslint-plugin-vue .vue文件 eslint插件 js

prettier 自动格式化代码

eslint-config-prettier eslint-plugin-prettier 解决eslint与prettier冲突

安装配置完毕prettier eslint-config-prettier eslint-plugin-prettier后便可实现 保存代码自动格式化eslint报错的代码。

## Vite 添加 ESLint 支持

需要安装一个插件 [vite-plugin-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-plugin-eslint "vite-plugin-eslint")，在 vite.config.ts 中进行使用。

npm install vite-plugin-eslint --save-dev

```javascript
...
import eslint from 'vite-plugin-eslint' // 新增
 
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), eslint()], // 新增 eslint()
})
 
复制代码
```

作用 eslint本身报错 vite会忽略编译的时候，浏览器也不会显示，使用了这个插件后，会在终端和浏览器中显示eslint的报错

https://blog.csdn.net/qq_41581588/article/details/130052727

ts下会报错说找不到声明文件，暂没有解决办法，因为是一个比较小众的依赖。

## 一些额外的eslint

`@babel/eslint-parser` 是一个 ESLint 解析器，它的作用是允许 ESLint 使用 Babel 解析器来解析 JavaScript 代码。通常情况下，ESLint 默认使用 Espree 作为解析器，但有时候我们希望使用 Babel 来解析代码，特别是在涉及到一些新的 JavaScript 语法或者需要支持一些 Babel 插件的情况下。

使用 `@babel/eslint-parser` 可以让 ESLint 在检查代码时使用 Babel 的解析器，这样就可以支持更多的 JavaScript 语法特性，以及使用一些 Babel 插件所带来的好处。这对于在项目中使用了 Babel 进行代码转换的情况下特别有用，可以确保 ESLint 能够正确解析和检查经过 Babel 转换后的代码。

本质这也是一个自定义解析器。

如果要使用自定义解析器（如 @babel/eslint-parser 或 @typescript-eslint/parser），则必须使用该 parserOptions.parser 选项而不是该 parser 选项。因为这个插件需要 vue-eslint-parser 来解析 .vue 文件，所以如果你覆盖这个 parser 选项，这个插件就不起作用。

**diff** 差异

```json
- "parser": "@typescript-eslint/parser",
+ "parser": "vue-eslint-parser",
  "parserOptions": {
+     "parser": "@typescript-eslint/parser",
      "sourceType": "module"
  }
```

这也是为什么我们的配置文件里是"parser": "vue-eslint-parser" 的原因了。因为我们用了自定义解析器也就是ts的eslint解析器。

vue-eslint-parser 并没有被我们直接安装，而是我们使用安装eslint-plugin-vue的时候自带的。

## 为什么配置了组件自动导入了，还会提示找不到组件的类型？

这是由于，如果我们设置了快捷path 比如views 那么如果我们直接写views/xxx.vue 是会报类型问题的，解决办法就是需要声明.vue的类型。

如果我们通过正常的相对路径的话，则不会有这个问题。

## `tsconfig.node.json`

`tsconfig.node.json` 文件通常用于配置 TypeScript 项目在 Node.js 环境中的编译选项和设置。与普通的 `tsconfig.json` 文件相比，`tsconfig.node.json` 文件是针对在 Node.js 环境下运行的 TypeScript 项目进行特定配置的文件。

一些常见的配置项和用途包括：

1. **目标环境：** 设置 `target` 选项为 `node`，以指定编译后的 JavaScript 代码是针对 Node.js 运行时环境的。
2. **模块系统：** 设置 `module` 选项为 `commonjs`，以确保 TypeScript 编译后的模块系统与 Node.js 兼容。
3. **Node.js 特定库支持：** 可能会配置 `lib` 选项以包含 Node.js 特定的类型声明文件，以便在 TypeScript 代码中使用 Node.js 提供的 API。
4. **其他编译选项：** 可能会根据项目需求配置其他编译选项，如输出目录、源映射、严格模式等。

总的来说，`tsconfig.node.json` 文件用于定制 TypeScript 项目在 Node.js 环境中的编译设置，以确保 TypeScript 代码能够正确地在 Node.js 中运行和执行。

一般用于编译vite.config.ts。

## vite与ts

在使用 Vite 构建 Vue 3 项目时，如果你打算使用 TypeScript 进行开发，通常情况下是需要安装 TypeScript 的。尽管 Vite 内置了对 TypeScript 的支持，并且使用 esbuild 来处理 TypeScript 代码的编译和转换，但 TypeScript 本身仍然是一种独立的编程语言，需要通过安装 TypeScript 包来提供类型检查、语法支持等功能。

因此，为了在 Vue 3 项目中使用 TypeScript，并且能够获得 TypeScript 提供的类型检查和其他功能，你仍然需要在项目中安装 TypeScript 包。你可以通过 npm 或 yarn 来安装 TypeScript：

```bash
npm install typescript --save-dev
# 或
yarn add typescript --dev
```

安装 TypeScript 后，你可以在项目中编写 TypeScript 代码，并利用 Vite 提供的 TypeScript 支持来进行开发。安装 TypeScript 包可以让你在项目中充分利用 TypeScript 的强大功能，同时结合 Vite 的快速构建能力，实现高效的开发体验。

也就是说vite只负责转换ts，不负责语法类型检查，需要typescript和vue-tsc来检查。

https://blog.csdn.net/qq_29689343/article/details/127187921

vscode本身支持ts校验的，虽然不装ts依赖也没关系，但是如果不用vscode呢。

https://blog.csdn.net/qq_41579104/article/details/129856763

tsconfig的配置项说明。

## vite中的tsconfig.json作用

首先就是配置vue-tsc的，让他执行的时候进行ts代码的规则校验。

至于compilerOptions中的配置我发现修改了并不影响最终的打包结果，可能是打包和编译是vite做的，而vue-tsc的打包需要我们设置noEmit为false 才会输出文件，这个输出的文件才是受compilerOptions影响的。

也就是说tsconfigjson其实对我们的打包编译影响很小，主要还是做类型校验的。这个单独使用typescript开发的时候很有用。

.d.ts类型声明文件一定要放到 include下声明的需要编译处理声明的文件目录，否则无效。

## javascript开启严格模式好处

开启 JavaScript 的严格模式（Strict Mode）可以带来以下几个好处：

1. 更严格的语法和错误检查：严格模式会对一些不规范的语法和错误进行更严格的检查，可以帮助开发者发现潜在的问题并避免一些常见的错误。
2. 提升代码质量：严格模式要求更规范的编码方式，可以帮助开发者编写更加健壮、可靠的代码，提升代码质量。
3. 避免全局变量污染：在严格模式下，禁止隐式声明全局变量，可以避免全局变量污染，提高代码的可维护性和可读性。
4. 提高性能：严格模式下的代码通常比非严格模式下的代码更优化，因为严格模式下的一些特性可以让 JavaScript 引擎进行更好的优化。

总的来说，开启 JavaScript 的严格模式可以帮助开发者编写更加规范、健壮的代码，提高代码质量和性能，避免一些常见的问题和错误。因此，推荐在项目中使用严格模式来编写 JavaScript 代码。

## ESlint 傻瓜式配置办法

https://blog.csdn.net/qq_41581588/article/details/130052727

不需要手动安装一堆eslint插件，只安装eslint直接init初始化一个配置选完就好了，自动安装多个eslint依赖。

另外即便选择了typescript，还是需要手动去配置文件里配置的。

其他一些报错eslint的也可以参考这里面的解决办法。

另外，yarn init 和npm init执行不一样后者才是初始化eslint 前者是初始化一个package.json

可以在eslintrc.cjs文件的rules下进行配置 关闭一些不需要的配置。

## ENV文件内部变量新增ts提示。

https://cn.vitejs.dev/guide/env-and-mode.html#intellisense

这样 使用import.meta.env的时候就有提示了。

## html中使用env中变量

语法是%env中变量名% 如果没有那个变量 则会显示字符串你使用的内容%env%

## Pinia支持两种语法 组合式和选项式

组合式和vue组合式api一样使用setup函数然后内部定义响应式变量后return出来。

选项式就和vue的选项式是一样的，状态写在state里，然后最终把每个状态写到这个store实例的根属性上。

也不是把状态写到store的根属性，实际上是在根属性上为$data(data)，store是$state加上了代理，直接通过根属性访问等于访问的是data或者state中的数据源。

打印vm中的this上的data中的根属性，发现其是一个get get return data[key] 而methods中的方法不是get 而是直接是一个方法。

但是pinia不是，他根属性是值，不是get，他的state居然是get ()=>hot ? hotState.value : pinia.state.value[$id]

vue3的data居然也是get ()=>publicPropertiesMap[[key](instance)]

单个store中的state是从pinia这个pinia应用身上的state中根据id作为key取到的，也就是说咱们所有定义的state都存在了pinia应用实例身上。

我打印了vue3的应用实例 app 发现其身上除了use provide unmount directive component mount等等属性和方法外，还有_component根组件或者说组件树结构

**_context**存折全局上下文内容，主要包含如下：

app自身  components 全局组件

propsCache 存着全局的props **emitsCache** 全局emits

optionsCache 存着全局所有组件的options

倒是没找到缓存全局data的key。

## vue组件实例扩展

instance（实例） 一个vue组件就是一个实例，组件实例对象身上有很多方法。

再vue3中 每个组件实例都是一个proxy对象，可以通过这个proxy对象来获取data中的数据与methods方法和computed计算属性从根属性上。

而这个组件真正的实例对象则存在_这个属性身上，这个属性和vue2的组件实例对象很像都有uid，data，props等等。

而vue实例proxy对象身上除了咱们定义的方法属性外，其他的$data $ el 等属性 都是get方法 **() => publicPropertiesMap[key](instance)**（instance） 这个instance就是当前组件的_属性 也就是实例 也就是说哪些属性也是通过_这个组件实例身上来获取属性的。

```javascript
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props) ,
      $attrs: (i) => shallowReadonly(i.attrs) ,
      $slots: (i) => shallowReadonly(i.slots) ,
      $refs: (i) => shallowReadonly(i.refs) ,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i) ,
      $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i) 
    })
  );
```

publicPropertiesMap 本质上是一个Map数据结构，其中每个属性都是一个方法，方法接受instance然后输出对应的内容，其实就是组件proxy快速访问实例身上的属性。

而proxy根属性上的数据也是get获取的 get ()=>data[key] data也是vue内部定义的，方法直接就是方法赋值的。

setup函数中定义的data return 后也会出现在根属性上。

但是setup语法糖不会。不过setup语法糖里的顶层变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用

setup函数可以直接return 一个render函数，这是一个函数组件可以创建虚拟dom。语法糖不可以。 attr参数和slot也都是响应式的。

`setup`中返回的数据，还有官网中罗列的 `$el`，`$data`等都可以通过 `this`访问，底层是使用了 `Proxy`作为代理，当组件初始化的时，设置了代理对象。而这一过程中又设置了_与 `$el`，`$data`等属性，使其可以通过get访问到对应的数据。

## pinia组合式写法

要注意的是pinia组合式写的时候可以不用使用ref或者reactive去定义state，前提是修改数据时通过store.xx = 去修改 因为这个是proxy对象修改会触发响应式，如果通过store中的function去修改state不行，因为数据不是响应式数据，因此最好我们定义成响应式的，使用的时候ref的数据可以不.value，这是由于 `store` 是一个用 `reactive` 包装的对象，这意味着不需要在 getters 后面写 `.value`。 https://pinia.vuejs.org/zh/core-concepts/#using-the-store

## 为什么vue组件data是函数而不是对象

首先一个.vue组件 包含了模板 脚本和样式 。

1. 解析：构建工具（如 Vue Loader）会解析 `.vue` 文件，将模板、脚本和样式部分分离开来。
2. 编译：模板部分会被编译成渲染函数，脚本部分会被转换成 JavaScript 模块，样式部分会被处理成对应的样式表。
3. 实例化：在 JavaScript 模块中，会创建一个 Vue 组件实例对象，该对象包含了组件的数据、方法、生命周期钩子等信息。
4. 挂载：最后，将这个组件实例对象挂载到页面上的某个元素上，使其可以渲染出对应的 UI。

而data的初始化就在组件实例化这一阶段。

https://www.pipipi.net/38792.html

根据文献与源码，大概能够得知是先有虚拟dom，后有组件实例的。

https://segmentfault.com/a/1190000041535107?sort=newest

确实先有虚拟dom再有组件实例。因为组件实例中会用到虚拟dom中的一些属性。

```
createComponentInstance方法
```

```
applyOptions
```

这个方法来给组件实例通过options来apply 方法和data。

多个相同组件在渲染时用的是同一个render函数，也就是.vue文件编译后的render函数，render函数生产虚拟dom，同时会创建组件实例，组件实例中的data来自于options中的data，methods中的方法会被添加到组件实例身上，`computed` 选项会被处理为计算属性，也会被添加到组件实例中，可以像普通属性一样访问，但是会根据依赖的数据动态计算。

而这个options中的data是共享的，一个组件被使用多次是同一个render函数调用生产虚拟dom的，而这个虚拟dom和组件实例的data也是取自同一个options对象的data，如果options的data是对象，那就导致多个组件实例的数据源指向同一对象，因此需要设置一个函数，每次需要实例化的时候调用data函数返回一个新的对象。

.vue组件编译完后会导出一个对象，template会编译成 render函数 其他的options会原封不动的导出，setup组件 导出setup函数。

后续创建vnode，创建组件实例都要用到这些options，因为这个编译好的sfc对象是不变的，后续创建组件实例和vnode的时候基于这个sfc对象的data，如果data是对象，那么数据就会共享，因此要设置成函数。

https://cn.vuejs.org/guide/scaling-up/sfc.html#single-file-components

https://blog.csdn.net/qq_36348403/article/details/136525629

setup里使用的组件，不会出现在实例的components属性中。

https://zhuanlan.zhihu.com/p/612336916

深入组件初始化与响应式。

https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js

vue源码。

## volar和prettier冲突解决

代码格式化选择默认prettier。

## letter-spacing

letter-spacing是可以设置小数的，比如0.9px 0.8px 设置的是文字间距。

## ::after伪类元素会受当前元素的css影响比如文字渐变色等等，本质上他属于当前元素子元素。

## 文字渐变色

background: linear-gradient(left, #ff0000, #ffff00); // 背景渐变色

background-clip: text; // 以文字的范围来裁剪背景图片 简单来说就是可以做一个带背景的艺术文字效果

-webkit-text-fill-color:transparent; // *text-fill-color*是CSS3中的属性,表示文字颜色填充 把裁剪缕空的文字弄透明，这样就可以通过缕空的形状看到背景颜色，这时背景颜色就是字体的颜色

https://www.jb51.net/css/728441.html

## eslint 报错说找不到ref reactive方法解决办法

https://blog.csdn.net/webbirds/article/details/127283504

## ts声明props类型且设置默认值

```typescript
// 枚举的声明方式
enum ButtonType {
  default = "default"
}
// 声明泛型propsType
type propsType = {
// type可传可不传
  type?: ButtonType
}
// 使用vue的语法糖withDefaults声明类型检查props以及default默认值
const props = withDefaults(defineProps<propsType>(), {
// 这里default要用枚举的方式声明 而不是直接写成"default"
  type: ButtonType.default
})

console.log(props)
```

使用ts好处是 vue自带的props校验仅仅针对生产环境，而ts编译时即可找出问题。

## linear-gradient参数学习与使用

inear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。

参数
方法：linear-gradient(direction, color-stop1, color-stop2, ...)

direction：第一个参数表示渐变的方向。其可以是一个具体的角度值如45deg，或者是具体的方向值如to top，表示自下而上渐变；to bottom表示自上而下渐变【默认为to bottom】，还有 to right、to left等。

color-stop：渐变色的起止位置，通常是颜色加起始位置百分比。如 red 10%等。

不写起止位置默认去平分。0deg 由下到上渐变，先写的颜色在下，后写的颜色在上。

不写0deg 默认的由上到下渐变，先写的颜色在上 后写在下 可以认为是180deg

https://blog.csdn.net/Bekind2010/article/details/130269260

## 双引擎架构Vite如何实现？

https://segmentfault.com/a/1190000043784798

开发环境 esbuild

生产环境 rollup 不过代码压缩也用了esbuild 因为快 rollup有自己的ts编译插件

## vite 预构建

https://cn.vitejs.dev/guide/dep-pre-bundling.html

vite构建完毕后会在node_modules中有缓存，只要不更改如viteconfigjs或者删除新增依赖就不会重新构建依赖。 因为依赖常常是不需要被更改的，预构建后会大大提高效率。不必每次都去转换依赖。

https://juejin.cn/post/7310439736828117046?searchId=20240407095912EAA9C5FA0F7CEF7F3563  深入浅出 Vite5 中依赖预构建

## rollup内置了ts依赖插件来打包ts

## vue-tsc 需要typescript依赖

## npm run vite build 过程发生了什么

https://juejin.cn/post/6887013512364130311

rollup和esbuild 都会执行vite.config.json 都会执行其中的plugin 因此.vue的转换是 @vitejs/plugin-vue实现的

## video不设置大小默认是视频自身宽高

## [Vite是如何实现Esbuild打包的](https://segmentfault.com/a/1190000043980887)

https://segmentfault.com/a/1190000043980887

https://www.jianshu.com/p/7b9fa3a4969b

开发环境是请求发送的时候，vite服务才开始编译module然后返回的，而不是一开始就编译好的。 如果缓存中已存在直接返回已经编译好的。 当然这里不包含已经预构建的依赖，仅针对咱们写的 css和.vue .js等文件。

每个组件在客户端被请求的时候都会在头部引入热更新的模块。

## plugin和loader的区别

https://blog.csdn.net/qq_38290251/article/details/134212725

https://blog.csdn.net/baidu_21919557/article/details/134973258

vite中貌似取消loader了，只有plugin了

## 为什么vite服务浏览器可以使用ts文件直接

因为ts的响应标头是text/javascript

另外 vite自身即可编译ts 装ts依赖是为了使用vue-tsc 进行类型检查

## 滚动条样式修改

```css
::-webkit-scrollbar {
// 滚动条宽高  x轴是高度 y轴是宽度
width:6px;
  height: 6px;
}
// 滚动条滑块得样式 可以使用背景色渐变
::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom right, #4d7fff 0%, #1a56ff 100%);
  border-radius: 5px;
}
// 滚动条轨道
::-webkit-scrollbar-track {
  background-color: #ddd;
  border: 1px solid #ccc;
}
// 滚动条两侧按钮
::-webkit-scrollbar-button {
  background-color: #4d7fff;
  border-radius: 5px;
}
// 按钮悬浮样式
::-webkit-scrollbar-button:hover {
  background-color: #999999;
}
```

## [`assetsInclude` 选项](https://cn.vitejs.dev/config/shared-options.html#assetsinclude)

作用是声明可以被import导出的资源。

https://cn.vitejs.dev/guide/assets.html#static-asset-handling

https://cn.vitejs.dev/config/shared-options.html#assetsinclude

## enum类型说明

enum枚举类型最终编译后是一个对象，而不是数组，另外它的声明方式和对象很像key value的形式，如果默认只写key 则会默认是 key = 0 key = 1的形式 编译成一个对象。

https://www.jb51.net/javascript/30299895t.htm

枚举想要赋值字符串的时候必须要使用枚举的属性，而不能直接写字符串 否则报错，但是数值可以直接赋值

成员可以是字符串也是数值，不允许使用其他类型的值。

## props踩雷记录

```javascript

const customClass = {
  small: props.size === "small",
  "super-large": props.size === "super-large",
  default:
    !props.size || props.size === "default" || props.size === "super-large",
  disabled: props.disabled
}
// 这里我声明了一个对象 来保存所有的class 然后template中使用它 但是我发现没有数据驱动视图，原因在于对象中的属性一开始就是固定的了，props在使用时已经变成了值。

// 至于我们使用对象形式父传子 以及template中不写props直接使用props的属性都是可以的
```

## 全局组件用不用最终都会打包进去 因此最好还是按需导入。

## icon图标自动导入

https://github.com/sxzz/element-plus-best-practices/blob/db2dfc983ccda5570033a0ac608a1bd9d9a7f658/vite.config.ts#L21-L58

```javascript
// 自动导入图标组件
        IconsResolver({
          prefix: 'Icon',
        }),
// 自动注册图标组件
        IconsResolver({
          enabledCollections: ['ep'],
        }),
```

这段配置代码是一个 webpack 插件配置的示例，主要包含了三个插件的配置信息。让我来分析一下这段代码：

1. **AutoImport 插件**:

   - 这里配置了 AutoImport 插件，用于自动导入模块。
   - 在 resolvers 中配置了 IconsResolver，表示使用 IconsResolver 来解析图标。
   - IconsResolver 配置了 prefix 为 'Icon'，表示导入图标时的前缀为 'Icon'。
2. **Components 插件**:

   - 这里配置了 Components 插件，用于处理组件相关的逻辑。
   - 在 resolvers 中配置了 IconsResolver，表示同样使用 IconsResolver 来处理组件。
   - IconsResolver 配置了 enabledCollections 为 ['ep']，表示启用特定的图标集合 'ep'。
3. **Icons 插件**:

   - 这里配置了 Icons 插件，用于处理图标相关的逻辑。
   - Icons 插件配置了 autoInstall 为 true，表示自动安装图标。

总的来说，这段配置代码主要是在配置 webpack 插件，其中 AutoImport 插件用于自动导入模块，Components 插件用于处理组件逻辑，Icons 插件用于处理图标逻辑。IconsResolver 被用于处理图标相关的逻辑，并根据配置参数来解析和处理不同的图标集合。希望这个分析对您有帮助。如果您有任何其他问题，请随时告诉我。

我们配置完毕后 会自动下载安装ep模块的icon 然后就可以通过i-ep-xx在组件中使用了 并且需要注意的是不再需要手动安装element-icon的依赖了

自动导入是从iconify 中导入图标的，elementplus中的icon 默认基于这个图标库

naiveui和antdesign 我看官网没有提供自动导入图标的功能

ep是一个集合，意思是elementplus的iconify图标库中的ep集合。

## vite-plugin-inspect

vite-plugin-inspect 插件的作用是用于在 Vite 构建过程中检查和调试插件的工具。它可以帮助开发者更好地了解和分析 Vite 插件在构建过程中的执行情况，以便进行问题排查和优化调整。

通过 vite-plugin-inspect 插件，开发者可以查看插件在 Vite 构建过程中的执行顺序、输入输出信息、插件钩子的调用情况等，从而更好地理解插件的工作原理和影响。这有助于开发者调试和优化自定义插件，提高构建过程的效率和质量。

总的来说，vite-plugin-inspect 插件提供了一种方便的方式来检查和调试 Vite 构建过程中的插件，帮助开发者更好地理解和优化他们的自定义插件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

目测可以查看每个插件对源码的编译修改过程，和svn有点像，并且可以通过source-map-visualization 来查看我们写的代码编译后对应的代码关系。

scss编译成css，然后编译成js返回，不过返回我们的文件后缀还是scss，在network看的话。

并且css也会编译成js返回给我们。

自动导入默认是绝对路径导入的，编译后才变成相对路径。

ts文件是esbuild编译的。

## yarn install报错There appears to be trouble with your network connection. Retrying 解决办法

https://blog.csdn.net/qq_45503196/article/details/127468032

当然，让我为您解释每一行命令的作用：

1. `yarn config list`:

   - 这个命令用于查看当前 yarn 配置的所有设置，包括代理、镜像源等信息。
2. `yarn config delete proxy`:

   - 这个命令用于删除 yarn 的代理设置，如果之前设置了代理，执行这个命令会将代理设置移除。
3. `npm config rm proxy`:

   - 这个命令用于删除 npm 的代理设置，如果之前设置了 npm 的代理，执行这个命令会将代理设置移除。
4. `npm config rm https-proxy`:

   - 这个命令用于删除 npm 的 HTTPS 代理设置，如果之前设置了 npm 的 HTTPS 代理，执行这个命令会将 HTTPS 代理设置移除。
5. `yarn config set registry https://registry.npm.taobao.org`:

   - 这个命令用于将 yarn 的包管理器镜像源设置为淘宝镜像源，这样在安装包时会从淘宝镜像源下载，可以加快包的下载速度。

通过执行这些命令，您可以管理代理设置并将包管理器的镜像源设置为淘宝镜像源，以提高包的下载效率。希望这些解释对您有帮助。如果您有任何其他问题，请随时告诉我。

很好的问题!让我来解释一下 npm 和 yarn 设置代理以及 HTTPS 代理的用途:

1. **设置代理的用途**:

   - 代理服务器可以帮助我们绕过一些网络限制,比如某些地区无法直接访问某些网站或资源。
   - 通过设置代理,我们可以将对这些受限资源的请求转发到代理服务器,由代理服务器来访问这些资源,然后将结果返回给我们。
   - 对于 npm 和 yarn 来说,设置代理可以帮助我们绕过网络限制,从而更顺利地下载所需的包和依赖。
2. **HTTPS 代理的用途**:

   - HTTPS 是一种加密的网络传输协议,用于保护网络通信的安全性。
   - 当我们需要访问使用 HTTPS 协议的资源时,如果直接使用 HTTP 代理可能会出现问题。
   - 此时我们需要设置 HTTPS 代理,让代理服务器能够正确地处理 HTTPS 协议,确保我们能够安全地访问这些资源。
   - 对于 npm 和 yarn 来说,如果需要下载使用 HTTPS 协议的包和依赖,设置 HTTPS 代理就变得很重要。

总的来说,设置代理和 HTTPS 代理可以帮助我们绕过网络限制,更顺利地使用 npm 和 yarn 下载所需的包和依赖。这在某些受限网络环境下非常有用。希望这个解释对您有帮助!如果还有其他问题,欢迎继续询问。

代理是为了脱离网络的限制，以及网站屏蔽。 代理相当于一个中间人的角色可以隐藏真实的ip地址，同时还可以绕过可能存在的网络限制。

https://blog.csdn.net/lihefei_coder/article/details/119906244

https://wenku.baidu.com/view/72a0355430d4b14e852458fb770bf78a65293afe.html?_wkts_=1714213019069&bdQuery=npm%E4%BB%A3%E7%90%86%E4%BD%9C%E7%94%A8

如果您已经将 npm 镜像源设置为国内镜像（比如淘宝镜像或者 cnpm），通常情况下是不需要再配置代理地址的。国内镜像源已经帮助您加速了对 npm 包的访问，通常可以满足大部分用户的需求。

但是，如果您在使用国内镜像时仍然遇到网络访问问题，比如下载速度很慢或者无法连接到镜像源，这时可能需要考虑配置代理地址来帮助解决网络问题。代理服务器可以帮助您绕过网络限制或提高下载速度，有助于解决一些网络访问方面的困难。

总的来说，如果您使用了国内镜像并且网络访问正常，通常情况下是不需要额外配置代理地址的。但如果遇到网络问题，可以考虑配置代理来解决。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

## vite初始化与钩子

https://blog.csdn.net/xiangzhihong8/article/details/130931082

https://blog.csdn.net/u012384510/article/details/124287604

## 为什么已经使用了Components插件来自动导入vue组件了，但是autoImport里还有include声明vue文件呢？

因为autoimport 中导入的一些js 与组件 不属于components的范畴 比如 elmessage。

## 为什么已经安装了element图标库 使用自动导入图标时候还会自动安装ep图标库呢

后经过我测试 不需要安装element图标库了。

## inset  boxshadow 内阴影  外阴影看起来会改变盒子大小 内阴影不会 阴影本身不会改变元素大小  0 0 0 npx 看起来像是边框

## flex和 line-height 不会影响不同文字大小在同一容器内垂直位置上居中对齐。

也就是说垂直居中 使用line-height 不能让文字每一段文字 字号不同大小写不同，但都对盒子中心居中对齐. 文字默认有自己的对齐方式，就是根据文字基线来。

而flex align-items center 也不能保证 所有文字垂直居中对齐，文字有自己的高度。但总体还是大差不差的。

总结 数字 大写字母 汉字 使用line-height + **vertical-align**: **middle**;是可以实现文字居中的效果和flex ac一样 但小写字母不同 小写字母只是 显示小但是默认其高度是和大写字母一样高的 导致看起来 没有居中对齐而是偏下了，最好的所有文字居中对齐 还得是flex

https://www.cnblogs.com/BigFatStar/p/13442914.html

## flex只能保证子盒子位置 但是不能保证子盒子内部的盒子位置

## 自动导入的一些补充

https://blog.csdn.net/weixin_45366616/article/details/134469304

https://blog.csdn.net/qq_38845858/article/details/137112474

https://blog.csdn.net/qq_42611074/article/details/123036252

## template中函数传参细节

如果template中函数传参用到了ref 那么实参拿到的也是ref解包后的参数 不需要.value了

## ts 变量后边的问号和感叹号区别

例如 form？.xxx  意思是 form存在才调用后面方法，不存在不调用，!号意思是此时一定不为空直接调用

?.是js的不是ts的，我才知道

## ？。和？？

在 JavaScript 中，`?.` 和 `??` 是两种比较新的语法，分别表示可选链操作符（Optional Chaining Operator）和空值合并操作符（Nullish Coalescing Operator）。

1. **可选链操作符 `?.`**:

   - 可选链操作符 `?.` 用于简化访问深层对象属性时的代码，避免出现 `TypeError` 错误。
   - 当使用 `?.` 时，如果对象的前一个属性为 `null` 或 `undefined`，则整个表达式会立即返回 `undefined`，而不会继续访问后面的属性。
   - 例如：`obj?.prop1?.prop2`，如果 `obj` 或 `prop1` 为 `null` 或 `undefined`，则表达式会返回 `undefined`，而不会抛出错误。
2. **空值合并操作符 `??`**:

   - 空值合并操作符 `??` 用于提供一种更严格的空值判断，只有在值为 `null` 或 `undefined` 时才会返回其右侧的值。
   - 与传统的逻辑或操作符 `||` 不同，空值合并操作符 `??` 不会将空字符串 `''`、数字 `0` 或布尔值 `false` 视为 `null` 或 `undefined`。
   - 例如：`const result = a ?? b`，如果 `a` 的值为 `null` 或 `undefined`，则 `result` 的值为 `b`，否则为 `a` 的值。

这两种操作符的引入使得 JavaScript 代码更加简洁和易读，同时提高了处理空值和深层属性访问的便利性。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

??对比||的优点是，??只有在一边是null和undefined的时候才会返回另一侧的值 而|| 则必须另一侧的值不为能转成布尔false的值才返回，前者对比后者是可以返回布尔值 空字符串 0 等的 而后者不行。 好处是如果后端返回我们是0或者"" 我们也可以认为他返回值了 而不是没有。

## autoimport配置中imports不能直接自动导入只包含一个export default的包

比如axios lodash 这种包只默认导出了一个export default 会报错  除非手动写成对象形式才行

另外ts 导出的文件 只可以默认在ts类型的中 默认导入 js不行  同理配置的tsconfig中@ 这种别名 也只能在支持ts的文件中用js不行，除非手动在tsconfig.json中设置allowJStrue

目前发现类型是无法自动导入的，无论是element的还是自己定义的以后尝试网上有没有解决办法。

## checkJs和allowJs

在 TypeScript 的 `tsconfig.json` 配置文件中，`allowJs` 和 `checkJs` 是两个不同的选项，它们分别用于处理 JavaScript 文件的情况。

1. **`allowJs` 选项**：

   - `allowJs` 是一个布尔类型的选项，用于指定是否允许在 TypeScript 项目中包含 JavaScript 文件（.js 文件）。
   - 当 `allowJs` 设置为 `true` 时，TypeScript 编译器将允许在项目中引入 JavaScript 文件，并对这些 JavaScript 文件进行类型检查和编译。
   - 这个选项通常用于逐步迁移现有的 JavaScript 项目到 TypeScript，或者允许在 TypeScript 项目中使用一些第三方库的 JavaScript 版本。
2. **`checkJs` 选项**：

   - `checkJs` 也是一个布尔类型的选项，用于指定是否对 JavaScript 文件进行类型检查。
   - 当 `checkJs` 设置为 `true` 时，TypeScript 编译器将对引入的 JavaScript 文件进行类型检查，类似于对 TypeScript 文件的处理。
   - 这个选项可以帮助在引入 JavaScript 文件时提供更好的类型检查和代码质量保证。

综合来说，`allowJs` 用于控制是否允许引入 JavaScript 文件，而 `checkJs` 用于控制是否对这些 JavaScript 文件进行类型检查。在需要逐步迁移项目或者引入第三方 JavaScript 库时，可以结合使用这两个选项来更好地管理 TypeScript 项目中的 JavaScript 文件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

## 有时候自动导入没有生效，原因可能是代码没有编译由于其他报错，需要重新编译一下就自动解决了

## elementplus中的表单验证ref 通过ref使用泛型可以 通过Ref就报错 哦 原因是因为忘记默认undefined了

## setInterval 类型是NodeJs.timeout 赋值给变量复制成这个|null

## axios返回值类型设置

https://juejin.cn/post/6969070102868131853

## vue3+ts 在获取接口响应数据时，在ts中报错 类型“AxiosResponse＜any, any＞”上不存在属性“state”

https://blog.csdn.net/m0_57033755/article/details/128547409

declare module "axios"  扩展axios

## upload组件注意事项

upload组件 file-list参数不要用v-model绑定，要用自定义属性，否则不好控制file-list内容 因为onchange事件执行在前 v-model执行在后,另外如果不想让默认的上传列表出来 不能直接设置file-list = [] 而是要手动 on-change里设置file-list = []

## elementplus表单重置事件

elementplus表单重置事件 不是重置成表单默认值，而是重置成当前这个表单创建时的初始值。
假如表单创建的时候 form的值已经变化了 则以form的当前值为初始值

## 选中当前元素的后一个兄弟元素与has

https://blog.csdn.net/sdgfafg_25/article/details/137006174

:has() 可以选择括号內部指定元素的父元素

比如 :has(p) 意思是所有元素内部包含p元素的父元素

:has(>p) 意思是所有 一级子元素是p的父元素

选择直接（一级）后代元素包含 `<p>`元素的父级标签名是 `div`父元素：

```css
div:has(> p)
```

:has(+ p) 表示p前的兄弟元素唯一一个

:has(~p) 表示 p前全部的兄弟元素

## 文字颜色变化也可以做过度效果  用过度或者@property 或者动画

@property的用法和正常修改属性一样 hover的时候只会修改当前的css 变量 而非全局的 全局的照常用

## 设置盒子宽度从中间往两边展开  简单flex aligncenter布局 或者margin 0 auto 只要让元素在父元素中心 他边宽自然由中心往两侧

## declare module 'axios'

https://blog.51cto.com/u_16213444/7044433

不要忘记导入AxiosRequestConfig类型 否则会默认认为config是一个any类型 从而报错

```typescript
declare module "axios" {
  interface AxiosInstance {
    // config confiog配置类型
    (config: AxiosRequestConfig): Promise<any>
  }
}
```

不能在axios 类型扩展的时候使用ResponseType 类型 因为axios中有这个 默认会使用这个 不用我们自己定义的

这里的any可以换成任意interface 这样我们then的时候 的数据就是这个类型了 舒服了 这样我们解包的data就不会被认错 不知道是不是解包的了。

不过http封装的地方 use响应拦截器的回调的第一个参数倒是不知道如果设置data类型 不过也无所谓 因为axios默认了那个类型是any且不会被ts报错。

当我们把promise `<any> 换成interface后 那么 use 响应拦截器第一个参数会和axios.then 的res的类型 保持一致 虽然接口名不同 但类型一样 并且可以获得类型提示。`

另外 想要扩展module的时候一并扩展其中的interface 则要写在module中 定义interface 定义外面无效。

## 判断当前路由是否存在项目中

好多种做法第一种 hasRoute 这个缺点是只能通过路由name

第二种直接通过routes 去some

第三种 **currentRoute** 的component是否存在

## TS _参数 表示这个参数用不到

## history模式后端配置

这段代码是一个 Nginx 服务器配置文件的一部分，用于配置一个简单的 Web 服务器。让我为您解释一下这段代码的各个部分：

1. `server`：这是 Nginx 配置文件中定义一个服务器块的关键字，表示接下来是一个服务器的配置信息。
2. `listen 8080`：这一行指定了服务器监听的端口号为 8080，表示服务器将会在 8080 端口上接收传入的请求。
3. `server_name localhost`：这一行指定了服务器的域名为 localhost，表示服务器将会响应来自 localhost 的请求。
4. `location /`：这是一个 Nginx 配置中的 location 块，用于匹配请求的 URL 路径。
5. `root 'E:\dist'`：这一行指定了服务器的根目录为 'E:\dist'，表示当匹配到该 location 时，Nginx 会在 'E:\dist' 目录下查找相应的文件。
6. `index /index.html`：这一行指定了默认的索引文件为 /index.html，表示当请求的路径是一个目录时，默认会返回 index.html 文件。
7. `try_files $uri $uri/ /index.html`：这一行定义了 Nginx 在尝试查找文件时的策略。它会依次尝试查找与请求 URI 匹配的文件（$uri）、目录（$uri/），如果都找不到，则返回 /index.html 文件。

综合起来，这段配置文件的作用是配置一个 Nginx 服务器，监听在 8080 端口上，当收到来自 localhost 的请求时，会在 'E:\dist' 目录下查找相应的文件，如果找不到则返回 index.html 文件。这样可以实现一个简单的静态文件服务器，用于提供 Web 页面的访问。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

https://blog.csdn.net/muzidigbig/article/details/121892336

## 谷歌浏览器禁止跨域解决办法

https://blog.csdn.net/qq_17627195/article/details/129203873

## flex布局 父元素不设置宽度 默认会铺满 但是子元素默认是内容宽度

## 扩展window对象

```typescript
declare global {
  interface Window {
      $message: MessageApiInjection
  }
}
```

https://juejin.cn/post/7154527027599507486

https://www.jb51.net/javascript/320281bmm.htm

declare global是扩展全局作用域 可以扩展window String  以及第三方库全局类型

当使用第三方库时,如果该库没有提供类型定义文件(`.d.ts`),可以使用 `declare global` 来声明它的全局类型。

## 同时配置alias目录和相对路径目录相同时 vite优先使用前者 除非手动指定相对路径./ 不写./ 默认前者

## new URL定义文件导入路径的时候，正常应该.href，如果没有.href，使用的时候 template中会自动使用.href 但ts会报错。

## 浏览器会把0.1和0.9的border渲染成1px 想要小数border需要用盒子宽度做 比如before伪元素

https://www.cnblogs.com/ranyonsue/p/17236067.html

## flex: 0  0  xxpx / 3 的原理是什么

## new URL也可编译 tsconfig种的alias  src也可以  background也可以  除了cesium 中的路径不行

## html 横向纵向滚动条样式分别设置

在 WebKit 浏览器中，实际上并没有 `::-webkit-scrollbar-y-thumb` 和 `::-webkit-scrollbar-x-thumb` 这样的伪元素。要设置滚动条的滑块样式，您需要使用通用的 `::-webkit-scrollbar-thumb` 伪元素，并结合 `orientation` 属性来区分纵向和横向滚动条。

以下是正确的示例代码：

```css
/* 纵向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  width: 12px; /* 纵向滚动条宽度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 纵向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:vertical {
  background: #888; /* 纵向滚动条滑块颜色 */
}

/* 横向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  height: 12px; /* 横向滚动条高度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 横向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:horizontal {
  background: #888; /* 横向滚动条滑块颜色 */
}
```

通过在 `::-webkit-scrollbar-thumb` 中使用 `:vertical` 和 `:horizontal` 伪类，可以分别设置纵向和横向滚动条的滑块样式。这样就可以实现分开设置纵向和横向滚动条样式的效果。

## 有时候设置flex align-items center发现图片和文字无法居中对齐。

原因是因为字体会有自己的line-height默认的， 在这个line-height里文字可能不是在最中心的，因此最好单独设置line-height与父盒子相等，不过要视情况而定。

https://blog.csdn.net/lucklymm/article/details/125523258

## flex多行布局 侧轴样式设置

https://blog.csdn.net/shulianghan/article/details/130547207

align-content 样式说明

## 盒子装载图片时出现的盒子比图片实际偏高的问题

https://blog.csdn.net/m0_51404378/article/details/121095574

## 监听滚动事件与设置固钉 原生写法

```typescript
const quickActions = ref<HTMLElement>()
onMounted(() => {
  bodyHeight.value = document.body.clientHeight + "px"
  // scroll事件的触发对象只能是 window document 或者有滚动条的盒子
  window.addEventListener("scroll", function () {
// 根据滚动 不停修改滚动条位置
    quickActions.value!.style.top = `calc(${window.scrollY}px + 50vh - ${quickActions.value!.offsetHeight / 2}px)`
  })
  quickActions.value!.setAttribute(
    "style",
    `top: calc(50vh - ${quickActions.value!.offsetHeight / 2}px)`
  )
})
```

## nth-child和nth-of-type

nth-child想要选中某个元素 前面跟想要选中的元素  意思是选中这个父元素中第n个元素且这个元素是 我们前面规定的元素。 位置+类型必须一致

而nth-of-type 放在需要被选中的元素后面使用 意思是父盒子中第几个当前类型的元素被使用，它指的是当前元素。位置不一致 类型一致就行 因为位置是父元素中第n个类型符合的元素

nth-last-child 和nth-last-of-type 是从后往前数。

## 前端配置VITE_APP_BASE_API 作用

开发环境默认配代理路径就行，开发时会请求本机地址然后通过代理访问后端服务。

生产环境上线地址配置为空 或者/ 默认就会请求项目的服务器所在地址 后端会通过nginx转发到真实的后端服务地址。

如果后端不想nginx转发，则需要我们上线时把地址写死（那不还是会出现跨域问题），能后端会把不同地址都配置成请求他本地测试吧。

## z-index只能搭配 定位使用 绝对定位 相对定位 固定定位

相同父元素下 z-index值越大 优先级约高 不同父元素下 先比较父元素的z-index 谁大谁优先级高

## typscript的面向对象以及多态重载说明

https://blog.csdn.net/hzether/article/details/134889424

## 前端工程化学习笔记

https://www.kancloud.cn/cyyspring/webpack/3079670

core-js是完全模块化的javascript标准库。 包含ECMA-262至今为止大部分特性的polyfill，如promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的WHATWG / W3C特性的polyfill，如WHATWG URL。 它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入core-js，仍然使用最新特性的ES写法编码即可；也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入core-js的相关module，并可能还需要通过手工调用module完成编码，没法直接使用最新ES的写法。它是一个完全模块化的库，所有的polyfill实现，都有一个单独的module文件，既可以一劳永逸地把所有polyfill全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的core-js的modules文件。

注意 core.js与 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill的关系

babel-plugin-transform-runtime 是用来编译转换代码的 用到一些ES的方法 他会自动从 babel-runtime中导入使用工具函数 以及其他一些babel-runtime/corejs中的polyfill

babel-polyfill 基于core-js 他是对es6+方法的转换用es5的语法去实现他们，以及内置对象身上的方法。

`import "@bable/polyfill"` 的方式来实现针对api层面的“抹平”。然而从 babel v7.4.0开始官方就不建议采取这样的方式了。

因为不能按需导入+污染全局变量。

现在Babel7 的 presets对babel-polyfill做了处理，新增"useBuiltIns": "usage"，这样只会加载代码中用到的部分，完美的按需加载，但是依然会污染全局变量。

babel-runtime 中也包含polyfill，准确来说是core-js，也就意味着babel-runtime和babel-polyfill二者有其一就可以了。

`babel-runtime` 不能转码实例方法比如

```
!!!'.repeat(3);
'hello'.includes('h');
```

这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。

随着历史进程的发展，新一代的 [babel-prenset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmaster%2Fpackages%2Fbabel-preset-env "https://github.com/babel/babel/tree/master/packages/babel-preset-env")出现了。

babel-runtime使用与性能优化

https://juejin.cn/post/6844903615212027917

用了babel还需要polyfill吗？？？ https://juejin.cn/post/6845166891015602190?searchId=20240425105812792820EAF0C597F91626

关于babel(精华又通俗) https://juejin.cn/post/6844904199554072583

结合Babel 7.4.0 谈一下Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879

babel-polyfill VS babel-runtime VS babel-preset-env

https://juejin.cn/post/6844903602822053895

前端工程化（7）：你所需要知道的最新的babel兼容性实现方案

https://juejin.cn/post/6976501655302832159

webpack入门之js处理(babel、babel polyfill)

https://juejin.cn/post/7126465727178997791?searchId=20240425105812792820EAF0C597F91626

结合Babel 7.4.0 谈一下Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879?searchId=20240425105812792820EAF0C597F91626

实例探究Babel及Babel与Webpack、Vue之间的关系

https://juejin.cn/post/7051555571451265038?searchId=20240425105812792820EAF0C597F91626

@babel/preset-env只支持语法转换比如箭头函数转普通函数，let const 转var。 api则需要core-js或者babel/polyfill或者babel/runtime-corejs 来转换了。

@babel/preset-env babel7.0.0之前的话一开始如果只使用core2的话 无法polyfill内置方法，还需要安装babel/polyfill。 如果使用core3则不需要使用babel/polyfill

并且babel/runtime-corejs3 可以模拟实例或者说原型对象上的方法，而babel/runtime-corejs2不可以。

babel/polyfill虽然也可以 但是被废弃了。

babel一开始是会编译代码的，随着新版babel的发布，babel的编译功能交给了插件，自身只作为一个平台，如果不安装任何插件babel编译的结果和源码是一样的。

配置babel有两种，插件(`plugin`)或者预设(`preset`)。 编译时插件会先执行，预设后执行。

@babel/preset-env就是一个预设。他默认不会转义内置方法，需要搭配babel-polyfill，他会对高级语法进行降级

babel/runtime-corejs2 不支持实例方法，3支持。

babel/core在转义代码的时候 是要使用插件去处理的。

`@babel/preset-env`本身在语法转换的时候，会使用一些辅助函数来实现一些语法的模拟。而事实的确，这只是一种语法转换。 也就是说class辅助函数是 `@babel/preset-env` 语法降级时候定义的。

`_classCallCheck` 是 Babel 编译后代码中的一个辅助函数，用于实现类的构造函数中的类似于 ES6 类中 `this` 的检查和初始化。这个函数通常是由 Babel 插件 `@babel/plugin-transform-runtime` 插入到编译后的代码中的。

在 ES6 类中，如果没有正确使用 `super` 关键字调用父类的构造函数，或者在构造函数中没有正确初始化 `this`，就会导致错误。为了处理这种情况，Babel 在编译 ES6 类时会插入 `_classCallCheck` 函数来确保正确的类继承和初始化。

因此，`_classCallCheck` 并不是 JavaScript 或 ES6 标准中的原生方法，而是 Babel 在编译过程中生成的辅助函数之一，用于确保类的正确使用和初始化。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

在使用 Babel 进行 JavaScript 编译时，`babel-runtime`、`babel-plugin-transform-runtime` 和 `babel-polyfill` 是三个常用的工具或插件，它们在项目中扮演着不同的角色：

1. **babel-runtime**：

   - `babel-runtime` 是 Babel 提供的一个运行时库，用于支持编译后代码的运行。它包含了一些 Babel 编译后代码中使用的辅助函数，例如 `_classCallCheck`、`_extends` 等。
   - `_classCallCheck`、`_extends`不是babel-runtime生成的，而是babel语法转换时自己生成的，但是babel-runtime中提供了封装好的函数供导入用。
   - 使用 `babel-runtime` 可以避免在每个编译后的文件中重复生成这些辅助函数，减小编译后文件的体积。
   - 通常通过安装 `@babel/runtime` 包来使用 `babel-runtime`。
2. **babel-plugin-transform-runtime**：

   - `babel-plugin-transform-runtime` 是一个 Babel 插件，用于在编译过程中将代码中的公共辅助函数替换为 `@babel/runtime` 包中的对应函数。
   - 这个插件可以帮助减小编译后代码的体积，并且避免在每个文件中重复生成相同的辅助函数。
   - 通过在 Babel 配置中添加该插件，可以实现对编译后代码的优化。
3. **babel-polyfill**：

   - `babel-polyfill` 是一个用于提供对新的 JavaScript 特性的兼容性支持的包。它会在全局作用域中注入一些缺失的 ECMAScript 特性和内置对象的方法，以便在旧版本的浏览器中运行新的 JavaScript 代码。
   - 使用 `babel-polyfill` 可以解决一些新特性在旧浏览器中不被支持的问题，但它会增加项目的体积。
   - 在使用 `babel-polyfill` 时，需要在代码中引入它，通常是在应用程序的入口文件中引入。

总结：

- `babel-runtime` 是 Babel 提供的运行时库，包含一些辅助函数。
- `babel-plugin-transform-runtime` 是一个 Babel 插件，用于优化编译后代码中的辅助函数。
- `babel-polyfill` 是用于提供对新特性的兼容性支持的包，在旧浏览器中运行新的 JavaScript 代码时可能会用到。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

## HTML+CSS动画网

https://uiverse.io/Amerss/massive-robin-70

https://zhuanlan.zhihu.com/p/683609906

## 扩展 axios 请求config类型

https://www.cnblogs.com/qh1688/p/17457625.html

直接在扩展 axios module的时候 export interface 想要扩展的属性就完事了 因为interface本身就支持多个interface合并

## VSCode 噴 Unknown at rule @tailwind 解決方式

https://israynotarray.com/tailwindcss/20220405/1504568293/

## tailwind样式与自定义样式冲突解决办法

tailwind样式导入放最前面，让自己的覆盖他

## css的attr()方法

可以通过attr 使用当前元素身上的的属性 但测试目前好像只有content属性支持这个方法。

## unity打包出来的h5文件和cesium一样，需要本地托管一个服务才能跑起来，直接双击html运行的话不可以会报警告。

我知道了 通过xhr或者fetch去请求本地文件 如果是http https请求给通过，如果是file模式本地会报错

Access to XMLHttpRequest at 'file:///C:/Users/Administrator/Desktop/study-jk/%E6%B5%8B%E8%AF%95js%E7%9A%84%E8%AF%BB%E5%8F%96/a.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

这是浏览器为了安全设计的。

https://www.cnblogs.com/tuyile006/p/15619697.html

## 定位一些踩坑

定位的元素 如果不设置宽高 默认是被内容撑开 没内容那宽高就是0

如果定位的盒子 宽高是由内容撑开的 而恰好装他的父盒子没有宽高且必须是定位（单纯没有宽高不行），因为定位是相对于父元素的，那么定位的子盒子中的内容会竖着显示，如果是英文不受影响，因为英文单词很长本身就不会自动换行，中文的话会竖着显示，一行显示一个字，如果有逗号则最多显示两个字。 具体原因尚不明确。火狐也是这样。

如果子元素有长单词 那么子元素宽度会被撑开，即便设置了**word-wrap**: **break-word**; 也不能影响被撑开的子元素。

首先元素宽度不够 文字是的确会默认换行的，子元素遵循子绝父相，如果父元素没有定位则向上找，而向上找不存在文字伸展不开，但如果父元素宽度0且定位 那么子元素确实内容伸不开会换行。 因为他宽度不能超过父元素。

汉字之间会被视为一个个独立的字符，每个字符都会占据一定的宽度。由于汉字的宽度一般大于字母和数字，因此当一行放不下更多的汉字时，汉字就会自动换行。

英文和数字不会自动换行 需要设置 **word-wrap**: **break-word**;

word-break 属性规定自动换行的处理方法。

| normal    | 使用浏览器默认的换行规则。     |
| --------- | ------------------------------ |
| break-all | 允许在单词内换行。             |
| keep-all  | 只能在半角空格或连字符处换行。 |

word-wrap word-wrap 属性允许长单词或 URL 地址换行到下一行。

white-space 属性设置如何处理元素内的空白。

white-space 管的文字一行上不会换行强制不换行 遇到空白不会换行。word-warp 管的是长单词该不该换行，二者功能不重叠。

## 一些面试题

https://zhuanlan.zhihu.com/p/69723829?utm_id=0

## 浏览器加载图片和视频的时候默认的处理方式

图片和视频由于都是二进制流，因此浏览器默认是下载一点就展示一点。

## 「白话前端」快速区分webGL，webGPU，unity3D和UE4

https://baijiahao.baidu.com/s?id=1782882451057013215&wfr=spider&for=pc

## el-table覆盖了el-image处理办法

https://blog.csdn.net/CycleByle/article/details/135993703

https://blog.csdn.net/yusha123/article/details/106327893/

## 解决VUE keyup.enter和blur绑定同一事件，触发两次的问题

https://blog.csdn.net/qq_46264882/article/details/119344643

https://www.cnblogs.com/imPedro/p/12811781.html

https://www.jb51.net/article/265737.htm

## 为什么 el-input的blur事件 是input触发的  click也是input触发的

因为这些事件都是 element ui 自己封装的自定义事件 而不是原生事件，而这个自定义事件被子组件接受 子组件接受并触发传参的。 所以我们接受的也是input
