## 可以创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，**_init 命令有两个别名 create、innit_** (init 就是 innit 的缩写)。

npm init 和 npm create 都是初始化一个 package.json 文件。

npm init -y 快速生成一个 package.json 文件。

yarn init 也会初始化一个 package.json。

yarn create 则会报错。因为 yarn create 需要跟包名

意思是

- **用指定的工具 创建新项目，但实际上做了两件事情：**
- a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
- b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于 vite 版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx 实际会去安装 create-xxx 这个包 然后执行 bin 下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是 TypeScript 项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue 项目编译和打包的时候都需要依据这个文件来进行 ts 的编译。

而 jsconfig.json 除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是 TypeScript 项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。

2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。

3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。

4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

快速上手 Vue 开发：在项目中如何配置 tsconfig.json 文件？

https://blog.csdn.net/sinat_27933301/article/details/132335904

tsconfigjson 中的配置可以在运行 vue-tsc 命令的时候根据 json 中的配置项进行编译打包输出 js，前提是设置了 noEmit 为 false 以及 outDir。 如果不输出文件的话最终只做了 ts 代码检查。

## 一些依赖

@vitejs/plugin-vue 编译和解析.vue 单文件组件。 他是 vite 与 vue 之间的桥梁。

typescript typescript 依赖库。

vite 就是 vite 本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

- Vite 仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对 Vue3 进行 Typescript 类型校验

这里没有发现解析编译 typescript 的依赖，可能是 esbuild 也可以编译 ts 吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite 官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite 缓存

https://esbuild.github.io/ esbuild 官网也说了 内置了 js css ts 以及 jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build 的 js 代码没有被 babel 处理 因此如果需要兼容性则需要手动导入 babel 插件。

## SEO 优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置 webpack 和页面实现预渲染方案，最终 build 出来多个 html 文件

不过需要 history 路由模式

## vite+vue3+ts 手把手教你创建一个 vue3 项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD 模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

AMD 和 CMD 区别 https://baijiahao.baidu.com/s?id=1790113364978673808&wfr=spider&for=pc

## 说说浏览器中的 self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是 WebWorker

WebWorker 是运行在后台的 javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时 WebWorker 在后台运行。
简单明了的一句话就是在 javascript 单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker 为 Web 应用程序提供了一种能在后台中运行的方法。通过 WebWorker 可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用 WebWorker

- 解决一些页面的卡顿问题。
- 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

react 使用 webworker

https://blog.csdn.net/qq_33539839/article/details/131885078

## 使用 vite 创建 vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts 中的 reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types env 文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用 ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts 和 js 混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些 eslint 规则

https://blog.csdn.net/qq_36305530/article/details/128342186

1. **`@babel/eslint-parser`** ：

- `@babel/eslint-parser`是一个 ESLint 解析器，它允许 ESLint 与 Babel 插件集成，以便在 ESLint 中使用 Babel 解析 JavaScript 代码。
- 通过使用 `@babel/eslint-parser`，可以确保 ESLint 能够正确解析使用了最新 JavaScript 语法或特性的代码，例如 ES6/ES7 语法、JSX 等。

  这是一个代码检查插件。配置完成会自动安装相关依赖并生成 `.eslintrc.cjs` 文件

- `vite-plugin-eslint`允许在 Vite 项目中集成 ESLint，实现对 JavaScript 和 Vue 等文件的代码检查。
- 通过该插件，可以在开发过程中实时检测代码风格和潜在问题，并及时提醒开发者进行修复，有助于提高代码质量和可维护性。

  [Prettier](https://so.csdn.net/so/search?q=Prettier&spm=1001.2101.3001.7020) 代码格式化工具，eslint 是代码质量检查工具，二者可以搭配使用，一个负责检测代码书写错误，规范代码，一个用于自动修改代码中的错误。

  https://blog.csdn.net/m0_62762847/article/details/127072823

二者可以结合使用

https://zhuanlan.zhihu.com/p/659839223

https://zhuanlan.zhihu.com/p/337536349

https://blog.csdn.net/wangsenling/article/details/124944411

1. **eslint-config-prettier** ：

- `eslint-config-prettier`是一个 ESLint 配置，它的作用是关闭与 Prettier 重复的 ESLint 规则，避免 ESLint 和 Prettier 之间的冲突。
- 当使用 `eslint-config-prettier`时，它会禁用一些与 Prettier 冲突的 ESLint 规则，确保 ESLint 不会干扰 Prettier 对代码的格式化。

1. **eslint-plugin-prettier** ：

- `eslint-plugin-prettier`是一个 ESLint 插件，它的作用是在 ESLint 中运行 Prettier 进行代码格式化，并将格式化结果与原始代码进行比较。
- 当使用 `eslint-plugin-prettier`时，它会在 ESLint 检查代码之前运行 Prettier，如果发现代码格式不符合规范，会将格式化后的代码与原始代码进行比较，并输出差异。
  eslint 作用就是编辑一套适合团队的代码风格，而 `prettier`是自动格式化代码。

  https://blog.csdn.net/weixin_64051447/article/details/128262929

- eslint-config-prettier 会关闭 ESLint 中有关代码格式化的配置，具体参考这里。
- eslint-plugin-prettier 把 Prettier 配置成 ESLint 的一个插件，让其当做一个 linter 规则来运行，可参考其官网。

## npm cnpm yarn pnmp

https://zhuanlan.zhihu.com/p/457698236

https://blog.csdn.net/qq_68086484/article/details/127235359

总结 pnmp>yarn>npm3>npm2 cnpm 是 npm 的国内镜像。

pnpm 安装速度快且会有一个全局 store 来存储包，node_modules 中是引用指向全局 store 中的包。

而 yarn 和 npm 是放到 modules 中把包。

## 使用 TS 时，解决.vue 文件导入时报错说找不到类型

```typescript
// 声明一个模块，用于匹配所有以 ".vue" 结尾的文件
declare module "*.vue" {
  // 从 "vue" 中导入 DefineComponent 类型
  import { App, defineComponent } from "vue"
  // 定义一个类型为 DefineComponent 的变量 component
  // 它具有三个泛型参数，分别表示组件的 props、组件的 data 和其他的类型。
  // 在这里，我们使用空对象（{}）表示没有 props，使用空对象（{}）表示没有 data，使用 any 表示其他类型可以是任意值。
  const component: ReturnType<typeof defineComponent> & {
    install(app: App): void
  }
  // 导出 component 变量，这样其他地方在导入 ".vue" 文件时，TypeScript 编译器会将它识别为一个 Vue 组件
  export default component
}
```

declare module typescript 声明模块的语法。 上面的代码作用就是告诉 ts .vue 也是一个 ts 模块 而不是仅仅只是 ts 结尾的文件才是 ts 模块

d.ts 文件是项目中的类型声明文件。如果想要 ts 能够获取默认类型则需要在 d.ts 文件中声明。

https://www.jianshu.com/p/85bd7e25e1e5

`declare module` 是在 TypeScript 中声明一个模块的语法。它通常用于为 JavaScript 模块（如 npm 包）或其他非 TypeScript 文件（如 Vue 的单文件组件）提供类型信息。这样，在 TypeScript 代码中引入这些模块时，编译器会使用你在 `.d.ts` 文件中定义的类型信息进行类型检查和代码提示。

## Typescript 中使用 ESLint 和 Prettier

https://www.jianshu.com/p/f363337e7c3e

```
npm i -d eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

这三个依赖分别是：

- eslint: ESLint 的核心代码；
- @typescript-eslint/parser：ESLint 的解析器，解析 TypeScript，检查和规范 TypeScript 代码；
- @typescript-eslint/eslint-plugin：ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

```
npm i -g prettier eslint-config-prettier eslint-plugin-prettier
```

- prettier：prettier 插件的核心代码；
- eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prettier 的样式规范为准，使 ESLint 中的样式规范自动失效；
- eslint-plugin-prettier：将 prettier 作为 ESLint 规范来使用。

暂时没有发现不写.prettierrc.js 文件对代码格式化产生的问题，只要配置了 eslint 的配置文件就行.eslintrc.cjs

## ESlint 插件

@vue/eslint-config-typescript .vue 文件支持 eslint ts

@typescript-eslint/parser ts eslint 解析器

@typescript-eslint/eslint-plugin ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

eslint-plugin-vue .vue 文件 eslint 插件 js

prettier 自动格式化代码

eslint-config-prettier eslint-plugin-prettier 解决 eslint 与 prettier 冲突

安装配置完毕 prettier eslint-config-prettier eslint-plugin-prettier 后便可实现 保存代码自动格式化 eslint 报错的代码。

## Vite 添加 ESLint 支持

需要安装一个插件 [vite-plugin-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-plugin-eslint "vite-plugin-eslint")，在 vite.config.ts 中进行使用。

npm install vite-plugin-eslint --save-dev

```javascript
...
import eslint from 'vite-plugin-eslint' // 新增

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), eslint()], // 新增 eslint()
})

复制代码
```

作用 eslint 本身报错 vite 会忽略编译的时候，浏览器也不会显示，使用了这个插件后，会在终端和浏览器中显示 eslint 的报错

https://blog.csdn.net/qq_41581588/article/details/130052727

ts 下会报错说找不到声明文件，暂没有解决办法，因为是一个比较小众的依赖。

## 一些额外的 eslint

`@babel/eslint-parser` 是一个 ESLint 解析器，它的作用是允许 ESLint 使用 Babel 解析器来解析 JavaScript 代码。通常情况下，ESLint 默认使用 Espree 作为解析器，但有时候我们希望使用 Babel 来解析代码，特别是在涉及到一些新的 JavaScript 语法或者需要支持一些 Babel 插件的情况下。

使用 `@babel/eslint-parser` 可以让 ESLint 在检查代码时使用 Babel 的解析器，这样就可以支持更多的 JavaScript 语法特性，以及使用一些 Babel 插件所带来的好处。这对于在项目中使用了 Babel 进行代码转换的情况下特别有用，可以确保 ESLint 能够正确解析和检查经过 Babel 转换后的代码。

本质这也是一个自定义解析器。

如果要使用自定义解析器（如 @babel/eslint-parser 或 @typescript-eslint/parser），则必须使用该  parserOptions.parser  选项而不是该  parser  选项。因为这个插件需要 vue-eslint-parser 来解析  .vue  文件，所以如果你覆盖这个  parser  选项，这个插件就不起作用。

**diff**  差异

```json
- "parser": "@typescript-eslint/parser",
+ "parser": "vue-eslint-parser",
  "parserOptions": {
+     "parser": "@typescript-eslint/parser",
      "sourceType": "module"
  }
```

这也是为什么我们的配置文件里是"parser": "vue-eslint-parser" 的原因了。因为我们用了自定义解析器也就是 ts 的 eslint 解析器。

vue-eslint-parser 并没有被我们直接安装，而是我们使用安装 eslint-plugin-vue 的时候自带的。

## 为什么配置了组件自动导入了，还会提示找不到组件的类型？

这是由于，如果我们设置了快捷 path 比如 views 那么如果我们直接写 views/xxx.vue 是会报类型问题的，解决办法就是需要声明.vue 的类型。

如果我们通过正常的相对路径的话，则不会有这个问题。

## `tsconfig.node.json`

`tsconfig.node.json` 文件通常用于配置 TypeScript 项目在 Node.js 环境中的编译选项和设置。与普通的 `tsconfig.json` 文件相比，`tsconfig.node.json` 文件是针对在 Node.js 环境下运行的 TypeScript 项目进行特定配置的文件。

一些常见的配置项和用途包括：

1. **目标环境：** 设置 `target` 选项为 `node`，以指定编译后的 JavaScript 代码是针对 Node.js 运行时环境的。
2. **模块系统：** 设置 `module` 选项为 `commonjs`，以确保 TypeScript 编译后的模块系统与 Node.js 兼容。
3. **Node.js 特定库支持：** 可能会配置 `lib` 选项以包含 Node.js 特定的类型声明文件，以便在 TypeScript 代码中使用 Node.js 提供的 API。
4. **其他编译选项：** 可能会根据项目需求配置其他编译选项，如输出目录、源映射、严格模式等。

总的来说，`tsconfig.node.json` 文件用于定制 TypeScript 项目在 Node.js 环境中的编译设置，以确保 TypeScript 代码能够正确地在 Node.js 中运行和执行。

一般用于编译 vite.config.ts。

## vite 与 ts

在使用 Vite 构建 Vue 3 项目时，如果你打算使用 TypeScript 进行开发，通常情况下是需要安装 TypeScript 的。尽管 Vite 内置了对 TypeScript 的支持，并且使用 esbuild 来处理 TypeScript 代码的编译和转换，但 TypeScript 本身仍然是一种独立的编程语言，需要通过安装 TypeScript 包来提供类型检查、语法支持等功能。

因此，为了在 Vue 3 项目中使用 TypeScript，并且能够获得 TypeScript 提供的类型检查和其他功能，你仍然需要在项目中安装 TypeScript 包。你可以通过 npm 或 yarn 来安装 TypeScript：

```bash
npm install typescript --save-dev
# 或
yarn add typescript --dev
```

安装 TypeScript 后，你可以在项目中编写 TypeScript 代码，并利用 Vite 提供的 TypeScript 支持来进行开发。安装 TypeScript 包可以让你在项目中充分利用 TypeScript 的强大功能，同时结合 Vite 的快速构建能力，实现高效的开发体验。

也就是说 vite 只负责转换 ts，不负责语法类型检查，需要 typescript 和 vue-tsc 来检查。

https://blog.csdn.net/qq_29689343/article/details/127187921

vscode 本身支持 ts 校验的，虽然不装 ts 依赖也没关系，但是如果不用 vscode 呢。

https://blog.csdn.net/qq_41579104/article/details/129856763

tsconfig 的配置项说明。

## vite 中的 tsconfig.json 作用

首先就是配置 vue-tsc 的，让他执行的时候进行 ts 代码的规则校验。

至于 compilerOptions 中的配置我发现修改了并不影响最终的打包结果，可能是打包和编译是 vite 做的，而 vue-tsc 的打包需要我们设置 noEmit 为 false 才会输出文件，这个输出的文件才是受 compilerOptions 影响的。

也就是说 tsconfigjson 其实对我们的打包编译影响很小，主要还是做类型校验的。这个单独使用 typescript 开发的时候很有用。

.d.ts 类型声明文件一定要放到 include 下声明的需要编译处理声明的文件目录，否则无效。

## javascript 开启严格模式好处

开启 JavaScript 的严格模式（Strict Mode）可以带来以下几个好处：

1. 更严格的语法和错误检查：严格模式会对一些不规范的语法和错误进行更严格的检查，可以帮助开发者发现潜在的问题并避免一些常见的错误。
2. 提升代码质量：严格模式要求更规范的编码方式，可以帮助开发者编写更加健壮、可靠的代码，提升代码质量。
3. 避免全局变量污染：在严格模式下，禁止隐式声明全局变量，可以避免全局变量污染，提高代码的可维护性和可读性。
4. 提高性能：严格模式下的代码通常比非严格模式下的代码更优化，因为严格模式下的一些特性可以让 JavaScript 引擎进行更好的优化。

总的来说，开启 JavaScript 的严格模式可以帮助开发者编写更加规范、健壮的代码，提高代码质量和性能，避免一些常见的问题和错误。因此，推荐在项目中使用严格模式来编写 JavaScript 代码。

## ESlint 傻瓜式配置办法

https://blog.csdn.net/qq_41581588/article/details/130052727

不需要手动安装一堆 eslint 插件，只安装 eslint 直接 init 初始化一个配置选完就好了，自动安装多个 eslint 依赖。

另外即便选择了 typescript，还是需要手动去配置文件里配置的。

其他一些报错 eslint 的也可以参考这里面的解决办法。

另外，yarn init 和 npm init 执行不一样后者才是初始化 eslint 前者是初始化一个 package.json

可以在 eslintrc.cjs 文件的 rules 下进行配置 关闭一些不需要的配置。

## ENV 文件内部变量新增 ts 提示。

https://cn.vitejs.dev/guide/env-and-mode.html#intellisense

这样 使用 import.meta.env 的时候就有提示了。

## html 中使用 env 中变量

语法是%env 中变量名% 如果没有那个变量 则会显示字符串你使用的内容%env%

## Pinia 支持两种语法 组合式和选项式

组合式和 vue 组合式 api 一样使用 setup 函数然后内部定义响应式变量后 return 出来。

选项式就和 vue 的选项式是一样的，状态写在 state 里，然后最终把每个状态写到这个 store 实例的根属性上。

也不是把状态写到 store 的根属性，实际上是在根属性上为$data(data)，store是$state 加上了代理，直接通过根属性访问等于访问的是 data 或者 state 中的数据源。

打印 vm 中的 this 上的 data 中的根属性，发现其是一个 get get return data[key] 而 methods 中的方法不是 get 而是直接是一个方法。

但是 pinia 不是，他根属性是值，不是 get，他的 state 居然是 get ()=>hot ? hotState.value : pinia.state.value[$id]

vue3 的 data 居然也是 get ()=>publicPropertiesMap[[key](instance)]

单个 store 中的 state 是从 pinia 这个 pinia 应用身上的 state 中根据 id 作为 key 取到的，也就是说咱们所有定义的 state 都存在了 pinia 应用实例身上。

我打印了 vue3 的应用实例 app 发现其身上除了 use provide unmount directive component mount 等等属性和方法外，还有\_component 根组件或者说组件树结构

**\_context**存折全局上下文内容，主要包含如下：

app 自身 components 全局组件

propsCache 存着全局的 props **emitsCache** 全局 emits

optionsCache 存着全局所有组件的 options

倒是没找到缓存全局 data 的 key。

## vue 组件实例扩展

instance（实例） 一个 vue 组件就是一个实例，组件实例对象身上有很多方法。

再 vue3 中 每个组件实例都是一个 proxy 对象，可以通过这个 proxy 对象来获取 data 中的数据与 methods 方法和 computed 计算属性从根属性上。

而这个组件真正的实例对象则存在\_这个属性身上，这个属性和 vue2 的组件实例对象很像都有 uid，data，props 等等。

而 vue 实例 proxy 对象身上除了咱们定义的方法属性外，其他的$data $ el 等属性 都是 get 方法 **() => publicPropertiesMap[key](instance)**（instance） 这个 instance 就是当前组件的*属性 也就是实例 也就是说哪些属性也是通过*这个组件实例身上来获取属性的。

```javascript
const publicPropertiesMap =
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
```

publicPropertiesMap 本质上是一个 Map 数据结构，其中每个属性都是一个方法，方法接受 instance 然后输出对应的内容，其实就是组件 proxy 快速访问实例身上的属性。

而 proxy 根属性上的数据也是 get 获取的 get ()=>data[key] data 也是 vue 内部定义的，方法直接就是方法赋值的。

setup 函数中定义的 data return 后也会出现在根属性上。

但是 setup 语法糖不会。不过 setup 语法糖里的顶层变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用

setup 函数可以直接 return 一个 render 函数，这是一个函数组件可以创建虚拟 dom。语法糖不可以。 attr 参数和 slot 也都是响应式的。

`setup`中返回的数据，还有官网中罗列的 `$el`，`$data`等都可以通过 `this`访问，底层是使用了 `Proxy`作为代理，当组件初始化的时，设置了代理对象。而这一过程中又设置了\_与 `$el`，`$data`等属性，使其可以通过 get 访问到对应的数据。

## pinia 组合式写法

要注意的是 pinia 组合式写的时候可以不用使用 ref 或者 reactive 去定义 state，前提是修改数据时通过 store.xx = 去修改 因为这个是 proxy 对象修改会触发响应式，如果通过 store 中的 function 去修改 state 不行，因为数据不是响应式数据，因此最好我们定义成响应式的，使用的时候 ref 的数据可以不.value，这是由于 `store` 是一个用 `reactive` 包装的对象，这意味着不需要在 getters 后面写 `.value`。 https://pinia.vuejs.org/zh/core-concepts/#using-the-store

## 为什么 vue 组件 data 是函数而不是对象

首先一个.vue 组件 包含了模板 脚本和样式 。

1. 解析：构建工具（如 Vue Loader）会解析 `.vue` 文件，将模板、脚本和样式部分分离开来。
2. 编译：模板部分会被编译成渲染函数，脚本部分会被转换成 JavaScript 模块，样式部分会被处理成对应的样式表。
3. 实例化：在 JavaScript 模块中，会创建一个 Vue 组件实例对象，该对象包含了组件的数据、方法、生命周期钩子等信息。
4. 挂载：最后，将这个组件实例对象挂载到页面上的某个元素上，使其可以渲染出对应的 UI。

而 data 的初始化就在组件实例化这一阶段。

https://www.pipipi.net/38792.html

根据文献与源码，大概能够得知是先有虚拟 dom，后有组件实例的。

https://segmentfault.com/a/1190000041535107?sort=newest

确实先有虚拟 dom 再有组件实例。因为组件实例中会用到虚拟 dom 中的一些属性。

```
createComponentInstance方法
```

```
applyOptions
```

这个方法来给组件实例通过 options 来 apply 方法和 data。

多个相同组件在渲染时用的是同一个 render 函数，也就是.vue 文件编译后的 render 函数，render 函数生产虚拟 dom，同时会创建组件实例，组件实例中的 data 来自于 options 中的 data，methods 中的方法会被添加到组件实例身上，`computed` 选项会被处理为计算属性，也会被添加到组件实例中，可以像普通属性一样访问，但是会根据依赖的数据动态计算。

而这个 options 中的 data 是共享的，一个组件被使用多次是同一个 render 函数调用生产虚拟 dom 的，而这个虚拟 dom 和组件实例的 data 也是取自同一个 options 对象的 data，如果 options 的 data 是对象，那就导致多个组件实例的数据源指向同一对象，因此需要设置一个函数，每次需要实例化的时候调用 data 函数返回一个新的对象。

.vue 组件编译完后会导出一个对象，template 会编译成 render 函数 其他的 options 会原封不动的导出，setup 组件 导出 setup 函数。

后续创建 vnode，创建组件实例都要用到这些 options，因为这个编译好的 sfc 对象是不变的，后续创建组件实例和 vnode 的时候基于这个 sfc 对象的 data，如果 data 是对象，那么数据就会共享，因此要设置成函数。

https://cn.vuejs.org/guide/scaling-up/sfc.html#single-file-components

https://blog.csdn.net/qq_36348403/article/details/136525629

setup 里使用的组件，不会出现在实例的 components 属性中。

https://zhuanlan.zhihu.com/p/612336916

深入组件初始化与响应式。

https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js

vue 源码。

## volar 和 prettier 冲突解决

代码格式化选择默认 prettier。

## letter-spacing

letter-spacing 是可以设置小数的，比如 0.9px 0.8px 设置的是文字间距。

## ::after 伪类元素会受当前元素的 css 影响比如文字渐变色等等，本质上他属于当前元素子元素。

## 文字渐变色

background: linear-gradient(left, #ff0000, #ffff00); // 背景渐变色

background-clip: text; // 以文字的范围来裁剪背景图片 简单来说就是可以做一个带背景的艺术文字效果

-webkit-text-fill-color:transparent; // *text-fill-color*是 CSS3 中的属性,表示文字颜色填充 把裁剪缕空的文字弄透明，这样就可以通过缕空的形状看到背景颜色，这时背景颜色就是字体的颜色

https://www.jb51.net/css/728441.html

## eslint 报错说找不到 ref reactive 方法解决办法

https://blog.csdn.net/webbirds/article/details/127283504

## ts 声明 props 类型且设置默认值

```typescript
// 枚举的声明方式
enum ButtonType {
  default = "default"
}
// 声明泛型propsType
type propsType = {
  // type可传可不传
  type?: ButtonType
}
// 使用vue的语法糖withDefaults声明类型检查props以及default默认值
const props = withDefaults(defineProps<propsType>(), {
  // 这里default要用枚举的方式声明 而不是直接写成"default"
  type: ButtonType.default
})

console.log(props)
```

使用 ts 好处是 vue 自带的 props 校验仅仅针对生产环境，而 ts 编译时即可找出问题。

## linear-gradient 参数学习与使用

inear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。

参数
方法：linear-gradient(direction, color-stop1, color-stop2, ...)

direction：第一个参数表示渐变的方向。其可以是一个具体的角度值如 45deg，或者是具体的方向值如 to top，表示自下而上渐变；to bottom 表示自上而下渐变【默认为 to bottom】，还有 to right、to left 等。

color-stop：渐变色的起止位置，通常是颜色加起始位置百分比。如 red 10%等。

不写起止位置默认去平分。0deg 由下到上渐变，先写的颜色在下，后写的颜色在上。

不写 0deg 默认的由上到下渐变，先写的颜色在上 后写在下 可以认为是 180deg

https://blog.csdn.net/Bekind2010/article/details/130269260

## 双引擎架构 Vite 如何实现？

https://segmentfault.com/a/1190000043784798

开发环境 esbuild

生产环境 rollup 不过代码压缩也用了 esbuild 因为快 rollup 有自己的 ts 编译插件

## vite 预构建

https://cn.vitejs.dev/guide/dep-pre-bundling.html

vite 构建完毕后会在 node_modules 中有缓存，只要不更改如 viteconfigjs 或者删除新增依赖就不会重新构建依赖。 因为依赖常常是不需要被更改的，预构建后会大大提高效率。不必每次都去转换依赖。

https://juejin.cn/post/7310439736828117046?searchId=20240407095912EAA9C5FA0F7CEF7F3563 深入浅出 Vite5 中依赖预构建

## rollup 内置了 ts 依赖插件来打包 ts

## vue-tsc 需要 typescript 依赖

## npm run vite build 过程发生了什么

https://juejin.cn/post/6887013512364130311

rollup 和 esbuild 都会执行 vite.config.json 都会执行其中的 plugin 因此.vue 的转换是 @vitejs/plugin-vue 实现的

## video 不设置大小默认是视频自身宽高

## [Vite 是如何实现 Esbuild 打包的](https://segmentfault.com/a/1190000043980887)

https://segmentfault.com/a/1190000043980887

https://www.jianshu.com/p/7b9fa3a4969b

开发环境是请求发送的时候，vite 服务才开始编译 module 然后返回的，而不是一开始就编译好的。 如果缓存中已存在直接返回已经编译好的。 当然这里不包含已经预构建的依赖，仅针对咱们写的 css 和.vue .js 等文件。

每个组件在客户端被请求的时候都会在头部引入热更新的模块。

## plugin 和 loader 的区别

https://blog.csdn.net/qq_38290251/article/details/134212725

https://blog.csdn.net/baidu_21919557/article/details/134973258

vite 中貌似取消 loader 了，只有 plugin 了

## 为什么 vite 服务浏览器可以使用 ts 文件直接

因为 ts 的响应标头是 text/javascript

另外 vite 自身即可编译 ts 装 ts 依赖是为了使用 vue-tsc 进行类型检查

## 滚动条样式修改

```css
::-webkit-scrollbar {
  // 滚动条宽高  x轴是高度 y轴是宽度
  width: 6px;
  height: 6px;
}
// 滚动条滑块得样式 可以使用背景色渐变
::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom right, #4d7fff 0%, #1a56ff 100%);
  border-radius: 5px;
}
// 滚动条轨道
::-webkit-scrollbar-track {
  background-color: #ddd;
  border: 1px solid #ccc;
}
// 滚动条两侧按钮
::-webkit-scrollbar-button {
  background-color: #4d7fff;
  border-radius: 5px;
}
// 按钮悬浮样式
::-webkit-scrollbar-button:hover {
  background-color: #999999;
}
```

## [`assetsInclude` 选项](https://cn.vitejs.dev/config/shared-options.html#assetsinclude)

作用是声明可以被 import 导出的资源。

https://cn.vitejs.dev/guide/assets.html#static-asset-handling

https://cn.vitejs.dev/config/shared-options.html#assetsinclude

## enum 类型说明

enum 枚举类型最终编译后是一个对象，而不是数组，另外它的声明方式和对象很像 key value 的形式，如果默认只写 key 则会默认是 key = 0 key = 1 的形式 编译成一个对象。

https://www.jb51.net/javascript/30299895t.htm

枚举想要赋值字符串的时候必须要使用枚举的属性，而不能直接写字符串 否则报错，但是数值可以直接赋值

成员可以是字符串也是数值，不允许使用其他类型的值。

## props 踩雷记录

```javascript
const customClass = {
  small: props.size === "small",
  "super-large": props.size === "super-large",
  default:
    !props.size || props.size === "default" || props.size === "super-large",
  disabled: props.disabled
}
// 这里我声明了一个对象 来保存所有的class 然后template中使用它 但是我发现没有数据驱动视图，原因在于对象中的属性一开始就是固定的了，props在使用时已经变成了值。

// 至于我们使用对象形式父传子 以及template中不写props直接使用props的属性都是可以的
```

## 全局组件用不用最终都会打包进去 因此最好还是按需导入。

## icon 图标自动导入

https://github.com/sxzz/element-plus-best-practices/blob/db2dfc983ccda5570033a0ac608a1bd9d9a7f658/vite.config.ts#L21-L58

```javascript
// 自动导入图标组件
        IconsResolver({
          prefix: 'Icon',
        }),
// 自动注册图标组件
        IconsResolver({
          enabledCollections: ['ep'],
        }),
```

这段配置代码是一个 webpack 插件配置的示例，主要包含了三个插件的配置信息。让我来分析一下这段代码：

1. **AutoImport 插件**:

   - 这里配置了 AutoImport 插件，用于自动导入模块。
   - 在 resolvers 中配置了 IconsResolver，表示使用 IconsResolver 来解析图标。
   - IconsResolver 配置了 prefix 为 'Icon'，表示导入图标时的前缀为 'Icon'。

2. **Components 插件**:

   - 这里配置了 Components 插件，用于处理组件相关的逻辑。
   - 在 resolvers 中配置了 IconsResolver，表示同样使用 IconsResolver 来处理组件。
   - IconsResolver 配置了 enabledCollections 为 ['ep']，表示启用特定的图标集合 'ep'。

3. **Icons 插件**:

   - 这里配置了 Icons 插件，用于处理图标相关的逻辑。
   - Icons 插件配置了 autoInstall 为 true，表示自动安装图标。

总的来说，这段配置代码主要是在配置 webpack 插件，其中 AutoImport 插件用于自动导入模块，Components 插件用于处理组件逻辑，Icons 插件用于处理图标逻辑。IconsResolver 被用于处理图标相关的逻辑，并根据配置参数来解析和处理不同的图标集合。希望这个分析对您有帮助。如果您有任何其他问题，请随时告诉我。

我们配置完毕后 会自动下载安装 ep 模块的 icon 然后就可以通过 i-ep-xx 在组件中使用了 并且需要注意的是不再需要手动安装 element-icon 的依赖了

自动导入是从 iconify 中导入图标的，elementplus 中的 icon 默认基于这个图标库

naiveui 和 antdesign 我看官网没有提供自动导入图标的功能

ep 是一个集合，意思是 elementplus 的 iconify 图标库中的 ep 集合。

## vite-plugin-inspect

vite-plugin-inspect 插件的作用是用于在 Vite 构建过程中检查和调试插件的工具。它可以帮助开发者更好地了解和分析 Vite 插件在构建过程中的执行情况，以便进行问题排查和优化调整。

通过 vite-plugin-inspect 插件，开发者可以查看插件在 Vite 构建过程中的执行顺序、输入输出信息、插件钩子的调用情况等，从而更好地理解插件的工作原理和影响。这有助于开发者调试和优化自定义插件，提高构建过程的效率和质量。

总的来说，vite-plugin-inspect 插件提供了一种方便的方式来检查和调试 Vite 构建过程中的插件，帮助开发者更好地理解和优化他们的自定义插件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

目测可以查看每个插件对源码的编译修改过程，和 svn 有点像，并且可以通过 source-map-visualization 来查看我们写的代码编译后对应的代码关系。

scss 编译成 css，然后编译成 js 返回，不过返回我们的文件后缀还是 scss，在 network 看的话。

并且 css 也会编译成 js 返回给我们。

自动导入默认是绝对路径导入的，编译后才变成相对路径。

ts 文件是 esbuild 编译的。

## yarn install 报错 There appears to be trouble with your network connection. Retrying 解决办法

https://blog.csdn.net/qq_45503196/article/details/127468032

当然，让我为您解释每一行命令的作用：

1. `yarn config list`:

   - 这个命令用于查看当前 yarn 配置的所有设置，包括代理、镜像源等信息。

2. `yarn config delete proxy`:

   - 这个命令用于删除 yarn 的代理设置，如果之前设置了代理，执行这个命令会将代理设置移除。

3. `npm config rm proxy`:

   - 这个命令用于删除 npm 的代理设置，如果之前设置了 npm 的代理，执行这个命令会将代理设置移除。

4. `npm config rm https-proxy`:

   - 这个命令用于删除 npm 的 HTTPS 代理设置，如果之前设置了 npm 的 HTTPS 代理，执行这个命令会将 HTTPS 代理设置移除。

5. `yarn config set registry https://registry.npm.taobao.org`:

   - 这个命令用于将 yarn 的包管理器镜像源设置为淘宝镜像源，这样在安装包时会从淘宝镜像源下载，可以加快包的下载速度。

通过执行这些命令，您可以管理代理设置并将包管理器的镜像源设置为淘宝镜像源，以提高包的下载效率。希望这些解释对您有帮助。如果您有任何其他问题，请随时告诉我。

很好的问题!让我来解释一下 npm 和 yarn 设置代理以及 HTTPS 代理的用途:

1. **设置代理的用途**:

   - 代理服务器可以帮助我们绕过一些网络限制,比如某些地区无法直接访问某些网站或资源。
   - 通过设置代理,我们可以将对这些受限资源的请求转发到代理服务器,由代理服务器来访问这些资源,然后将结果返回给我们。
   - 对于 npm 和 yarn 来说,设置代理可以帮助我们绕过网络限制,从而更顺利地下载所需的包和依赖。

2. **HTTPS 代理的用途**:

   - HTTPS 是一种加密的网络传输协议,用于保护网络通信的安全性。
   - 当我们需要访问使用 HTTPS 协议的资源时,如果直接使用 HTTP 代理可能会出现问题。
   - 此时我们需要设置 HTTPS 代理,让代理服务器能够正确地处理 HTTPS 协议,确保我们能够安全地访问这些资源。
   - 对于 npm 和 yarn 来说,如果需要下载使用 HTTPS 协议的包和依赖,设置 HTTPS 代理就变得很重要。

总的来说,设置代理和 HTTPS 代理可以帮助我们绕过网络限制,更顺利地使用 npm 和 yarn 下载所需的包和依赖。这在某些受限网络环境下非常有用。希望这个解释对您有帮助!如果还有其他问题,欢迎继续询问。

代理是为了脱离网络的限制，以及网站屏蔽。 代理相当于一个中间人的角色可以隐藏真实的 ip 地址，同时还可以绕过可能存在的网络限制。

https://blog.csdn.net/lihefei_coder/article/details/119906244

https://wenku.baidu.com/view/72a0355430d4b14e852458fb770bf78a65293afe.html?_wkts_=1714213019069&bdQuery=npm%E4%BB%A3%E7%90%86%E4%BD%9C%E7%94%A8

如果您已经将 npm 镜像源设置为国内镜像（比如淘宝镜像或者 cnpm），通常情况下是不需要再配置代理地址的。国内镜像源已经帮助您加速了对 npm 包的访问，通常可以满足大部分用户的需求。

但是，如果您在使用国内镜像时仍然遇到网络访问问题，比如下载速度很慢或者无法连接到镜像源，这时可能需要考虑配置代理地址来帮助解决网络问题。代理服务器可以帮助您绕过网络限制或提高下载速度，有助于解决一些网络访问方面的困难。

总的来说，如果您使用了国内镜像并且网络访问正常，通常情况下是不需要额外配置代理地址的。但如果遇到网络问题，可以考虑配置代理来解决。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

https://blog.csdn.net/weixin_51341201/article/details/134391607

删除代理会解决这个问题，镜像还是用淘宝的。

## vite 初始化与钩子

https://blog.csdn.net/xiangzhihong8/article/details/130931082

https://blog.csdn.net/u012384510/article/details/124287604

## 为什么已经使用了 Components 插件来自动导入 vue 组件了，但是 autoImport 里还有 include 声明 vue 文件呢？

因为 autoimport 中导入的一些 js 与组件 不属于 components 的范畴 比如 elmessage。

## 为什么已经安装了 element 图标库 使用自动导入图标时候还会自动安装 ep 图标库呢

后经过我测试 不需要安装 element 图标库了。

## inset boxshadow 内阴影 外阴影看起来会改变盒子大小 内阴影不会 阴影本身不会改变元素大小 0 0 0 npx 看起来像是边框

## flex 和 line-height 不会影响不同文字大小在同一容器内垂直位置上居中对齐。

也就是说垂直居中 使用 line-height 不能让文字每一段文字 字号不同大小写不同，但都对盒子中心居中对齐. 文字默认有自己的对齐方式，就是根据文字基线来。

而 flex align-items center 也不能保证 所有文字垂直居中对齐，文字有自己的高度。但总体还是大差不差的。

总结 数字 大写字母 汉字 使用 line-height + **vertical-align**: **middle**;是可以实现文字居中的效果和 flex ac 一样 但小写字母不同 小写字母只是 显示小但是默认其高度是和大写字母一样高的 导致看起来 没有居中对齐而是偏下了，最好的所有文字居中对齐 还得是 flex

https://www.cnblogs.com/BigFatStar/p/13442914.html

## flex 只能保证子盒子位置 但是不能保证子盒子内部的盒子位置

## 自动导入的一些补充

https://blog.csdn.net/weixin_45366616/article/details/134469304

https://blog.csdn.net/qq_38845858/article/details/137112474

https://blog.csdn.net/qq_42611074/article/details/123036252

## template 中函数传参细节

如果 template 中函数传参用到了 ref 那么实参拿到的也是 ref 解包后的参数 不需要.value 了

## ts 变量后边的问号和感叹号区别

例如 form？.xxx 意思是 form 存在才调用后面方法，不存在不调用，!号意思是此时一定不为空直接调用

?.是 js 的不是 ts 的，我才知道

## ？。和？？

在 JavaScript 中，`?.` 和 `??` 是两种比较新的语法，分别表示可选链操作符（Optional Chaining Operator）和空值合并操作符（Nullish Coalescing Operator）。

1. **可选链操作符 `?.`**:

   - 可选链操作符 `?.` 用于简化访问深层对象属性时的代码，避免出现 `TypeError` 错误。
   - 当使用 `?.` 时，如果对象的前一个属性为 `null` 或 `undefined`，则整个表达式会立即返回 `undefined`，而不会继续访问后面的属性。
   - 例如：`obj?.prop1?.prop2`，如果 `obj` 或 `prop1` 为 `null` 或 `undefined`，则表达式会返回 `undefined`，而不会抛出错误。

2. **空值合并操作符 `??`**:

   - 空值合并操作符 `??` 用于提供一种更严格的空值判断，只有在值为 `null` 或 `undefined` 时才会返回其右侧的值。
   - 与传统的逻辑或操作符 `||` 不同，空值合并操作符 `??` 不会将空字符串 `''`、数字 `0` 或布尔值 `false` 视为 `null` 或 `undefined`。
   - 例如：`const result = a ?? b`，如果 `a` 的值为 `null` 或 `undefined`，则 `result` 的值为 `b`，否则为 `a` 的值。

这两种操作符的引入使得 JavaScript 代码更加简洁和易读，同时提高了处理空值和深层属性访问的便利性。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

??对比||的优点是，??只有在一边是 null 和 undefined 的时候才会返回另一侧的值 而|| 则必须另一侧的值不为能转成布尔 false 的值才返回，前者对比后者是可以返回布尔值 空字符串 0 等的 而后者不行。 好处是如果后端返回我们是 0 或者"" 我们也可以认为他返回值了 而不是没有。

## autoimport 配置中 imports 不能直接自动导入只包含一个 export default 的包

比如 axios lodash 这种包只默认导出了一个 export default 会报错 除非手动写成对象形式才行

另外 ts 导出的文件 只可以默认在 ts 类型的中 默认导入 js 不行 同理配置的 tsconfig 中@ 这种别名 也只能在支持 ts 的文件中用 js 不行，除非手动在 tsconfig.json 中设置 allowJStrue

目前发现类型是无法自动导入的，无论是 element 的还是自己定义的以后尝试网上有没有解决办法。

## checkJs 和 allowJs

在 TypeScript 的 `tsconfig.json` 配置文件中，`allowJs` 和 `checkJs` 是两个不同的选项，它们分别用于处理 JavaScript 文件的情况。

1. **`allowJs` 选项**：

   - `allowJs` 是一个布尔类型的选项，用于指定是否允许在 TypeScript 项目中包含 JavaScript 文件（.js 文件）。
   - 当 `allowJs` 设置为 `true` 时，TypeScript 编译器将允许在项目中引入 JavaScript 文件，并对这些 JavaScript 文件进行类型检查和编译。
   - 这个选项通常用于逐步迁移现有的 JavaScript 项目到 TypeScript，或者允许在 TypeScript 项目中使用一些第三方库的 JavaScript 版本。

2. **`checkJs` 选项**：

   - `checkJs` 也是一个布尔类型的选项，用于指定是否对 JavaScript 文件进行类型检查。
   - 当 `checkJs` 设置为 `true` 时，TypeScript 编译器将对引入的 JavaScript 文件进行类型检查，类似于对 TypeScript 文件的处理。
   - 这个选项可以帮助在引入 JavaScript 文件时提供更好的类型检查和代码质量保证。

综合来说，`allowJs` 用于控制是否允许引入 JavaScript 文件，而 `checkJs` 用于控制是否对这些 JavaScript 文件进行类型检查。在需要逐步迁移项目或者引入第三方 JavaScript 库时，可以结合使用这两个选项来更好地管理 TypeScript 项目中的 JavaScript 文件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

## 有时候自动导入没有生效，原因可能是代码没有编译由于其他报错，需要重新编译一下就自动解决了

## elementplus 中的表单验证 ref 通过 ref 使用泛型可以 通过 Ref 就报错 哦 原因是因为忘记默认 undefined 了

## setInterval 类型是 NodeJs.timeout 赋值给变量复制成这个|null

## axios 返回值类型设置

https://juejin.cn/post/6969070102868131853

## vue3+ts 在获取接口响应数据时，在 ts 中报错 类型“AxiosResponse ＜ any, any ＞”上不存在属性“state”

https://blog.csdn.net/m0_57033755/article/details/128547409

declare module "axios" 扩展 axios

## upload 组件注意事项

upload 组件 file-list 参数不要用 v-model 绑定，要用自定义属性，否则不好控制 file-list 内容 因为 onchange 事件执行在前 v-model 执行在后,另外如果不想让默认的上传列表出来 不能直接设置 file-list = [] 而是要手动 on-change 里设置 file-list = []

## elementplus 表单重置事件

elementplus 表单重置事件 不是重置成表单默认值，而是重置成当前这个表单创建时的初始值。
假如表单创建的时候 form 的值已经变化了 则以 form 的当前值为初始值

## 选中当前元素的后一个兄弟元素与 has

https://blog.csdn.net/sdgfafg_25/article/details/137006174

:has() 可以选择括号內部指定元素的父元素

比如 :has(p) 意思是所有元素内部包含 p 元素的父元素

:has(>p) 意思是所有 一级子元素是 p 的父元素

选择直接（一级）后代元素包含 `<p>`元素的父级标签名是 `div`父元素：

```css
div: has(> p);
```

:has(+ p) 表示 p 前的兄弟元素唯一一个

:has(~p) 表示 p 前全部的兄弟元素

## 文字颜色变化也可以做过度效果 用过度或者@property 或者动画

@property 的用法和正常修改属性一样 hover 的时候只会修改当前的 css 变量 而非全局的 全局的照常用

## 设置盒子宽度从中间往两边展开 简单 flex aligncenter 布局 或者 margin 0 auto 只要让元素在父元素中心 他边宽自然由中心往两侧

## declare module 'axios'

https://blog.51cto.com/u_16213444/7044433

不要忘记导入 AxiosRequestConfig 类型 否则会默认认为 config 是一个 any 类型 从而报错

```typescript
declare module "axios" {
  interface AxiosInstance {
    // config confiog配置类型
    (config: AxiosRequestConfig): Promise<any>
  }
}
```

不能在 axios 类型扩展的时候使用 ResponseType 类型 因为 axios 中有这个 默认会使用这个 不用我们自己定义的

这里的 any 可以换成任意 interface 这样我们 then 的时候 的数据就是这个类型了 舒服了 这样我们解包的 data 就不会被认错 不知道是不是解包的了。

不过 http 封装的地方 use 响应拦截器的回调的第一个参数倒是不知道如果设置 data 类型 不过也无所谓 因为 axios 默认了那个类型是 any 且不会被 ts 报错。

当我们把 promise `<any> 换成interface后 那么 use 响应拦截器第一个参数会和axios.then 的res的类型 保持一致 虽然接口名不同 但类型一样 并且可以获得类型提示。`

另外 想要扩展 module 的时候一并扩展其中的 interface 则要写在 module 中 定义 interface 定义外面无效。

## 判断当前路由是否存在项目中

好多种做法第一种 hasRoute 这个缺点是只能通过路由 name

第二种直接通过 routes 去 some

第三种 **currentRoute** 的 component 是否存在

## TS \_参数 表示这个参数用不到

## history 模式后端配置

这段代码是一个 Nginx 服务器配置文件的一部分，用于配置一个简单的 Web 服务器。让我为您解释一下这段代码的各个部分：

1. `server`：这是 Nginx 配置文件中定义一个服务器块的关键字，表示接下来是一个服务器的配置信息。
2. `listen 8080`：这一行指定了服务器监听的端口号为 8080，表示服务器将会在 8080 端口上接收传入的请求。
3. `server_name localhost`：这一行指定了服务器的域名为 localhost，表示服务器将会响应来自 localhost 的请求。
4. `location /`：这是一个 Nginx 配置中的 location 块，用于匹配请求的 URL 路径。
5. `root 'E:\dist'`：这一行指定了服务器的根目录为 'E:\dist'，表示当匹配到该 location 时，Nginx 会在 'E:\dist' 目录下查找相应的文件。
6. `index /index.html`：这一行指定了默认的索引文件为 /index.html，表示当请求的路径是一个目录时，默认会返回 index.html 文件。
7. `try_files $uri $uri/ /index.html`：这一行定义了 Nginx 在尝试查找文件时的策略。它会依次尝试查找与请求 URI 匹配的文件（$uri）、目录（$uri/），如果都找不到，则返回 /index.html 文件。

综合起来，这段配置文件的作用是配置一个 Nginx 服务器，监听在 8080 端口上，当收到来自 localhost 的请求时，会在 'E:\dist' 目录下查找相应的文件，如果找不到则返回 index.html 文件。这样可以实现一个简单的静态文件服务器，用于提供 Web 页面的访问。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

https://blog.csdn.net/muzidigbig/article/details/121892336

## 谷歌浏览器禁止跨域解决办法

https://blog.csdn.net/qq_17627195/article/details/129203873

## flex 布局 父元素不设置宽度 默认会铺满 但是子元素默认是内容宽度

子元素可设置宽度

## 扩展 window 对象

```typescript
declare global {
  interface Window {
    $message: MessageApiInjection
  }
}
```

https://juejin.cn/post/7154527027599507486

https://www.jb51.net/javascript/320281bmm.htm

declare global 是扩展全局作用域 可以扩展 window String 以及第三方库全局类型

当使用第三方库时,如果该库没有提供类型定义文件(`.d.ts`),可以使用 `declare global` 来声明它的全局类型。

浏览器中有 self 和 globalThis 他们在浏览器中都指向 window

nodejs 有 global 和 globalThis 他指向 node 全局变量 如下

```javascript
<ref *1> Object [global] {
  global: [Circular *1],
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  queueMicrotask: [Function: queueMicrotask],
  structuredClone: [Getter/Setter],
  atob: [Getter/Setter],
  btoa: [Getter/Setter],
  performance: [Getter/Setter],
  fetch: [Function: fetch],
  crypto: [Getter]
}
```

```typescript
declare global {
  interface Window {
    $message: MessageApiInjection
    $appName: string
    $showLoading: () => void
    $hideLoading: () => void
  }
  // 拓展一个全局可用的函数 本质上其还是在window上,只不过上面这种写法使用时前面必须加window，而后者不需要
  function globalFunction(): void
  interface Global {
    myCustomProperty: string
    myCustomMethod(): void
  }
}
```

总结起来，`self` 在浏览器环境中指向全局的 `window` 对象，`global` 是非标准的全局对象，而 `globalThis` 是在 ECMAScript 标准中引入的通用全局对象，可用于访问全局作用域无论是在浏览器还是其他 JavaScript 运行时环境中。

因此我们扩展 window 变量的时候，需要 declare global 因为 window 属于 global 的子集

https://www.jianshu.com/p/3e3029000629

ts enum 枚举不仅会定义类型 还会导出一个对象 但 interface 不会

并没找到 globalThis 变量的拓展方法 只有 window 和全局的拓展

globalThis 可以在浏览器 webworker nodejs 三端通用 分别指向他们对应的全局变量

## TS — 命名空间的定义

https://blog.csdn.net/sjsjsjsj1010/article/details/129988212

命名空间最终会转换成一个对象

## 同时配置 alias 目录和相对路径目录相同时 vite 优先使用前者 除非手动指定相对路径./ 不写./ 默认前者

## new URL 定义文件导入路径的时候，正常应该.href，如果没有.href，使用的时候 template 中会自动使用.href 但 ts 会报错。

## 浏览器会把 0.1 和 0.9 的 border 渲染成 1px 想要小数 border 需要用盒子宽度做 比如 before 伪元素

https://www.cnblogs.com/ranyonsue/p/17236067.html

## flex: 0 0 xxpx / 3 的原理是什么

flex 属性是一个整合属性包括了[flex-grow**](https://m.baidu.com/s?word=flex-grow&sa=re_dqa_zy)、[flex-shrink**](https://m.baidu.com/s?word=flex-shrink&sa=re_dqa_zy)和[flex-basis**](https://m.baidu.com/s?word=flex-basis&sa=re_dqa_zy)三个部分

flex-grow 表示当前元素 占用父元素剩余空间的比例

[flex-shrink](https://m.baidu.com/s?word=flex-shrink&sa=re_dqa_zy) 表示缩放比例

flex-basis 表示当前元素占主轴大小的初始值,优先级高于 width 低于 flex-grow

https://answer.baidu.com/answer/land?params=1U1qENvXv%2BoPp5DJ4v%2FK3vpMBZGBNI8sHOVbdbTJD4ZjvJonwTdcCm0RMR1jIYHhQmhaKhxEJeyhIGvs82SMzc9aKE9xLmO7Jsu5RCAqTk3xVKaNd5tJYFznubx7kxuCRQxCpbrxlz%2BKxD%2BSjEKZ1Ha87Zrc04Z771JCa0RvQSQGdJm7qL7dm80HT5KCPMykFLvcJMEA5B47VdrTUvot8A%3D%3D&from=dqa&lid=d86e765d0056df00&word=css%20flex%E5%B1%9E%E6%80%A7

## new URL 也可编译 tsconfig 中的 alias src 也可以 background 也可以 除了 cesium 中的路径不行

也就是配置的路径

## html 横向纵向滚动条样式分别设置

在 WebKit 浏览器中，实际上并没有 `::-webkit-scrollbar-y-thumb` 和 `::-webkit-scrollbar-x-thumb` 这样的伪元素。要设置滚动条的滑块样式，您需要使用通用的 `::-webkit-scrollbar-thumb` 伪元素，并结合 `orientation` 属性来区分纵向和横向滚动条。

以下是正确的示例代码：

```css
/* 纵向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  width: 12px; /* 纵向滚动条宽度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 纵向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:vertical {
  background: #888; /* 纵向滚动条滑块颜色 */
}

/* 横向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  height: 12px; /* 横向滚动条高度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 横向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:horizontal {
  background: #888; /* 横向滚动条滑块颜色 */
}
```

通过在 `::-webkit-scrollbar-thumb` 中使用 `:vertical` 和 `:horizontal` 伪类，可以分别设置纵向和横向滚动条的滑块样式。这样就可以实现分开设置纵向和横向滚动条样式的效果。

## 有时候设置 flex align-items center 发现图片和文字无法居中对齐。

原因是因为字体会有自己的 line-height 默认的， 在这个 line-height 里文字可能不是在最中心的，因此最好单独设置 line-height 与父盒子相等，不过要视情况而定。

https://blog.csdn.net/lucklymm/article/details/125523258

## flex 多行布局 侧轴样式设置

https://blog.csdn.net/shulianghan/article/details/130547207

align-content 样式说明

## 盒子装载图片时出现的盒子比图片实际偏高的问题

https://blog.csdn.net/m0_51404378/article/details/121095574

## 监听滚动事件与设置固钉 原生写法

```typescript
const quickActions = ref<HTMLElement>()
onMounted(() => {
  bodyHeight.value = document.body.clientHeight + "px"
  // scroll事件的触发对象只能是 window document 或者有滚动条的盒子
  window.addEventListener("scroll", function () {
    // 根据滚动 不停修改滚动条位置
    quickActions.value!.style.top = `calc(${window.scrollY}px + 50vh - ${
      quickActions.value!.offsetHeight / 2
    }px)`
  })
  quickActions.value!.setAttribute(
    "style",
    `top: calc(50vh - ${quickActions.value!.offsetHeight / 2}px)`
  )
})
```

## nth-child 和 nth-of-type

nth-child 想要选中某个元素 前面跟想要选中的元素 意思是选中这个父元素中第 n 个元素且这个元素是 我们前面规定的元素。 位置+类型必须一致

而 nth-of-type 放在需要被选中的元素后面使用 意思是父盒子中第几个当前类型的元素被使用，它指的是当前元素。位置不一致 类型一致就行 因为位置是父元素中第 n 个类型符合的元素

nth-last-child 和 nth-last-of-type 是从后往前数。

## 前端配置 VITE_APP_BASE_API 作用

开发环境默认配代理路径就行，开发时会请求本机地址然后通过代理访问后端服务。

生产环境上线地址配置为空 或者/ 默认就会请求项目的服务器所在地址 后端会通过 nginx 转发到真实的后端服务地址。

如果后端不想 nginx 转发，则需要我们上线时把地址写死（那不还是会出现跨域问题），能后端会把不同地址都配置成请求他本地测试吧。

## z-index 只能搭配 定位使用 绝对定位 相对定位 固定定位

相同父元素下 z-index 值越大 优先级约高 不同父元素下 先比较父元素的 z-index 谁大谁优先级高

## typscript 的面向对象以及多态重载说明

https://blog.csdn.net/hzether/article/details/134889424

多态就是继承与方法重写

重载就是根据参数不同执行方法的分支也会有所不同

ts 更多使用教程

https://blog.csdn.net/qq_47040462/article/details/132367100

## 前端工程化学习笔记

https://www.kancloud.cn/cyyspring/webpack/3079670

nodejs 中 全局作用域下 this 指向空对象 mjs 下指向 undefined

core-js 是完全模块化的 javascript 标准库。 包含 ECMA-262 至今为止大部分特性的 polyfill，如 promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的 WHATWG / W3C 特性的 polyfill，如 WHATWG URL。 它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入 core-js，仍然使用最新特性的 ES 写法编码即可；也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入 core-js 的相关 module，并可能还需要通过手工调用 module 完成编码，没法直接使用最新 ES 的写法。它是一个完全模块化的库，所有的 polyfill 实现，都有一个单独的 module 文件，既可以一劳永逸地把所有 polyfill 全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的 core-js 的 modules 文件。

注意 core.js 与 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill 的关系

babel-plugin-transform-runtime 是用来编译转换代码的 用到一些 ES 的方法 他会自动从 babel-runtime 中导入使用工具函数 以及其他一些 babel-runtime/corejs 中的 polyfill

babel-polyfill 基于 core-js 他是对 es6+方法的转换用 es5 的语法去实现他们，以及内置对象身上的方法。

`import "@bable/polyfill"` 的方式来实现针对 api 层面的“抹平”。然而从 babel v7.4.0 开始官方就不建议采取这样的方式了。

因为不能按需导入+污染全局变量。

现在 Babel7 的 presets 对 babel-polyfill 做了处理，新增"useBuiltIns": "usage"，这样只会加载代码中用到的部分，完美的按需加载，但是依然会污染全局变量。

babel-runtime 中也包含 polyfill，准确来说是 core-js，也就意味着 babel-runtime 和 babel-polyfill 二者有其一就可以了。

`babel-runtime` 不能转码实例方法比如

```
!!!'.repeat(3);
'hello'.includes('h');
```

这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。

随着历史进程的发展，新一代的 [babel-prenset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmaster%2Fpackages%2Fbabel-preset-env "https://github.com/babel/babel/tree/master/packages/babel-preset-env")出现了。

babel-runtime 使用与性能优化

https://juejin.cn/post/6844903615212027917

用了 babel 还需要 polyfill 吗？？？ https://juejin.cn/post/6845166891015602190?searchId=20240425105812792820EAF0C597F91626

关于 babel(精华又通俗) https://juejin.cn/post/6844904199554072583

结合 Babel 7.4.0 谈一下 Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879

babel-polyfill VS babel-runtime VS babel-preset-env

https://juejin.cn/post/6844903602822053895

前端工程化（7）：你所需要知道的最新的 babel 兼容性实现方案

https://juejin.cn/post/6976501655302832159

webpack 入门之 js 处理(babel、babel polyfill)

https://juejin.cn/post/7126465727178997791?searchId=20240425105812792820EAF0C597F91626

结合 Babel 7.4.0 谈一下 Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879?searchId=20240425105812792820EAF0C597F91626

实例探究 Babel 及 Babel 与 Webpack、Vue 之间的关系

https://juejin.cn/post/7051555571451265038?searchId=20240425105812792820EAF0C597F91626

@babel/preset-env 只支持语法转换比如箭头函数转普通函数，let const 转 var。 api 则需要 core-js 或者 babel/polyfill 或者 babel/runtime-corejs 来转换了。

@babel/preset-env babel7.0.0 之前的话一开始如果只使用 core2 的话 无法 polyfill 内置方法，还需要安装 babel/polyfill。 如果使用 core3 则不需要使用 babel/polyfill

并且 babel/runtime-corejs3 可以模拟实例或者说原型对象上的方法，而 babel/runtime-corejs2 不可以。

babel/polyfill 虽然也可以 但是被废弃了。

babel 一开始是会编译代码的，随着新版 babel 的发布，babel 的编译功能交给了插件，自身只作为一个平台，如果不安装任何插件 babel 编译的结果和源码是一样的。

配置 babel 有两种，插件(`plugin`)或者预设(`preset`)。 编译时插件会先执行，预设后执行。

@babel/preset-env 就是一个预设。他默认不会转义内置方法，需要搭配 babel-polyfill，他会对高级语法进行降级

babel/runtime-corejs2 不支持实例方法，3 支持。

babel/core 在转义代码的时候 是要使用插件去处理的。

`@babel/preset-env`本身在语法转换的时候，会使用一些辅助函数来实现一些语法的模拟。而事实的确，这只是一种语法转换。 也就是说 class 辅助函数是 `@babel/preset-env` 语法降级时候定义的。

`_classCallCheck` 是 Babel 编译后代码中的一个辅助函数，用于实现类的构造函数中的类似于 ES6 类中 `this` 的检查和初始化。这个函数通常是由 Babel 插件 `@babel/plugin-transform-runtime` 插入到编译后的代码中的。

在 ES6 类中，如果没有正确使用 `super` 关键字调用父类的构造函数，或者在构造函数中没有正确初始化 `this`，就会导致错误。为了处理这种情况，Babel 在编译 ES6 类时会插入 `_classCallCheck` 函数来确保正确的类继承和初始化。

因此，`_classCallCheck` 并不是 JavaScript 或 ES6 标准中的原生方法，而是 Babel 在编译过程中生成的辅助函数之一，用于确保类的正确使用和初始化。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

在使用 Babel 进行 JavaScript 编译时，`babel-runtime`、`babel-plugin-transform-runtime` 和 `babel-polyfill` 是三个常用的工具或插件，它们在项目中扮演着不同的角色：

1. **babel-runtime**：

   - `babel-runtime` 是 Babel 提供的一个运行时库，用于支持编译后代码的运行。它包含了一些 Babel 编译后代码中使用的辅助函数，例如 `_classCallCheck`、`_extends` 等。
   - `_classCallCheck`、`_extends`不是 babel-runtime 生成的，而是 babel 语法转换时自己生成的，但是 babel-runtime 中提供了封装好的函数供导入用。
   - 使用 `babel-runtime` 可以避免在每个编译后的文件中重复生成这些辅助函数，减小编译后文件的体积。
   - 通常通过安装 `@babel/runtime` 包来使用 `babel-runtime`。

2. **babel-plugin-transform-runtime**：

   - `babel-plugin-transform-runtime` 是一个 Babel 插件，用于在编译过程中将代码中的公共辅助函数替换为 `@babel/runtime` 包中的对应函数。
   - 这个插件可以帮助减小编译后代码的体积，并且避免在每个文件中重复生成相同的辅助函数。
   - 通过在 Babel 配置中添加该插件，可以实现对编译后代码的优化。

3. **babel-polyfill**：

   - `babel-polyfill` 是一个用于提供对新的 JavaScript 特性的兼容性支持的包。它会在全局作用域中注入一些缺失的 ECMAScript 特性和内置对象的方法，以便在旧版本的浏览器中运行新的 JavaScript 代码。
   - 使用 `babel-polyfill` 可以解决一些新特性在旧浏览器中不被支持的问题，但它会增加项目的体积。
   - 在使用 `babel-polyfill` 时，需要在代码中引入它，通常是在应用程序的入口文件中引入。

总结：

- `babel-runtime` 是 Babel 提供的运行时库，包含一些辅助函数。
- `babel-plugin-transform-runtime` 是一个 Babel 插件，用于优化编译后代码中的辅助函数。
- `babel-polyfill` 是用于提供对新特性的兼容性支持的包，在旧浏览器中运行新的 JavaScript 代码时可能会用到。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

## HTML+CSS 动画网

https://uiverse.io/Amerss/massive-robin-70

https://zhuanlan.zhihu.com/p/683609906

## 扩展 axios 请求 config 类型

https://www.cnblogs.com/qh1688/p/17457625.html

直接在扩展 axios module 的时候 export interface 想要扩展的属性就完事了 因为 interface 本身就支持多个 interface 合并

## VSCode 噴 Unknown at rule @tailwind 解決方式

https://israynotarray.com/tailwindcss/20220405/1504568293/

## tailwind 样式与自定义样式冲突解决办法

tailwind 样式导入放最前面，让自己的覆盖他

## css 的 attr()方法

可以通过 attr 使用当前元素身上的的属性 但测试目前好像只有 content 属性支持这个方法。

## unity 打包出来的 h5 文件和 cesium 一样，需要本地托管一个服务才能跑起来，直接双击 html 运行的话不可以会报警告。

我知道了 通过 xhr 或者 fetch 去请求本地文件 如果是 http https 请求给通过，如果是 file 模式本地会报错

Access to XMLHttpRequest at 'file:///C:/Users/Administrator/Desktop/study-jk/%E6%B5%8B%E8%AF%95js%E7%9A%84%E8%AF%BB%E5%8F%96/a.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

这是浏览器为了安全设计的。

https://www.cnblogs.com/tuyile006/p/15619697.html

## 定位一些踩坑

定位的元素 如果不设置宽高 默认是被内容撑开 没内容那宽高就是 0

如果定位的盒子 宽高是由内容撑开的 而恰好装他的父盒子没有宽高且必须是定位（单纯没有宽高不行），因为定位是相对于父元素的，那么定位的子盒子中的内容会竖着显示，如果是英文不受影响，因为英文单词很长本身就不会自动换行，中文的话会竖着显示，一行显示一个字，如果有逗号则最多显示两个字。 具体原因尚不明确。火狐也是这样。

如果子元素有长单词 那么子元素宽度会被撑开，即便设置了**word-wrap**: **break-word**; 也不能影响被撑开的子元素。

首先元素宽度不够 文字是的确会默认换行的，子元素遵循子绝父相，如果父元素没有定位则向上找，而向上找不存在文字伸展不开，但如果父元素宽度 0 且定位 那么子元素确实内容伸不开会换行。 因为他宽度不能超过父元素。

汉字之间会被视为一个个独立的字符，每个字符都会占据一定的宽度。由于汉字的宽度一般大于字母和数字，因此当一行放不下更多的汉字时，汉字就会自动换行。

英文和数字不会自动换行 需要设置 **word-wrap**: **break-word**;

word-break 属性规定自动换行的处理方法。

| normal    | 使用浏览器默认的换行规则。     |
| --------- | ------------------------------ |
| break-all | 允许在单词内换行。             |
| keep-all  | 只能在半角空格或连字符处换行。 |

word-wrap word-wrap 属性允许长单词或 URL 地址换行到下一行。

white-space 属性设置如何处理元素内的空白。

white-space 管的文字一行上不会换行强制不换行 遇到空白不会换行。word-warp 管的是长单词该不该换行，二者功能不重叠。

## 一些面试题

https://zhuanlan.zhihu.com/p/69723829?utm_id=0

## 浏览器加载图片和视频的时候默认的处理方式

图片和视频由于都是二进制流，因此浏览器默认是下载一点就展示一点。

## 「白话前端」快速区分 webGL，webGPU，unity3D 和 UE4

https://baijiahao.baidu.com/s?id=1782882451057013215&wfr=spider&for=pc

## el-table 覆盖了 el-image 处理办法

https://blog.csdn.net/CycleByle/article/details/135993703

https://blog.csdn.net/yusha123/article/details/106327893/

## 解决 VUE keyup.enter 和 blur 绑定同一事件，触发两次的问题

https://blog.csdn.net/qq_46264882/article/details/119344643

https://www.cnblogs.com/imPedro/p/12811781.html

https://www.jb51.net/article/265737.htm

## 为什么 el-input 的 blur 事件 是 input 触发的 click 也是 input 触发的

因为这些事件都是 element ui 自己封装的自定义事件 而不是原生事件，而这个自定义事件被子组件接受 子组件接受并触发传参的。 所以我们接受的也是 input

## getCurrentInstance

getCurrentInstance 获取的是当前组件的实例，在他的 appContext 属性里可以获取 app 应用的配置信息。

`getCurrentInstance().proxy` 是一个用于获取当前组件实例的代理对象的函数。它返回的是当前组件的代理对象，您可以通过这个代理对象访问组件实例的属性、方法以及生命周期钩子。

而我们可以通过 `proxy`访问到 app.config.globalProperties 上的属性，我想原因可能是 proxy 代理 访问某个属性触发 get 在 get 里进行了某些处理。

不过这个 proxy 代理的对象本身还是一个 defineProperty 对象。

## elementplus 2.6 以上版本 radio 通过 value 绑定值了 2.6 以下 label

el-select option 的 label 需要自定义属性绑定到 el-option 上 如果通过插槽不写自定义属性的话，那么选中 option 后 el-select 展示的是 value 而不是 label 因为 label 只是 option 的插槽 而 select 没办法拿对应的 value 去比对拿对应 item 项中指定 label 项的某个值作为 label

## vue 事件与原生事件传参

原生事件 addeventlistener 第一个参数是事件名称，第二个参数可以是一个 function 也可以是一个 function 名 也可以是一个函数执行产生另外的一个函数。onclick 同理。

绑定在 html 身上的原生事件 例如 onclick 必须是函数执行或者是表达式或者代码片段 而函数执行必须传参 函数形参才有参数。

而 vue 的事件 无论是 vue 原生事件还是自定义事件 既可以放函数名 也可以放函数调用 只放函数名的话，会执行函数，并可以接受参数 e，如果放的是函数表达式那么还可以放形参接受实参传递给函数式内部扩展参数，如果想要拓展自定义事件的回调函数中的参数，则可以采取自定义事件回调函数定义在事件触发的地方接受形参然后在函数内部书写真实函数并扩展参数。

记住函数调用才传实参，定义函数传形参。

## el-upload change 事件除了有自己的回调参数还有 event 事件对象 这个对象有三个 点击 change 和进度

## 上传 读取 文件转换这种 最好都封装成 promise 例如 file 转 base64

```javascript
export default function (file) {
  const reader = new FileReader()
  reader.readAsDataURL(file)
  return new Promise((resolve, reject) => {
    reader.onloadend = function () {
      resolve(reader.result)
    }
    reader.onerror = function (err) {
      reject(err)
    }
  })
}
```

## loading=lazy

在 HTML 中，`loading` 和 `loading="lazy"` 是 `<img>` 标签的两个属性，用于优化页面加载性能和用户体验：

1. `loading` 属性：

   - `loading` 属性用于指定在图片加载过程中显示的加载行为。它可以设置为以下三种值之一：
     - `auto`：默认值，浏览器自动选择加载行为。
     - `eager`：立即加载图片，不考虑视口内外。
     - `lazy`：延迟加载图片，只有当图片进入视口时才开始加载。

2. `loading="lazy"`：

   - `loading="lazy"` 是 `loading` 属性的一种取值，表示延迟加载图片。当设置为 `lazy` 时，浏览器会等到图片进入视口范围内时才开始加载图片，从而减少页面的初始加载时间和带宽占用。
   - 使用 `loading="lazy"` 可以帮助提高页面的加载性能，特别是对于包含大量图片的页面或长页面来说，延迟加载图片可以减少不必要的网络请求和加快页面加载速度。

总的来说，`loading` 和 `loading="lazy"` 属性可以帮助优化页面加载性能，提升用户体验。通过合理设置加载行为，可以在保证页面内容完整性的前提下，尽可能减少不必要的资源加载，从而加快页面加载速度。希望这个解释对您有帮助，如果有任何疑问，请随时告诉我。

## el-upload 上传图片够数了就隐藏掉上传按钮的做法

官方并未提供这个属性，因此必须我们自己去想办法，首先是 v-bind css 绑定给 el-upload 类 当上传添加到 filelist 或者 form 中后 则修改 v-bind 的值 删除时再修改，这种做法在低版本的 vue 比如 3.3.9 中不生效 编译后的 css 变量 不存在。

https://www.jianshu.com/p/e93259c4ee3e

不是低版本 vue 的问题 而是 append-to-body 的问题

第二种做法 https://blog.csdn.net/qq_62262918/article/details/135026917

通过 disabled 属性 来给 el-upload 增加类 然后 disabled 的类设置隐藏。 这种缺点是图片无法删除了

## Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead

避免依赖于枚举组件实例上的键的应用程序逻辑。密钥在生产模式中将为空，以避免性能开销

我本来以为是什么问题呢，后来发现是这一句代码出了警告

这里咱们通过 const { proxy } = getCurrentInstance(); 获取了当前组件的实例，只能从组件实例身上拿去属性，而不能对他执行逻辑操作，否则 vue 就会弹出警告。

这里应该是 proxy 进行了处理 只要去遍历或者其他一些逻辑操作 就会报出警告 目前测试 修改 新增 删除属性不会报错 遍历会报错 forin keys 获取所有属性标识符等都会 这里暂时不知道是如何做到的，了解即可。

猜测是对 proxy 整个对象进行了检测或者什么的吧，自己写的 handle 没有触发。

```javascript
console.log(Object.getOwnPropertyDescriptors(proxy))
```

## el-upload 默认不自带图片放大预览 需要手动使用

难道我的记忆出现错乱？

## el-upload filelist 作用

图片预览列表理论来说是用不到 filelist 这个自定义属性的，但是为什么我们需要他呢，是因为只要上传图片别管成功没成功默认 elementplus 都会把本地图片作为 list-file 显示在 文件列表，前提是没有写 file-list 这个属性，当我们有了文件服务器 则每张图片上传时需要判断是否成功了有才会往 filelist 里 push 然后绑定给 upload 组件实时显示图片

但是也需要 filelist 因为编辑页面会重服务器拿 然后渲染

## el-form resetFields 没有重置

原因 1 model 没有设置

原因 2 每个 item 的 prop 没有设置

## dialog closed 事件触发条件

1 点击 x

2 设置 v-model 得那个值为 false

## axios 响应拦截器说明

axios 相应拦截器成功函数执行时机是 status 为 200 成功的时候 而错误回调是 status 不等于 200 的时候

## 更多 axios 使用

http://www.axios-js.com/zh-cn/docs/ 文档比较老，有些配置或许不能用了

https://blog.csdn.net/u010494753/article/details/135583465

这里是 xhr fetch 和 axios 分别取消请求的方式

xhr.**abort**(**)**;//取消请求

fetch 是通过**new**AbortController(**)**;

axios 通过 axios.**CancelToken**.**source**(**)**;

取消的请求会被 axios 响应拦截器失败回调捕获

## JavaScript 包管理工具对比：npm、Yarn、pnpm 和 Bower

https://juejin.cn/post/7261783831057121335?searchId=202405081024293AB014D7C535BEF0DA76

Bower 简介

https://juejin.cn/post/6844904158395367431?searchId=202405081024293AB014D7C535BEF0DA76

npm、bower、jamjs 等包管理器，哪个比较好用？ - 尤雨溪的回答 - 知乎
https://www.zhihu.com/question/24414899/answer/28021471

npm1、npm2 采用递归管理，npm3、npm3+、yarn 依赖扁平化管理消除依赖提升。

pnpm 依赖策略：消除依赖提升、规范拓扑结构

https://blog.csdn.net/snowball_li/article/details/124787870

https://blog.csdn.net/m0_69551472/article/details/136932567

pnpm 会在这个存储目录中创建 hard links，这样多个项目可以共享同一份依赖包的实际文件，而不是每个项目都存储一个副本，从而节省磁盘空间。

https://baijiahao.baidu.com/s?id=1786851423161937048&wfr=spider&for=pc

幽灵依赖 是什么

## 成为一名前端架构师

https://juejin.cn/post/6844904054896721934?searchId=202405081024293AB014D7C535BEF0DA76

## pnpm 构建 vue3 项目+eslint .prettier 配置

https://blog.csdn.net/weixin_59816940/article/details/131395326

## 传参是传参，event 是 event，函数没有传参的情况下，传参数默认是事件对象，函数如果回调有参数那么以实参为准此时可以通过 event 来访问事件对象，另外 vue 的无论是自定义事件还是原生事件，无论传不传事件对象，最终通过 event 都能够获取正确的事件对象。

除非这个事件找不到事件触发对象，比如计时器，就算是我们用 watch 监听数据变化发生的事件，vue 也会找到触发这个数据变化的操作事件传递 event

## vuedraggableplus change 和 move 事件说明

onMove 拖拽移动的时候触发 触发频率和 onchange 一样必须换位置才会触发。但 onMove 可以去控制 拖拽生不生效 return false 不生效 return true 生效

onUpdate 必须是松开鼠标了才触发。 需要注意的是 move 无法获取到被拖得元素以及要放得元素得位置

为什么不能用 onUpdate 或者 记录位置 原因是因为 如果是从第一个拖拽和第三个交换 那么第二个会跑到第一个去 此时第一个不再是之前得第三个 而是第二个 那么我们存的新旧的就变成 第二个和第一个 然后再还原的时候 就变成了第二个第三个之交换位置 第一个值跑第二去了的 bug

## Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组。

这个数组可以解构 key 是索引 0 所在的元素 value 是索引 1 所在的元素

## pinia vuex 这种都是面向对象的编程思维。

属性 方法，方法修改属性，一个对象就是一个独立运行的模块。

## js 获取浏览器高度和宽度

https://www.cnblogs.com/easirm/p/4205155.html

https://cloud.tencent.com/developer/article/2107920

scrollheight 获取对象的滚动高度 和 scrollTop 的区别

window.getComputeStyle(obj).height

## 计算机组成原理 栈堆 线程进程 对象

## defineEmits 可以不传参数 但 defineProps 必须传

不传参数得缺点是没有类型提示。

## el 表单组件 model-value 与 v-model 的区别 在于前者是受控模式 后者是双向数据绑定

前者受数据绑定状态 比如 switch 只有数据修改了 switch 才会变 而后者数据和状态同时变 属于非受控模式

https://cloud.tencent.com/developer/article/2414134

受控与非受控。

## el 级联选择器 配置父子不关联和 是否数据返回数组

在 props 这个自定义属性里。 而不是组件身上

el 级联选择器获取 当前选择的 node ref.getCheckedNodes() 获得的是一个数组 数组第一项也仅有一项是当前选择的 node 其内部又 parent 可以看父级 node 也有 children 看子 node

v-model 如果是

## el-form 中只有一个 el-input 的时候 回车触发页面刷新表单提交

https://blog.csdn.net/weixin_46504400/article/details/138300630

是因为 el-form 一个比较智能的判断 如果表单上只有一个输入框 则在输入框上按回车 表单就会自动提交 且刷新界面

老实说 挺奇葩的 这个智能的判断 很多时候都会成为智障 因为大部分人都不需要这个功能 且很多时候会给大家带来问题 这个问题还不容易发现

解决办法就是 在 el-form 上加上@submit.native.prevent 防止事件冒泡

## el-form rules 的 trigger 时机

无论是 change 还是 blur 触发时机都是针对 表单的触发事件 比如 blur 比如 change 而动态增加移除表单组件 不会触发

## v-model 可以绑定响应式对象的值，也可以绑定响应式数组的值

v-model 不能用于 v-for 或 v-slot 作用域变量，因为它们不可写，但是可以绑定 v-for 的 item 内部的值。

如果 v-for 的响应式数组 里的每一个索引对应的是字符串而不是对象 那么通过 v-mode 绑定数组[index]后也是双向绑定的

## elementplus 中的 el-tree 收缩树所有节点的做法

```javascript
for (const key in tree.value.store.nodesMap) {
  if (Object.hasOwnProperty.call(tree.value.store.nodesMap, key)) {
    const element = tree.value.store.nodesMap[key]
    element.expanded = false
  }
}
```

## 我们定义的一些 css 类可能会和 tailwindcss 产生冲突

https://blog.csdn.net/weixin_51076986/article/details/132564486

https://article.juejin.cn/post/7251609043953188925

我的意见是要不给自己的样式全部加 important

要不就一开始用 tailwindcss 不要中途用。

tailwindcss 需要搭配 postcss 用 并且安装完毕这两个依赖 需要去配置一下

postcss.config.js

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}
```

tailwind.config.js

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx,vue}"],
  theme: {
    extend: {}
  },
  plugins: []
}
```

## proxy 的 rewrite 第二个 参数 写多少个// 都无所谓 vite 会自动处理

## v-model 也会触发依赖收集 前提是 这个数据获取的方式必须触发 proxy 的 get 也就是响应式数据 而直接 v-model = 数值的话 则不行

v-for 循环时 input v-model 双向绑定时遇到的。 自定义属性也同理

## 路由 404 的另外一种实现方式

一种是我们在路由导航守卫里做，如果当前的路由获取不到则跳转 404 另外一种更简单直接指定所有路由跳转 404 使用 path**:**'/:pathMatch(._)_'**,** 但是他的优先级低于我们通过路径配置的路由 因此他常用作匹配未定义的路由 跳转 404.

```javascript
const routes = router.getRoutes()
const isTrue = routes.some((item) => item.path === to.path)
if (!isTrue) {
  router.push("/notfound")
}
```

路由如果重复定义，以第一次为准。

在开发中，当前已存在的的 api 或者方法的性能大概率是要比我们手写的性能更好的。但也不一定绝对。

https://blog.csdn.net/XiugongHao/article/details/132715778 path: '/:pathMatch(.)\*'作用

https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-Not-found-%E8%B7%AF%E7%94%B1

pathMatch 是参数，这个可以是任意值 只不过最终存在路由的 params 中的 key 有所区别。

是的 路由传参的时候 这个类似于形参占位符可以是任意字符串。

传参不同 匹配路由也不同 也可通过传参去区分匹配路由

https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html

路由有两种跳转方式 一种是 path 一种是对象 对象里可以使用 name 和 params 跳转 也可对象里用 path

在路由配置中，"sensitive" 和 "strict" 是两个常见的选项，用于控制路由匹配的敏感度和严格性。

1. Sensitive（敏感）：当设置路由的 sensitive 选项为 true 时，路由匹配将会对大小写敏感。也就是说，如果路由路径中包含大写或小写字母，那么只有大小写完全匹配时才会触发路由匹配。默认情况下，路由匹配是不区分大小写的。
2. Strict（严格）：当设置路由的 strict 选项为 true 时，路由匹配将会对路径末尾的斜杠进行严格匹配。也就是说，如果路由路径以斜杠结尾，那么只有在路由配置中也以斜杠结尾时才会触发路由匹配。默认情况下，路由匹配是不严格匹配路径末尾斜杠的。

通过设置 sensitive 和 strict 选项，您可以更精细地控制路由匹配的行为，以满足特定的需求和约束条件。

希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

## host: true 和 host: '0.0.0.0'

在计算机网络中，"0.0.0.0"是一个特殊的 IP 地址，代表所有不符合以上规则的 IP 包。在网络编程中，"0.0.0.0"可以被看作是一个空接口，用于表示所有不符合以上 IP 包的所有 IP 地址。

在编程语境中，"0.0.0.0"可以用于表示当前设备在网络上的任何可用接口。

而在配置文件中，"host: true"通常用于某些配置文件中，比如 Docker Compose，表示绑定到宿主机的所有接口上。

"host: true"和"host: '0.0.0.0'"的区别在于，"host: true"绑定的是宿主机的所有接口上，而"host: '0.0.0.0'"绑定的是宿主机的所有网络接口上，但不包括 localhost(127.0.0.1)。

在 Vue 项目中，将 host 设置为 '0.0.0.0' 可以使得项目可以通过局域网进行访问，而不设置或者设置为其他值可能导致只能通过本地访问而无法通过局域网访问的原因如下：

1. **绑定到所有网络接口**：'0.0.0.0' 是一个特殊的 IP 地址，表示绑定到所有可用的网络接口。当将 host 设置为 '0.0.0.0' 时，Vue 项目会监听来自所有网络接口的请求，包括本地和局域网的请求，从而使得局域网中的其他设备可以访问到该项目。
2. **默认绑定到本地**：如果不设置 host 或者设置为默认值（通常是 'localhost' 或者 '127.0.0.1'），Vue 项目会默认只监听来自本地的请求，而不会监听来自局域网的请求。这就导致了只能在本地访问项目，而无法通过局域网进行访问。

因此，通过将 host 设置为 '0.0.0.0'，Vue 项目会监听来自所有网络接口的请求，包括局域网中的请求，使得局域网中的其他设备可以访问到该项目。这就解释了为什么设置为 '0.0.0.0' 可以实现局域网访问，而不设置或者设置为其他值则无法实现局域网访问的原因。

希望这个解释能够帮助您理解为什么将 host 设置为 '0.0.0.0' 可以实现局域网访问。如果您有任何其他问题，请随时告诉我。

明白了,当这俩设置其中一个得时候,此时咱们的项目会绑定到本机所有的网络接口,当局域网通过本机 ip 访问我们得时候,我们就把项目通过局域网传输给对方查看.

localhost 是一个网络术语，通常用于指代本地主机或本地计算机。当您在浏览器或计算机中访问 localhost 时，实际上是在访问您自己的计算机上运行的服务或应用程序。

具体来说，localhost 通常对应的是 IP 地址 127.0.0.1，这是一个特殊的 IP 地址，用于表示本地主机。当您访问 localhost 或 127.0.0.1 时，您的计算机会尝试连接到自己的网络接口，从而访问本地运行的服务或应用程序。

因此，localhost 主要用于在本地计算机上访问本地部署的服务，进行开发、测试或调试。通过访问 localhost，您可以与本地主机上运行的应用程序进行交互，而无需通过网络连接到其他计算机或服务器。

总的来说，localhost 是一个方便的方式，让您可以在本地计算机上访问本地部署的服务或应用程序，是开发和测试过程中常用的工具之一。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

指定服务器应该监听哪个 IP 地址。 如果将此设置为 `0.0.0.0` 或者 `true` 将监听所有地址，包括局域网和公网地址。 ------vite 官网

https://cn.vitejs.dev/config/server-options.html#server-host

本地服务器和局域网服务 都可以本机直接访问,而项目上线则需要通过公网 ip 访问.

设置成 0.0.0.0 好处是局域网端口被占用会自动+1 寻找下一个可用端口 而 true 则不会寻找下一个端口导致项目启动了 别人局域网访问不到 有待证实，但是我遇到的问题的确是改成 0.0.0.0 就好了 经我测试 host 设置 true 如果都是 vite 项目 的话端口都一致 那么好像是会造成 项目启动覆盖原来的端口的问题

经我测试 host 设置 true 会造成同项目 启动多个 端口自+1 多个项目端口一致会覆盖不会自动+1 而 0.0.0.0 没这个问题

## el-upload v-model 注意事项

v-model:file-list 和:file-list 如果直接绑定 reactive([])的数据，那么操控数据源不会影响 dom 更新 而包一层 data 就可以了

upload 组件 api 写的 on-change 等事件都可以用@xxx 绑定

## vite 的 proxy 代理

本质上是一个 node 插件/包 node-http-proxy proxy 里 changeOrigin 是允许使用 target 作为目标 url 这里可以配置 timeout 响应超时事件。

## axios 取消请求也不会触发请求失败拦截器 但会触发请求拦截

请求拦截里 是请求发出前做什么配置 如果这里抛出错误什么的请求不会发出 并且请求得 then 和 catch 也不会拦截到任何东西 因为压根请求就没有发出，因此也没有成功和失败得状态了。 一般可以在请求拦截器里配 token 当然 create 得时候也可以配置。

## vscode 里的 eslint 插件和 vue 项目里安装的 eslint 的关系是什么。

首先没有安装 eslint 插件的话 项目里的 eslint 不会实时报错 只能在执行 lint 命令的时候才会报错,因为插件负责的就是编译时报错，.eslintrc.cjs 是项目 eslint 插件的配置文件。

ts 插件同理。

.eslintrc.cjs 和.`prettier`.cjs 都不需要启动项目 就能格式化代码。

执行项目的 lint 命令也需要这个配置文件。并且一些简单错误 lint 执行的时候也会帮我们修复比如单引号双引号等。

不装 eslint-vue-plugin 则无法 eslint .vue 文件

但如果有 typescript-eslint/parser 则可以解析 ts 的.vue 文件 但依然无法解析 js 的 vue 文件。

1. `eslint-config-prettier` ：这是一个 ESLint 配置规则的包，它将禁用与 Prettier 冲突的 ESLint 规则。使用 `eslint-config-prettier` 可以确保 ESLint 规则与 Prettier 的代码格式化规则保持一致，避免二者之间的冲突。
2. `eslint-plugin-prettier` ：这是一个 ESLint 插件，它将 Prettier 应用到 ESLint 中。它会使用 Prettier 来格式化代码，并将格式化结果作为 ESLint 的一项规则来检查代码。使用 `eslint-plugin-prettier` 可以在代码检查的同时，自动格式化代码，使其符合 Prettier 的规则。

通常情况下，您需要同时安装这两个包来实现 ESLint 和 Prettier 的集成。首先，使用 `eslint-config-prettier` 禁用与 Prettier 冲突的 ESLint 规则，然后使用 `eslint-plugin-prettier` 将 Prettier 应用到 ESLint 中，以便在代码检查时自动格式化代码。

但是测试移除了 `eslint-plugin-prettier` 并没有啥实质性的影响 yarn lint 还是保存都会格式化代码。 我看 npm 官方文档说 `eslint-plugin-prettier`作用是将 Prettier 作为 ESLint 规则运行，并将差异报告为单个 ESLint 问题。那我们没有测试出的原因可能是 eslint 配置后的规则本身就覆盖 prettier 了？导致他移除了也没啥影响吗？

但是我看代码中 eslint 规则的报错的确是 eslint-plugin-prettier 提示的，那有可能是 prettier 插件中自带了 eslint-plugin-prettier

移除@vue/eslint-config-prettier 的话 会失去 prettier 的功能. 并且失去 eslint 编译时报错的功能。在命令行的情况下，但可以保存执行 prettier 格式化代码。

Prettier 插件可以格式化代码，也可配置保存自动格式化代码。

需要配置.prettierrc 文件 然后全局的代码都可以自动保存格式化了。 一种是.prettierrc 一种是自带的 tsjs 格式化。

我们安装 Prettier 插件后,可以有两种格式化代码的方式，第一种是配置 vscode 的 json 然后需要在 prettier.configPath 选项下配置一个.prettierrc 文件 然后每一次保存的时候，会自动根据.prettierrc 文件去格式化代码，这种做法缺点是如果我们 vue 项目里安装了 eslint 和 prettier 依赖的话 由于顺序问题会先执行项目里的 prettier 再执行 插件的 prettier 导致多次格式化最终还是会报错。 解决办法是删掉 prettier 文件。另外 vue 的官方插件 vue office 也会格式化代码和项目里的 prettier 冲突。 因此我们格式化代码也不要用它就用 prettier 并且是没有配置.prettierrc 的 prettierrc 插件。

另外，除了配置在 vscode 的 json 中，.prettierrc 还可以放到某个项目的根目录下，这样也会执行格式化 并且是局部的 放在哪个根目录就只格式化那个根目录。 并且 prettierrc 插件不仅会格式化 vue js 等文件连 md 文档也会 ts json 不会。

另外格式化的优先级是以当前文件配置开始到 vscode 配置的。 后面的覆盖前面的。

而本项目的依赖 prettierrc 优先级优于 本项目里的.prettierrc 文件。

另外如果 eslint 插件禁用的话 项目代码不会有错误提示，但是格式化代码照常格式化这是由于咱们项目里 有.prettierrc.cjs 这也是 prettierrc 插件的配置文件。如果禁用 prettierrc 插件的话 那么项目会采用 eslint-prettierrc 来格式化代码 优先用这个。 如果这个被禁用则用 prettierrc 插件格式化代码。如果二者都开着则两个都会使用格式化代码。

即便我们删除 prettierrc.cjs 也会触发 prettierrc 插件格式化 这是由于 node_modules 下也有配置文件。

有时候这俩格式化代码都通过了 但是 ts 会报错。

eslint-config-prettierrc 不依赖.prettierrc.cjs 也不依赖.eslintrc.cjs 中 rules，但依赖 extends 没有这个 vscode 就不会提示错误了。

因此我们可以得出结论 eslint 插件和 prettierrc 插件二者只要配置了 对应的配置文件那么就能工作，前者负责报错，后者负责格式化代码，但如果我们想要功能更为强大得报错与格式化代码比如支持 vue ts 等等文件得格式化 以及自动帮我们整理好规则的话则需要手动去安装 eslint 与 prettierrc 的依赖在项目中并配置。

另外 eslint 的依赖需要 eslint 插件才能运行否则报错，而 eslint-config-prettierrc 不需要 prettierrc 插件 eslint 生效就能格式化代码了，如果 eslint 不生效则需要 prettierrc 插件和.prettierrc 来格式化代码。

prettierrc 插件 默认可以格式化代码？ 可以 因为默认插件有自己的一套配置。

插件都是编译时和保存时自动使用，而配置是执行命令时才调用。

## UI 风格汇：材料设计（Material Design），是对扁平风格的延展。

https://blog.csdn.net/2401_82616673/article/details/136993945

https://baike.baidu.com/item/Material%20Design/16011141

一种设计风格 类似的 ui 库有 Vuetify Varlet Quasar

一个比较显著的特点是 这种风格的 ui 组件库的按钮 点击是有涟漪效果的。

比较讲究**平面化与阴影效果** 以及过渡动画和响应式的 UI 设计风格

https://www.51cto.com/article/742102.html

## 将一个本地的的项目关联推送到远程仓库

首先在本地仓库里 git init 初始化本地仓库后才可以提交代码

git add .

git commit -m info

```
git remote add origin 远程仓库地址
```

```
git push -u origin "master"
```

后面每次提交代码都可以 git push 了

remote add 把远程仓库地址添加到本地。使本地仓库和远程仓库产生关联

origin 远程仓库的别名 url 地址

git push -u origin "master" **将本地仓库数据推送到远程仓库**

**origin 为远程仓库的名称，可以自定义**

https://blog.csdn.net/mi_lu_yuan/article/details/132467412

不知道切换分支推送的时候 是否也需要 git push -u origin 分支地址一次 (需要)

git merge 分支名 拉取合并某分支的代码 可以是远程的

git pull --no-stat -v --progress origin master

git pull origin master

直接从远程分支拉取代码 可以是其他分支拉主分支

## Git 拉取请求：Git pull Request

https://blog.csdn.net/mzgxinhua/article/details/135095992

https://www.cnblogs.com/kingpong/articles/16501021.html

这里的拉去请求 使用场景是 别人新建了一个分支并且推送到了远程，（他没有去本地分支合并然后 push）而我们本地没有那个分支，想要将别人的代码 远程合并到 master 分支时候，这样我们 pull master 的时候就能拉到别人分支的代码了。

Git pull request 是一种常用的协作方式，通常用于开源项目或团队合作中。下面是对 Git pull request 的解释：

1. **创建分支**：首先，您需要在本地仓库中创建一个新的分支，用于进行特性开发或修复工作。您可以使用 `git checkout -b <branch-name>` 命令来创建并切换到新的分支。
2. **提交更改**：在新的分支上进行代码修改、添加、删除等操作，并使用 `git add` 和 `git commit` 命令将更改提交到本地仓库。
3. **推送分支**：将本地的新分支推送到远程仓库，使用 `git push origin <branch-name>` 命令将新分支推送到远程仓库。
4. **创建 Pull Request**：在远程仓库中打开一个 Pull Request（PR），将您的新分支与目标分支（通常是主分支）进行比较。在 PR 中可以添加描述、更改说明等信息。
5. **讨论和审查**：团队成员可以在 PR 中进行讨论、提出建议或进行代码审查，确保代码质量和功能完整性。
6. **合并 Pull Request**：如果 PR 经过审查并通过了所有的检查，负责人或项目维护者可以选择合并该 PR，将您的更改合并到目标分支中。

通过使用 Git pull request，可以方便地进行代码审查、讨论和合并，保证团队协作的顺利进行，并确保代码质量和项目稳定性。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

如果是本地的分支，也就是我创建了新分支 那么我可以直接在本地合并分支后 push 到远程。

git 中为什么是 pull request 而不是 push request？ - 周越的回答 - 知乎
https://www.zhihu.com/question/334230718/answer/743900086

## Git 中 fork, clone,branch 有什么区别?

https://blog.csdn.net/weixin_40808668/article/details/133987915

## vite preview 和 vite

前者是运行编译打包后的项目 后者是编译前的 前者有文件指纹和 asset 中文件打包后名字改变后的文件导入。

## v-if 和 v-show 对于事件触发顺序的影响

v-if 移除 dom 和新增 dom 是异步的，这个我们都知道，因此如果做那种 hover 下拉菜单的时候，会出现这种情况，父级菜单移动到子级菜单的时候 由于父级菜单和子级菜单是连着的 事件的触发顺序是 父级 onmouseleave-> 子 onmouseenter 在父的 onmouseleave 种我们将子的显示状态切换成 false 但是由于 v-if 是异步移除 dom 的，由于我们速度很快，再加上异步销毁子，导致我们明明切换了子的显示状态为 false 但依然触发了 子的 onmouseenter 事件。理论来说我们是不希望这样的。我们只希望鼠标从父亲移开只触发 onMouseleave 不触发子的 onmouseenter。

而使用 v-show 去控制子显示与隐藏的话 也是异步的 但是同样的操作 不仅会触发子的 onmouseenter 还会触发 onmouseleave 当它消失的时候，歪打正着，如果我们触发了 onmouseleave，反倒还帮我们隐藏了三级菜单

如何让一级菜单移走 进入了二级菜单 但二级菜单不销毁呢，做法是当我们移入二级菜单的时候加一个全局变量 如 isleaveTwo 来作为我们是否一如二级菜单的依据，然后在一级菜单里的 leave 事件里判断（这里需要一个异步判断，原因如前：因为二级菜单的 enter 执行是一定在一级的 leave 后 而 isleaveTwo 状态修改是在子 enter 事件种 这里不异步的话 leave 的时候 isleaveTwo 状态永远没有变化。异步的选择方式可以是计时器可以是帧动画。）

## vue template 模板中 的元素除了能绑定 class style data-xx 等等原生属性 还可以通过 onclick onmouseenter 正常绑定事件 到时候会当成原生去解析。

那 template 种的内容会当作原生 html 解析的

并且这个事件和 vue 的@事件还不会冲突 这个事件先执行然后执行 vue 的@事件

## mouseenter mousemove 这种事件 不是 hover 事件。

mouseenter 和 mouseover 的区别

https://blog.csdn.net/qq_66442729/article/details/134523171

mouseover 绑定在父元素身上 从子元素移到父元素也会触发一次事件 但 enter 不会 enter 只会在进入时触发一次 leave 同理。

mouseover 还会冒泡 从父元素移动到子元素 子元素会冒泡 触发一次父元素的 mouseover 而 enter 不会，冒泡吗，很正常类比 click 绑定父元素 点击其中子元素也执行一样。

https://blog.csdn.net/weixin_47450807/article/details/123381092

## 绝对定位的元素 height:100%的说明

绝对定位 height 100%如果祖先元素中有相对定位的元素 则以相对定位的元素的高度\*100% 否则以 100vh 为参照。 宽度同理。 top left 值同理 这里是可视区域宽高 什么是可视区域 不算滚动条卷去的部分。

因此如果我们要考虑到滚动的话这里就不能用 left 50% transform translate-50%来写居中了 除非祖先元素是定位.

## 多级联动下拉菜单的解题思路

一定要是嵌套的写法，一级采单嵌套二级 二级嵌套三级 三级套四级

这么写好处是鼠标无论从三级或者四级或者二级移出到菜单外的时候，会自动关闭全部菜单，而无需手动去控制祖先级别菜单隐藏，这是因为由于结构是嵌套的，因此事件触发也是嵌套的 鼠标从 3 级出到外部的时候 同样是移除了 2 级和 1 级 导致他俩也触发各自的 leave 事件 关闭各自的子级，因此需要去绑定每一级的移除事件 因为要判断移除后是否又回到了上一级菜单，如果是则不关闭全部菜单，而是只关闭这一级的下一级菜单。

不能用菜单每一级都是独立然后用一个大盒子包起来的写法，这么写会有问题，导致外面大盒子触发的事件在后，内部盒子触发在前，导致事件冲突，因此最好的做法还是嵌套。 要不就嵌套，要不就分开写，然后分别控制他们移入移出以及移入到上下级时的事件，会很麻烦很麻烦，层级少还行层级多搞不定。

onmouseleave 当鼠标从自身元素移出时触发，如果三个相同大小的元素嵌套则会分别触发三个移出事件（前提三个分别绑定了）

和 mouseover 的区别 嵌套的时候 如果从父移到子 会触发父的 out 事件 但是 leave 不会

从子移到父也不会触发父的 enter 而 over 会触发。

也就是说 leave 和 enter 会把子也看作是自己的一部分。 而 over 和 out 会把子看作是独立的。

## 组件二次封装注意事项

slot 作用域插槽传参的时候 和正常 v-bind 传值一样 可以传多个 但是 template 使用的时候是一个对象接受的。

```javascript
  <n-modal v-bind="$attrs" preset="dialog">
    <template v-for="(item, index) in $slots" :key="index" #[item]="props">
	<!-- 为什么这里是v-for template 而不是直接slot v-for呢是因为 如果直接v-for slot 那么传过来的插槽全部都会在这里的default渲染 -->
      <!-- props可能是多个 这里用v-bind -->
      <slot :name="item" v-bind="props"></slot>
    </template>
  </n-modal>
```

## naiveui 自动导入的时候需要手动声明 dialog message 等四个方法 他们和 elementui 一样既用到方法也用到组件。 其他的可以直接光组件就行。

naiveui 的 modal 组件我二次封装插槽那里报错了。

vite 自动导入插件 如果一个方法有同名方法 具体导入哪一个 不知道 vite 是如何进行判断的，因此尽量避免定义同名函数

## 自动导入的两种方式 如果是 export 则直接导入 如果是 export default 则需要使用导出的文件名使用它。

## vue3 setup 语法中 使用 swiper

https://blog.csdn.net/weixin_51924709/article/details/125919323

## 多行省略无论设不设置 省略号都会显示省略号 如果想要设置多行溢出不显示省略号 做法是设置元素高度 然后 overflow hidden 正好显示两行的高度就行

## git 项目太久没有 pull 导致的报错解决办法

error: Pulling is not possible because you have unmerged files.
hint: Fix them up in the work tree, and then use 'git add/rm `<file>`'
hint: as appropriate to mark resolution and make a commit.
fatal: Exiting because of an unresolved conflict.

https://blog.csdn.net/yjk13703623757/article/details/88404705

https://blog.51cto.com/halolk/1304701

这里的报错原因应该是之前我 pull 了一次远程仓库的代码后，在本地测试 eslint prettierrc 配置等 修改了商城的代码 但是没有提交到远程仓库 然后拉去今天远程仓库提交的代码 导致本地与远程冲突，使用 git reset --hard FETCH_HEAD 回退到上一次成功的 pull。

如果本地的代码也有用 不能完全放弃的话，可以试试这种方法，先解决冲突再合并。

https://wenku.csdn.net/answer/6384a68058d29661899304d855b888b2

其实本质问题就是上次提交的代码忘记拉下来就开始直接写代码提交导致冲突了。

## apifox 和一些 node 插件可以自动根据接口返回生成 ts 类型。

## 变量：类型 是全局的 而类型断言是只要那行代码执行的时候可以断言成某个类型

变量声明类型 函数也要声明参数类型 就算是你调用函数时传的实参声明类型了 那形参也要声明类型 这是因为如果想要函数调用时声明类型 需要泛型,泛型的用法需要复习。

## vue-router path 不写或者和父路由 path 一致的话，父路由展示的时候，当前组件也会展示。

router.push 和 router-link to 去往的路径加不加/的区别 /就是根路径 不加/的话 默认会把不加/的路径 替换到当前路径的最后一级路径 然后跳转 比如当前路径是 a/b/c 然后我们 to d 则跳转的路径最终是 a/b/d

## margin-bottom 负值 可以让下面的盒子往上来。

https://blog.csdn.net/louxinuo/article/details/120780093

## get 请求无法发送 body 浏览器不让

https://blog.csdn.net/qq_40716795/article/details/135206453

## foreach 回调函数 ts 类型声明 回调函数得形参类型声明需要用: 而不是 as as 会报错 名且类型声明得话 形参需要用括号包起来 否则报错

## ?.[0]和?[]是两种不同含义 前者意思是当前面数组存在则找数组索引第一项 后面得?意思是 三元运算符了就

即可选链操作符（Optional Chaining Operator）。可选链操作符允许我们在访问对象的属性或方法时，避免因为中间的属性或方法不存在而导致的错误。

函数?.() 如果函数存在执行 如果赋值的时候使用?.可选链操作符其中某个值 是不存在 则直接返回 undefined

有时候可能需要多个?. 连着用来做非空判断, 疑惑的是 ts 里 item.children?[0].id 这么写居然没有报错 0 项可能是没有的

这是因为 ts 的数组类型是不会做为空数组校验的，知道为什么了，因为数组可能是 0 项也可能是无数项，因此不好去做校验 如果做的话 array[0] 需要做 那么 array[10]要不要做？ 又不是元组和枚举。

## 外面大盒子 point-events 设置 none 里面设置 all 那么里面的子元素是有鼠标事件的

## 无法找到模块“element-plus/dist/locale/zh-cn.mjs”的声明文件

https://cloud.tencent.com/developer/article/2322542?from=15425

## 定义的 css 变量，如果 css 变量定义的不正确，比如定义的颜色不正确，虽然这个变量被使用了，但页面渲染的是继承的样式。

## eslint 报错 报 debugger 的错解决办法

https://juejin.cn/s/eslint%20unexpected%20%27debugger%27%20statement.(no-debugger)

在 eslint 配置文件里

## formdata 作用

https://www.zhihu.com/tardis/bd/art/111480177?source_id=1001

## css 里面的@import

https://blog.csdn.net/qq_44473483/article/details/134596494

vue 中的 style 标签 可通过 src 引入 css 文件 并且可以添加 scoped 只对当前文件生效的 css 文件

@import 加不加 url 都能引入远程的 css 路径不写./的话 默认就是当前路径

目前没有发现加不加 url 有什么不同

@import 导入的 css 最终会编译成引入里的 css 代码 而不会和 import 一样 去下载 css 文件 但是 非编译工具的 html css 的话 会去下载 css

如果我们在 vue 文件的 style 文件上通过 src 去 导入 css/scss 的话，要从./ 或者../ 相对路径写 或者/ 绝对路径 如果不以这些开头 默认就是/ 而不是./当前目录

.vue 文件的 style 会单独编译成一个 css 文件 这个 css 中所有的 class id 等 通通以 [data-v-xxx]结尾 实现 scoped 而通过:deep 穿透的样式则以[data-v-xxx]开头 实现穿透样式 通过 src 引入的 css 编译后文件是文件名 直接写在 vue 文件中的 style 编译后是 很长的以当前组件命名加一堆后缀的 css 文件

## Map 说明

for of 遍历 map 的时候 iterator 获得的将会是 一个数组 数组第一项是 map item 项的 key 第二项是 value

并且 map 数据结构 通过 reactive 生成的 响应式数据 和 array 一样 调用 自身或者原型上的方法去修改数据源的时候会触发代理 响应式

## ts 不用定义类型得好方法

就是接口数据 我们先调用获取数据 然后赋值给变量 这样 ts 会自动推导出类型 也就是说默认值我们直接设置成接口的数据 这样就等于定义类型了，那可能接口返回赋值的时候 需要 res 设置类型

## ts 如果有一个数组的类型，想要获取数组中某个元素的类型的时候 直接数组类型[number]即可

## elementplus 有折叠面板的组件 名字叫 el-collapse 也提供了折叠面板的动画过渡组件 名字是

```
el-collapse-transition
```

## ts 定义数组类型的方式

Array `<T> 和 T[]`

## el-table 修改表格的样式做法

除了官方暴露出的自定义属性 如 header-row-style header-row-class-name cell-class-name cell-style 等 但是这些有时候无法把样式添加到我们理想的地方 比如我们用 header-row-class-name 去设置表头背景色 会发现权重没有 el-table th 权重高 导致没有修改 所以我们可以通过样式穿透 th td 来修改样式

## 盒模型-webkit-box

https://blog.csdn.net/jsonya/article/details/54694832

## 高德地图相关问题

高德地图请求有 key 有数字签名 私钥 还有安全密钥

没搞懂数字签名有啥用以及是如何生成的，安全密钥也不是所有的 api 都有，比如 ipv4 查地址接口就没有安全密钥。 好像只有 js api 才有安全密钥 i

如何添加数字签名？ https://lbs.amap.com/faq/quota-key/key/41181

JS API 安全密钥使用 https://lbs.amap.com/api/javascript-api-v2/guide/abc/jscode

[基于高德开放平台 Map Lab 的数据可视化](https://www.cnblogs.com/bigcousin/p/maplab.html "发布于 2019-08-15 13:57") https://www.cnblogs.com/bigcousin/p/maplab.html

数字签名使用教程 https://blog.csdn.net/qq_51793991/article/details/130484673

其实就是等于多一个 sig key 参数是 真实参数加私钥的 md5 加密

## md5 没有签名调用报错解决办法 与 ts 声明默认导出拓展

```javascript
declare module 'js-md5' {
  export default function(value:string): string;
}

```

Vue3 使用 MD5 加密（清晰明了）\_vue3 md5 加密，十大前端开发框架

https://blog.csdn.net/2401_84413092/article/details/138451963

## ts any 类型

在[TypeScript**](https://www.baidu.com/s?wd=TypeScript&rsv_idx=2&tn=baiduhome_pg&usm=1&ie=utf-8&rsv_pq=e4fd0571007a1862&oq=ts%20any%E7%B1%BB%E5%9E%8B&rsv_t=b6733%2FPJOqFCwndz3RT%2Bq2aLRcY63x2jhTC1zIDw6lD%2FRuOZ01JBIeQKkM%2FgwoachfG7&sa=re_dqa_zy&icon=1)中，`any`类型表示任何类型的值，包括但不限于数字、字符串、布尔值、对象、数组等。使用 `any`类型的变量可以被赋值为任何类型的值，而不会导致编译器报错或警告。这意味着，当声明一个变量为 `any`类型时，TypeScript 将不会对该变量的值进行类型检查，从而允许在运行时出现类型不一致或意外的行为。

`any`类型与 `unknown`类型的区别在于，`any`类型表示任意类型，放弃了 TypeScript 的类型检查，而 `unknown`类型是暂时未知的类型，仍然会进行 TypeScript 的类型检查。从集合论的角度看，`any`类型可以看成是所有其他类型的全集，包含了一切可能的类型，而 `unknown`类型是 TypeScript 类型系统的顶端类型。

在实际开发中，使用 `any`类型的场景包括：

- 需要关闭某些变量的类型检查时，可以将该变量的类型设为 `any`。
- 为了适配以前的老 JavaScript 项目，让代码快速迁移到 TypeScript 时，可以把变量类型设为 `any`。

需要注意的是，使用 `any`类型时需要谨慎，因为它是一个非常灵活的类型，可能会导致类型不一致或意外的行为。在某些情况下，使用 `unknown`类型可能是更安全的选择，因为它提供了更严格的类型检查。

any 可以去覆盖已经定义好的函数类型的参数类型，从而达到跳过类型检查的操作。

```typescript
interface BA {
  a: string
  b: string
}
interface BB {
  c: number
  d: number
}
type Test3 = (b: BA | BB) => void
const test3: Test3 = function (b: any) {
  // 这样不会报错 因为a只有BA类型才有 BB没有 直接使用b.a会报错 就算定义test3的时候 给参数指定为BA 也会报错 说不能将BA类型 赋值给联合类型
  console.log(b.a)
}
```

类型定义是 定义时 类型断言是使用时

https://blog.csdn.net/qq_28550263/article/details/128169543

## vue 的 ref 如果定义时泛型传了 但 ref()里什么都没写 则默认类型是泛型|undefined 不需要手动定义

## 放大镜效果代码与思路

元素需要三个 一个展示商品的容器在左侧 内部有一个元素做为检视元素 右侧有一个大元素 作为预览

容易产生的误区： 左侧大元素绑定 mouseenter 事件 来控制检视元素显示与初始位置， 隐藏检视元素和 move 事件绑定在检视元素身上

正确做法： 左侧大元素仅用作控制检视元素的显示，而检视元素的位置控制放在 move 事件里做 move 绑定在左侧大元素上,因为触发 mouseenter 事件 必定会触发 mousemove 事件 由于元素层级问题，检视元素需要取消 鼠标事件 point-events:none

注意事项：如果 mouseleave 绑定在父元素的话，当子元素显示的时候，鼠标会进入子元素 导致父元素触发 leave 事件 针对于误区内容 正确做法中取消了检视元素的鼠标事件

```html
<div class="left flex column pos-r">
  <img
    :src="productDetail.data.imgList[selectImg]"
    alt=""
    class="main-img"
    @mouseenter="showInspection"
    @mousemove="moveEvent"
    @mouseleave="isShowInspection = false"
    ref="mainImgRef"
  />
  <div
    class="pos-a inspection point-event-none"
    v-show="isShowInspection"
    ref="inspectionRef"
  ></div>
</div>
<div class="right ml-31 pos-r">
  <div class="preview pos-a zIndex-4 overflow-hide" v-if="isShowInspection">
    <img
      :src="productDetail.data.imgList[selectImg]"
      alt=""
      style="width: 300%; height: 300%"
      class="pos-a"
      ref="previewImgRef"
    />
  </div>
</div>
```

```typescript
br
```

思路：

主要使用到的一个属性是鼠标事件中的 e.layerX 和 e.layerY 它表示 鼠标在元素中的位置 相对于祖先元素中第一个定位的元素 从下往上找。 检视元素在左侧大元素中的位置 应当是 e.layerX/e.layerY - 检视元素自身的宽/高的一半

    但是需要考虑的是e.layerX/e.layerY- 检视元素自身的宽/高的一半是负数的情况比如鼠标刚移入到大元素的边边位置处。需要做对应处理。

至于预览元素 需要我们设置一个容器 里面放一个大图 大图与容器的比例 正好是 左侧元素与检视元素的比例 然后我们把 检视元素在左侧容器中的 top left 转成百分比 \* 预览元素的宽高 就算预览元素在右侧容器中的 top 和 left 了 （不过是负值，因为容器是固定的 图片是大的）

## 路由的 params 和 query

params 是路由定义的时候 需要使用/:xxx 来定义的 路由参数 而传递的时候需要/路由/123 这种传递 打印 route 的时候在 params 中获取

query 是查询参数，路由定义的时候不需要做任何处理 传递的时候通过 query 对象传递或者直接?拼接在路由后面即可 打印 route 通过 query 获取

## vue router 如果在路由导航守卫中多次 next 会报警告

The "next" callback was called more than once in one navigation guard when going from "/" to "/". It should be called exactly one time in each navigation guard. This will fail in production.

## 定义 localstorage 类型 ts

```typescript
declare global {
  interface Window {
    $message: MessageApiInjection
    $appName: string
    $showLoading: () => void
    $hideLoading: () => void
    localStorage: {
      jk_token: string
      jk_user: string
      jk_user_phone: string
    }
  }
  interface Storage {
    jk_token: string
    jk_user: string
    jk_user_phone: string
  }
}
```

## props 默认值 对象和数组都需要函数 return 而不能直接设置

## useRoute 是一个对象 也就是说 route 对象是一个对象

这也是为什么 路由切换会触发 watch route 的原因了 但是刷新页面不会触发 需要手动设置第一次触发。

路由切换 如果是从其他页面跳转到 设置 watch route 的页面是不会触发 watch 第一次变动的 因为 route 的改变在当前组件初始化前。

## `Teleport使用注意事项`

teleport 组件是 vue3 内置的组件 作用是可以让 template 种的内容渲染到指定的 dom 中 且不影响 组件上下文父子关系。

需要注意的是 to 的类型 `to` 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段**传送到 `body`** 标签下”

`<Teleport>` 挂载时，传送的 `to` 目标必须已经存在于 DOM 中。理想情况下，这应该是整个 Vue 应用 DOM 树外部的一个元素。如果目标元素也是由 Vue 渲染的，你需要确保在挂载 `<Teleport>` 之前先挂载该元素。

由于 vue 的 route-view 父子组件等渲染的时候是一次性生成所有真实 dom 的，因此有可能会出现子组件中某一块内容想要放到父组件中的某个地方渲染 不成功（路由同理），原因就是父子组件是一起渲染的，而 `Teleport`要求使用的时候，需要被放入的那个 dom 是已经挂载好的，此时需要我做处理，比如 v-if 延迟渲染 `Teleport`

如果需要插入的是一个组件的话 则需要 ref 组件实例对象.$el 因为 to 只能使用 HTMLelement 或者 string 选择器 而组件自身不是 dom

`Teleport` data-v 是所属组件 而不是被插入得组件

## 避免 template 中直接使用 ref 接收的组件 否则会报错 dom 没事

Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.

避免依赖于枚举组件实例上的键的应用程序逻辑。在生产模式下，密钥将为空，以避免性能开销。

错误场景：直接通过胡子语法在 template 里使用组件 ref 网上说 watch route 也有可能出现这个错误。

不过自己通过 JSON.stringify 处理 组件 ref 并不会报这个错 不过得到的最终是一个{}

## props 说明

props 是一个 reactive 对象 但是 如果其中的属性 接受的时候不是响应式或者说 没有传是默认值的话则那个属性不是 reactive 对象

## v-if 和 v-else 在 v-for 中 需要使用不同的 key 比如一个用 id 一个用 index

## el-collapse-transition 只可以对单个根根节点元素使用

多个需要自己用 transition-group 写

vue 的过度对元素 v-if 和 v-show 都可以使用 估计 v-if 使用了异步 因为 dom 的创建与移除是不会触发过度的 异步才可以

## vue transition-group 注意事项

v-if 可以不写 key 不会警告。

如果动画在过度事件内还未过度完成 但是状态被切换的话 会立即执行新的过度动画. 如果 v-if 的 key 都是重复的话 则会造成 如果动画过度时间很长 还未过度完毕 就执行新的状态切换 则会造成每次都会 v-if 为 true 时都会去创建新的 dom 然后执行过度动画 并且这些新的 dom 的过度不会影响 之前的 dom 的过度效果 过度结束后 之前的 dom 会消失 新的会保留。 并且每次切换的时候，第一轮创建的 dom 的最后一个会消失。

v-show 的话 不使用 key 直接是不执行动画的 且会报错.

key 如果设置重复的话 最后一个元素如果和上面一样快速点击执行状态切换的话 会造成最后一个 dom 隐藏后不再出现的情况.

v-if 的动画快速执行切换状态 每一次 动画都是独立执行的 因为动态创建与移除 dom 动画确实会独立执行 而 v-if 的动画 v-show = false 动画是独立执行的 但如果 v-show = false 动画 执行未结束 就执行 v-if true 则两个动画可以衔接上 过度是从 false 执行的位置 执行 true 过度的 但 true 执行不能和 false 衔接。

v-if 和 v-show 的动画应该都是异步处理的 我刚想起来 display none 如果同步也是无法触发动画的 dom 创建也是。

v-if 和 v-show 过度原理 本质上就是我们书写的 过度 class 动态的添加与移除。

transition 组件原理 https://www.cnblogs.com/onesea/p/17489417.html

vue transition 原理

Vue 中的 transition 原理主要是通过 Vue 的指令系统来实现的。Vue 在渲染元素时，如果元素被 `<transition>`包裹，Vue 会自动应用一些 class 来控制过渡效果。

基本的 Vue transition 使用方法如下：

```html
<transition name="fade">
  <!-- 需要被过渡的元素 -->
  <p v-if="show">Hello World</p></transition
>
```

```css
/* 定义过渡样式 */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active for <=2.1.8 */ {
  opacity: 0;
}
```

```javascript
new Vue({ el: "#app", data: { show: true } })
```

在这个例子中，当 `show`的值从 `true`变为 `false`或者从 `false`变为 `true`时，`<p>`元素将会触发一个淡入淡出的过渡效果。

Vue 为了实现这个效果，会在过渡的不同阶段添加或移除特定的 class：

- `fade-enter-active`：进入过渡生效时的状态
- `fade-enter`：进入过渡!开始时的状态，过渡进入完成之后，会立即移除
- `fade-leave-active`：离开过渡生效时的状态
- `fade-leave-to`：离开过渡完成时的状态，在过渡完成后移除

Vue 还支持更复杂的过渡，包括同时进入和离开的过渡、列表过渡等。

https://zhuanlan.zhihu.com/p/116605265?utm_id=0

vue 的过度太牛逼了，以后可以细细研究

## 回流与重绘

https://blog.csdn.net/qq_34595425/article/details/131464759

一个个 style 赋值性能要比直接 class 切换要低 虽然浏览器渲染页面是一次性绘制的 但是 dom 树的 render 是实时的

display none 的元素 进行 style 操作的时候 不会回流与重绘 当设置成 block 时只会进行一次回流与重绘

## 遇到最外层带边框 里面每个东西选中时也带边框 造成边框重叠叠加效果的解决办法

解决办法就外面的边框用 box-shadow 内阴影做 然后里面正常用边框，这样内部边框与内阴影是重叠的 不会有两条边框的效果 美滋滋 妈妈再也不用担心我要用 v-bind class 去处理边框了

常用场景包括 tab 切换

## bug：如果自动导入的组件名字和手动导入的 ts interface 或者 type 类型名字重复 并且在同一文件使用 会报错说找不到类型的导出，因为编译后的文件是没有类型的 所以类型不应该被导出使用。修改名字后就解决了

## route 定义跳转的时候 params 只能配合 name 用 因为 path 本身就包含 params 要么拼接要么 name+params

## 路由 浏览器地址栏的前进与后退 也是会触发 watch route 的 如果是同一页面的话 不是同一页面会触发生命周期重新执行

## 如果同一个 vue 页面 同时被 多个路由使用 或者有不同的 query 和 params 那么 他们之间互相切换 不会触发 vue 销毁与创建 除非手动在浏览器输入回车。

## template 里不能直接使用 autoimport 的变量 setup 里才能直接使用 如果想在 template 中用需要手动导入

localstorage 也不能被 template 直接使用，但是 window 和 math 可以

## RouteLocationNormalizedLoaded route 的 ts 类型

## git pull 拉代码提示代理错误

使用了 代理服务 比如开发者边车里的 git 代理 可以手动清空或者打开代理后再拉代码

代理的话 还还会开启 internet 选项的代理导致网页连不上网

https://blog.csdn.net/qq_21484461/article/details/124163545 清理 npm 代理

## flex warp 强制换行 是针对元素的 元素内的文字会自动换行 数字和长单词除外 汉字是会换行的

## el-input 的 max 和 min 控制的是 那个原生上下箭头的最大值和最小值 输入框的不能限制

## el-input 限制输入整数等分析

https://blog.csdn.net/Bruce__taotao/article/details/134554829

## el-input 限制为整数和小数，输入时顺序颠倒问题

https://blog.csdn.net/2202_75488715/article/details/136506224

## el-pagination 事件 不是绑定的按键 而是侦听的 pageSize 和 pageNum 也就是说不管在哪里修改 pageSize 和 pageNum 的值 都会触发分页的事件

## 路由地址 params 和 query 自己在浏览器修改会触发页面刷新 重新执行生命周期，而通过代码只修改 params 和 query 得话 不会触发生命周期

因此如果是前者 我们希望页面刷新执行一些方法，两种做法 直接写在 setup 里，每次刷新都执行，或者写在 watch route 但是要加页面首次加载执行，因为 route 改变会在 setup 执行前 watch 捕获不到，而后者 params 和 query 改变 进行某些操作的话，直接在 watch 里执行就好了 这种 watch 就监听得到了

## ts 实战系列十四：Record

https://blog.csdn.net/wanmeijuhao/article/details/135333704

https://juejin.cn/post/7112047649150205983

record `<T,K>`声明的类型在变量定义时 不能定义可选 T 都是必选

record 源码

```ts
type Record<K extends keyof any, T> = {
  [P in K]: T
}
// 它等于 type K = xxxx  type T = xxx
type A = {
  [P in K]: T
}
```

联合类型可用作 变量类型 但[P in K] 这种不能用作变量类型 但可定义为 interface 的 key 类型 因为 K 已经是类型了 [P in K] 等于脱裤子放屁 而联合类型不能直接作为 interface 的 key 使用

## 元素隐式具有“any”类型，因为类型为“string”的表达式不能用于索引类型

https://blog.csdn.net/qq_46258819/article/details/136295451

https://blog.csdn.net/hello_helloworld/article/details/131940440

https://www.5axxw.com/questions/simple/yrk1wn

问题出在我遍历对象属性的时候，定义的对象类型是 Object 类型 使用对象属性是 obj[key]报错了 这是因为 Object 类型 不是对象类型 而是 对象构造函数 Object 类型 这里要写成{[key:string]:any} 才是类型定义 这样 obj 才有了 key

或者把 key 断言为 as keyof typof Object 也就是从 object 种拿 key 得值

## ts 类型 如何取某个对象类型的属相类型

对象 interface['属性'] 不能用对象 interface.属性

## map 的类型定义

```javascript
constlistInfo = reactive(
  newMap < string,
  any >
    [
      ["品牌：", ""],

      ["商品编号：", 0],

      ["起订量：", "0"],

      ["限购量：", "0"]
    ]
)
```

而不能在 listInfo 后定义 除非 new Map 里不写内容 写了以后面内容类型为准

## 类型断言一定是使用的时候 而不是定义类型的时候

## await 接受的是 promise 成功状态的值 如果一直没有接收到 则后面的代码一直不执行。而不是接收不到变 undefined

## keyof typeof obj 和 keyof Interface 区别

一样的 没区别

## 声明对象属性 + 元素类型 无法获得类型推荐了

```typescript
type MyArray = {
  expand: boolean
  [index: number]: ProductDetail["modelMap"][]
}
```

上面这种写法无法获取类型推导了 改成下面

```typescript
type MyArray = {
  expand: boolean
} & ProductDetail["modelMap"][]
```

需要注意的是 [index: number]: ProductDetail["modelMap"][] 这种定义的其实还是对象 对象属性是 number 而不是数组

## input focus 触发弹框 只能用 click 而不能用 focus 的原因是 focus 触发弹框后，点击弹框的关闭按钮 并不会触发 input blur 导致下次 focus 无法触发 除非手动点一下 input 外面 或者弹窗关闭不点 x 点遮罩

原因是 element plus 对 dialog 进行了封装 就是如果点击 dialog 的 x 关闭弹框 那么如果是通过 input focus 打开的弹框 那么关闭弹框后 会重新聚焦 input 注意是重新 也就是说 input 的焦点 会聚焦 离开 聚焦

## axios 设置的请求拦截和响应拦截器 会对 axios() axios.get axios.post 等统统生效

## for in 遍历可以接受联合类型 可能是 undefined 或者 null 的对象 并且不报错 ts 但是必须要有对象类型这个联合类型里 且不能有 number string 等类型

js forin 对 string number null 等都不报错 只是不执行

后经过我测试 ts 是会对 forin undefined 类型或者 null 报错的 但是如果我们赋值的时候 真实的值的类型是对象 那么才不会报错 string number 同理

但是如果你在使用 for in 的时候给 key 断言类型 则反而会提示错误了又 说 obj 可能没定义 离谱 不知道是什么 bug

```js
for (const (key as any) in person.obj) {
  console.log(key);

}
```

也就是说 const key 后面不可以定义类型 要定义去 for 里面定义

## 从 Tailwind CSS 到 UnoCSS —— 原子化真的是现代前端 CSS 的救星吗

https://zhuanlan.zhihu.com/p/663336823

https://unocss.uihtm.com/guide/ unocss 官网

## TypeScript 实战-22-声明合并

https://blog.csdn.net/ABAP_Brave/article/details/101234299

## Ts 中 type 和 interface 定义类型扩展类型的方法

https://blog.csdn.net/m0_45219210/article/details/125757920

## jwt token 为什么要在前面添加 Bearer

https://blog.csdn.net/doiido/article/details/131976874

## 贝塞尔曲线 是控制动画速度的

## 内联 style 以及 style 不可以直接使用加减号计算样式 除非用 calc 或者 scss

## 逆天 bug：循环里可以触发动画 promise.all 不行

```typescript
function addToCart(e: MouseEvent) {
  if (isLoginIn()) {
    let hasNum = false

    const asyncArray = []
    productDetail.data.skus.forEach((element) => {
      if (element.num > 0) {
        hasNum = true
        asyncArray.push(
          addToShopCart({
            skuId: element.id,
            count: element.num
          })
        )
      }
    })

    Promise.all(asyncArray).then((res) => {
      const flag = res.some((item) => {
        return item.code === 0
      })

      if (flag) {
        cartShow.value = true
        cartPos.value.transition = "none"
        cartPos.value.top = e.clientY - 12 + "px"
        cartPos.value.left = e.clientX - 12 + "px"
        const domRct = document
          .querySelector("#shop-cart")!
          .getBoundingClientRect()
        requestAnimationFrame(() => {
          cartPos.value.transition = "all .5s ease"
          cartPos.value.top = domRct.top + "px"
          cartPos.value.left = domRct.left + "px"
        })
        setTimeout(() => {
          getShopCartList().then((res) => {
            if (res.code === 200) {
              appStore.shopCar = res.data
            }
          })
          cartPos.value.transition = "none"
          cartShow.value = false
          const dom = document.querySelector("#shop-cart") as HTMLElement
          dom.style.transform = "scale(1.3)"
          dom.style.transition = "all .2s linear"
          setTimeout(() => {
            dom.style.transform = "scale(1)"
          }, 200)
        }, 500)
      }
    })
    if (!hasNum) {
      window.$message.warning("请选择商品数量")
    }
  }
}
```

```typescript
function addToCart(e: MouseEvent) {
  if (isLoginIn()) {
    let hasNum = false
    productDetail.data.skus.forEach((element) => {
      if (element.num > 0) {
        hasNum = true
        addToShopCart({
          skuId: element.id,
          count: element.num
        }).then((res) => {
          if (res.code === 0) {
            cartShow.value = true
            cartPos.value.transition = "none"
            cartPos.value.top = e.clientY - 12 + "px"
            cartPos.value.left = e.clientX - 12 + "px"
            const domRct = document
              .querySelector("#shop-cart")!
              .getBoundingClientRect()
            console.log(domRct)

            requestAnimationFrame(() => {
              cartPos.value.transition = "all .5s ease"
              cartPos.value.top = domRct.top + "px"
              cartPos.value.left = domRct.left + "px"
            })
            setTimeout(() => {
              getShopCartList().then((res) => {
                if (res.code === 200) {
                  appStore.shopCar = res.data
                }
              })
              cartShow.value = false
              const dom = document.querySelector("#shop-cart") as HTMLElement
              dom.style.transform = "scale(1.3)"
              dom.style.transition = "all .2s linear"
              setTimeout(() => {
                dom.style.transform = "scale(1)"
              }, 200)
            }, 500)
          }
        })
      }
    })
    if (!hasNum) {
      window.$message.warning("请选择商品数量")
    }
  }
}
```

可能是浏览器的 bug(存疑)

解决办法是在 promise.all.then 里第一次修改还原 style 的地方 也包一层 RAF

第二种 也有概率出现 过渡动画没执行 或者说看起来没有执行的现象,其实也需要包 RAF,只不过可能是 vue 异步队列处理了的问题(存疑) 导致有时候会产生动画 有时候不会

执没执行原来是问题出在 背景小球的动画是否出现啊 好离谱的 bug 也可能是浏览器对动画队列优化所造成的吧

小球出现 车过渡执行 小球不出现 不执行 后面测试发现给小球也没关系 是谷歌动画调试工具的问题 打开就有动画

## Vite 深入浅出及原理分析

https://zhuanlan.zhihu.com/p/609650970

## vite 打包性能优化以及填坑

https://blog.csdn.net/lambert00001/article/details/131868527

## 实现扩展 external 能力的 Vite 插件

https://blog.csdn.net/Ashen__/article/details/128025431

## 快速理解 Vite 的依赖预构建

https://zhuanlan.zhihu.com/p/561139849

## vite 依赖预构建-依赖扫描

https://blog.csdn.net/weixin_43294560/article/details/126353822

## [Vite 是如何实现 Esbuild 打包的](https://segmentfault.com/a/1190000043980887)

## axios 类型扩展完整代码

```typescript
declare module "axios" {
  export interface AxiosRequestConfig {
    loading?: boolean
    status?: string
    noToken?: boolean
  }

  interface AxiosInstance {
    // config confiog配置类型
    (config: AxiosRequestConfig): Promise<ResponseDataType>
    get(url: string, config?: AxiosRequestConfig): Promise<ResponseDataType>
    post(
      url: string,
      data?: any,
      config?: AxiosRequestConfig
    ): Promise<ResponseDataType>
    put(
      url: string,
      data?: any,
      config?: AxiosRequestConfig
    ): Promise<ResponseDataType>
    delete(url: string, config?: AxiosRequestConfig): Promise<ResponseDataType>
  }
}
```

新增了对 post get 等方法的支持

## 通过 defineExpose 暴露得 ref 对象 使用时 不需要.value （待测试）

测试的确是的

ref 会和在普通实例中一样被自动解包 官网说的

## 对象从一个对象身上获取一些属性做法

https://www.cnblogs.com/gubaba/p/16505689.html

## vue template 模板中使用函数 return 的 ref 如果是字符串类型会出现双引号 原因未知 带冒号的情况 reactive 不会有这个问题

给 vue 提 issue 他们貌似很早也有人提出这个问题 但是并没有修改

## inline-flex 的元素 margin: 0 auto 不会生效 但 flex 可以

inline-flex 元素不换行且 flex 布局

## flex 情况下 会导致 vertical-align 属性失效

## 3 种方式禁用浏览器滚动条

一般用来做 弹窗滚动条隐藏 不可滚动

https://blog.csdn.net/mpr0xy/article/details/116172305

## axios 取消正在请求的接口

https://juejin.cn/post/7284417436752265277

`CancelToken`和 `AbortController` 两种形式 后者是原生的 前者是 axios 内置的 后者还可以取消其他事件比如 click 等

如果再请求拦截器里 本次请求时取消上一个接口 控制台会报错信息 但接口取消了 如果接口是连续请求的 如果取消上次请求没有使用计时器去执行 不创建新的宏任务 那么 axios 会不发请求 也就意味着 上个 axios 请求发出的时机晚于新的 axios 里取消上个 axios 请求的时机。

如果加了计时器 则有可能取消接口有可能不取消 根据时间执行顺序，接口请求是异步的。

并且取消请求虽然请求没有发出去 但依然会走响应拦截器 因此要在响应拦截器错误回调里进行一些处理

## h 渲染函数通过第二个参数 props 定义事件的时候，要么使用函数名要么定义函数 而不能使用函数加()的形式 否则 h 在创建虚拟 dom 的时候就会执行函数，因为他认为 函数()的意思是 这个事件是被这个函数执行 return 的新的函数。

## naiveui 的全局设置主题配置没有生效 不知道什么原因

https://www.naiveui.com/zh-CN/os-theme/docs/customize-theme

## lodash 常用方法

difference 多个数组 取不重复的值

uniq 数组去重

isEqual 对象相等判断（包含属性相同的两个引用不同的对象 数组 字符串 等等） 数组元素相同 但位置不同也不算相同

## naiveui table 修改选中的 keys 数据 table 选中状态同步更新

https://github.com/tusen-ai/naive-ui/issues/3613

本来用的 default-keys 那个 prop 那个可以改变表格初始渲染的选中状态 但没法修改选中项后表格也更新选中状态 即便修改了 defaultkey 的值 解决办法是 换乘 v-model:checked-row-keys

## el-checkbox 半选状态

indeterminate 控制 如果这个值是 true 则是半选状态 即便 v-model 的值是 false 也是 false 也会半选除非两个都是 false

## axios 导出 excel 表格

首先后端返回给我们的数据是一团乱码，这里有两种处理方式 1 是直接拿这个数据 new Blob 处理(存疑？ 后经我测试 new blob 处理字符串后下载得文件打不开) 2 是直接在 axios 的请求配置里加上 responseType 让 axios 给我门用 blob 处理好 在响应拦截器里就直接是 blob 文件了 然后再进行处理

https://blog.csdn.net/yyh123456hhh/article/details/131637151

vue+axios+element-ui 实现导出 excel 文件且显示导出百分比进度条

```typescript
let elink: HTMLAnchorElement | null = document.createElement("a")
// 创建a标签
elink.download = "一键询价模板" + ".xls"
// 设置a标签属性 download是下载名
elink.href = window.URL.createObjectURL(res as Blob)
// href属性为 新创建的一个url地址 这个就是浏览器的本地的那个文件地址
elink.click()
// 点击它下载
window.URL.revokeObjectURL(elink.href)
// 释放掉那个地址
// URL 接口的 createObjectURL() 静态方法创建一个用于表示参数中给出的对象的 URL 的字符串。

// URL 的生命周期与其创建时所在窗口的 document 绑定在一起。新对象 URL 代表指定的 File 对象或 Blob 对象。

// 要释放对象 URL，请调用 revokeObjectURL()。
// 也就说 URL自动释放是在网页关闭时
elink = null
```

我看还有些人做法是把这个 elink 插入到页面 然后弄完再移除 没必要 因为 不插入页面也可以触发 click 事件下载。

window.open(URL createObjectURL(xx))也会触发下载 只不过 页面会闪一下 因为 window.open 会先把链接当作网址去新窗口打开 发现是文件 再执行下载并且关闭新窗口 window.open 下载文件无法改名 想改名就必须得用创建 a 链接得方式。

```js
const blob = new Blob([res], { type: "text/plain" })
const fileName = "敏感词库.xlsx"
```

上面代码最终下载的格式是 xlsx 因为下载文件得最终格式是 fileName 决定的 如果 fileName 没有后缀 那么格式以 blob 的 type 为准 也就是说最终由 blob 转为文件时候 是要以后缀格式为准转换一次的

.xlsx 和.xls 最终都可以转换并打开

https://blog.csdn.net/weixin_54930261/article/details/139001437 responseType 是原生 ajax 提供的能力 明天测试如果换成 arraybuffer 会怎样

不知道 xhr 是如何通过配置一个 responseType 就把数据转成 blob 的，我自己没办法将 res 乱码手动转成 blob

https://juejin.cn/post/6844903933626810382

URL createObjectURL() 也可做文件预览 FileReader.readAsDataURL(file)也可以 那么同理 FileReader.readAsDataURL(file) 也可以做文件下载

## ts unknown 应用场景

https://www.jb51.net/article/283236.htm#_lab2_0_0

用于类型断言 比如函数的参数 声明的是 number 类型 但这里我们想要把它赋值为 其他类型 则可以先把他断言成未知类型 然后再去赋值就不会报错了 any 同理

https://blog.csdn.net/wanmeijuhao/article/details/135328656

## file input change 事件声明类型 不报错说 files 不存在的写法

```typescript
function upload() {
  const target = event?.target as HTMLInputElement
  const file = target.files![0]
  console.log(file)

  const fd = new FormData()
  fd.append("file", file)
}
```

## xhr.responseType 作用

https://www.jianshu.com/p/d647643e62d9 是告诉浏览器如何解析响应数据 浏览器会帮我们解析成想要的数据格式 然后供我们处理 比如处理 excel 的时候 这么写 好处是 不用我们去处理后端数据为 blob 了 浏览器会处理好

_responseType 的默认值为 json_

## axios 的 config 配置 三个地方都会用到 如果设置了某个属性必穿 但是 没有在 create 的时候定义它 则报错 或者每个接口请求时携带它 ts 就不报错了

分别是 create 的时候 请求拦截 config 以及真正发请求时候的 config 写在 axios.get 的时候

## vue3 按需引入 element plus 组件库、修改主题颜色

https://blog.csdn.net/qq_45345113/article/details/139735655

## naiveui table 即便设置了 maxwidth 如果文字过多 依然会去占用 没有设置 minwidth 的单元格的宽度 导致宽度比我们设置的 maxwidth 更大 除非那个单元格也设置了 minwidth

## forin 是无序遍历 也就是 key 不一定是从第一个到最后一个的顺序

Object.keys 排序错乱

https://blog.csdn.net/weixin_33414202/article/details/117375129

## js 让 forof 可以遍历对象

https://blog.51cto.com/u_16099179/7607321

## JavaScript 中 keys()和 getOwnPropertyNames()详解。

https://blog.csdn.net/wzg0817/article/details/105836538

## ui 组件中 对表格进行列设置宽度的标签 colgroup

`<colgroup>` 标签用于对表格中的列进行组合，以便对其进行格式化。

通过使用 `<colgroup>` 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。

**注释：** 只能在 `<table>` 元素之内，在任何一个 `<caption>` 元素之后，在任何一个 `<thead>`、`<tbody>`、`<tfoot>`、`<tr>` 元素之前使用 `<colgroup>` 标签。

可以设置列 的宽度 背景色 等等 用于格式化表格 naiveui element 都在用

如果某一列通过 display none 隐藏了列 那么它的 `colgroup 会被别的列所使用，自己跳过使用了  这应该是html决定的不是组件`

如果表格需要做滚动效果的话，的确需要两个表格。 naive 组件也是这也的如果不需要滚动就一个表格 需要滚动就俩 因为表格 tbody 是无法做滚动的 必须 table 外才可以

## naiveui 的 expand 展开内容 只有触发展开事件 内容出现的时候 才会执行创建展开的内容 而不是一开始就创建然后隐藏的。

并且每次展开与关闭 都是创建与销毁 也就是说其实这一块是 vif 而不是 vshow 这和我们自己手写菜单或者树的写法是一样的 因为我们不知道用户是否会展开全部的菜单 因此初次渲染的时候如果 v-show 性能损耗太大了。 但当我们全部一级菜单被创建了之后，用户通过 v-if 再去切换的时候 耗费的性能可以忽略不计，因为 vue 主要关心的是首屏加载时间。

## el-radio 也可以不配合 el-radio-group 使用 用法是 radio 身上写 v-model 和 value 当 v-model 值等于 value 的时候 radio 选中 而其他的 radio 同时绑定这个 v-model 的 value 不等于它 会直接取消勾选

## vue template 中事件加不加括号的区别

最简单的一种就是 不加括号默认第一个参数是 e 加括号的话想要获取 e 需要手动传入$event 或者在函数内用 event 加括号可以传参

https://blog.csdn.net/weixin_56008510/article/details/121948791

https://www.zhihu.com/question/55753541

根据知乎的回答 可以看出 不加括号的话 vue 会去判断实例身上是否有同名 的方法函数 有的话 执行它， 如果没有 则用函数包一层 然后执行这段代码。

当然如果直接写成函数形式或者箭头函数的形式 和直接写方法名是一样的都会执行函数，而直接写 js 代码或者带括号执行函数 则要用函数包一层执行。

```javascript
  <h1 @click="()=>{console.log(123)}">{{ msg }}</h1>
  <h1 @click="abc()">{{ msg }}</h1>
  <h1 @click="1 + 1">{{ msg }}</h1>
  <h1 @click="abc">{{ msg }}</h1>
```

编译成 render 后的代码 可以看出 直接写表达式和 函数调用 是会包一层 而直接使用函数或者 setup 的函数 则不会

```javascript
import {
  toDisplayString as _toDisplayString,
  createElementVNode as _createElementVNode,
  vModelText as _vModelText,
  withDirectives as _withDirectives,
  Fragment as _Fragment,
  openBlock as _openBlock,
  createElementBlock as _createElementBlock
} from "vue"
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock(
      _Fragment,
      null,
      [
        _createElementVNode(
          "h1",
          {
            onClick:
              _cache[0] ||
              (_cache[0] = () => {
                console.log(123)
              })
          },
          _toDisplayString($setup.msg),
          1 /* TEXT */
        ),
        _createElementVNode(
          "h1",
          {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.abc())
          },
          _toDisplayString($setup.msg),
          1 /* TEXT */
        ),
        _createElementVNode(
          "h1",
          {
            onClick: ($event) => 1 + 1
          },
          _toDisplayString($setup.msg),
          1 /* TEXT */
        ),
        _createElementVNode(
          "h1",
          { onClick: $setup.abc },
          _toDisplayString($setup.msg),
          1 /* TEXT */
        ),
        _withDirectives(
          _createElementVNode(
            "input",
            {
              "onUpdate:modelValue":
                _cache[2] || (_cache[2] = ($event) => ($setup.msg = $event))
            },
            null,
            512 /* NEED_PATCH */
          ),
          [[_vModelText, $setup.msg]]
        )
      ],
      64 /* STABLE_FRAGMENT */
    )
  )
}
```

## dayjs 官网说不能直接 import 导入 但是我使用可以 回头可以测试

```
{ //tsconfig.json
  "compilerOptions": {
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
  }
}
```

## v-for ts 不会报错 undefined 或者 boolean 的话 回去测试

## ts 感叹号断言 也会报错 用的多了 但 as 没事

```typescript
row.nowSelect?.skus.find((item) => item.id === row.nowSelect?.sku)!
  .untaxedPrice! / 100
```

```typescript
;(row.nowSelect?.skus.find((item) => item.id === row.nowSelect?.sku)!
  .untaxedPrice as number) / 100
```

error Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong @typescript-eslint/no-non-null-asserted-optional-chain

在 TypeScript 中，`Optional Chain Expressions` (?.) 允许你安全地尝试访问可能为 `null`或 `undefined`的对象属性。当你在可选链后使用非空断言感叹号(!)时，你告诉编译器你确信该表达式不会返回 `null`或 `undefined`。然而，如果实际上它可能是 `null`或 `undefined`，这种做法就会导致运行时错误。

这个 `@typescript-eslint/no-non-null-asserted-optional-chain`规则警告你可能存在的不安全行为：

1. **潜在的未定义值** ：可选链操作符已经设计为在遇到 `null`或 `undefined`时停止，但非空断言会忽略这个保护，可能导致运行时错误。
2. **代码错误** ：使用非空断言表示你认为表达式总是有值，但实际情况可能并非如此，这可能是代码逻辑的错误。
3. **类型安全** ：使用非空断言削弱了 TypeScript 的类型检查优势，因为它假设了一个可能不成立的前提。

解决这个问题的方法：

- **删除非空断言** ：如果可选链后的值可能为 `null`或 `undefined`，移除 `!`，让 TypeScript 的类型系统来处理可能的 `undefined`。
- **添加条件检查** ：在非空断言前添加条件检查，确保对象和属性确实存在。
- **重构代码** ：考虑是否可以避免使用可选链和非空断言，或者将数据结构设计得更安全，减少不确定性。

记得在修复后，重新运行 ESLint 以确保解决了警告。

该问题出现的场景是 再?.的属性后面使用! 不安全 因为!意味着肯定存在 ?.意味着可能存在 二者矛盾

## ts 定义的 ref 数组 不指定类型 直接 ref([])默认是 never[]

## ts reduce 报错类型重载的原因 定义的 sum 第一个参数的值 可能与初始值不同 比如内部 sum + 的值可能是 undefined

## bug：组件中 如果没有根元素 那么其中的元素/组件 使用 deep 是无法样式穿透的

因为样式穿透要加在根元素上 没有根元素 [data-v-xxx] 元素就找不到元素

## 页面通过路由进入的页面中的 watch 路由第一次永远不会执行 除非手动指定 watch 第一次执行

这是因为 route 的改变 是在组件创建之前的，因此监听不到。

但 app 中的 route 监听可以监听到其他路由切换，因为 app 是最外层的组件。 并且 router-view 放在 app 里的最早有可能放在这里的 因此就算进入首页也可以 watch 到

因此我们不必担心 页面刷新时会触发 watch route 当前

## new Date

new Date()获取的是浏览器所在计算机的系统时间。如果浏览器没有联网，那么获取的就是本地时间。如果浏览器联网了，那么获取的就是服务器时间。

## dayjs 获取减去一定时间和加上一定时间的用方法

```js
dayjs("2019-01-25").add(1, "day").subtract(1, "year").year(2009).toString()
// 单位可以是day 可以是week 可以是month 可以是year
```

## el-selected ref 的 visible 属性是控制 下拉显示与隐藏的

visible-change 是当下拉框出现/隐藏时触发 也就是 visible 值改变时触发 如果在这个事件里 将 visible 的值状态修改 那么会直接影响 selected 下拉 隐藏或显示。 因为异步更新的原因

## el-datepick 踩坑

default-time 相较于 elementui 从字符串[] 变为了 Date[]

并且 format YYYY-MM-DD HH：mm：ss 这里 hh 不能写成 hh 否则是按照 12 小时制算的即 0 点是 12 点 0 - 12 0-12 两个 0-12

并且 datepick 中没有 24:0:0 这个概念的 因为是下一天的 0 点 一天时间最多是 23：59：59

## el-button 可以使用 textalign 直接居中

原因是本质上 el-button 就算 button 元素 它和其他行内元素 比如 img input 等都可以直接背 textaligncenter 控制

## el-from model 不设置的话 rules 也会生效

只是无论我们输入什么 都过不了 rule。

也就是说 trigger 触发和 required 是根据绑定的 prop 来触发的 也就是说 那个 item 上 prop 绑定了 rules 中的属性 则 item 内的表单触发了 trigger 就会进行校验 不管你 vmodel 绑定的什么属性。 但是 prop 用来做校验的属性是 model 绑定的那个表单 + prop 属性 来获取的 没有 model 则属性永远不会过校验

# 也就是说表单组件触发 blur 或者 input 时 会通过作用域插槽去校验 model[prop]根据对应 rules

也就是说表单组件触发 blur 或者 input 时 会通过作用域插槽去校验 model[prop]根据对应 rules

除此之外，resetFields 也是根据 model+prop 来重置字段的 而不是简简单单的将 model 的对象重新赋值成备份的值。 而是根据 prop model[prop] = model 备份值的[prop] 如果 prop 对应不上 则值不会被重置

另外重置值的时候 是直接通过 model[prop] = model 备份值的[prop] 来重置的 因此如果 prop 设置了一个根本不存在 model 里的 prop 那么重置后的数据里会多一个这个不存在的 key 值是 undefined 比如 form 里有个 a 属性 但是 prop 写的 b 那么执行重置时 a 的值不会被清空 反倒会多一个 undefine 的 b 也就是说 v-model 每个表单元素和 model prop 都可以控制表单的值 这两个要统一 表单才不会有问题

## path:'/shop' 和 path:'/shop/:id'是两个不同的路由

并不是说定义的路由是/shop/:id 而直接访问/shop 就能访问的到 实际是访问不到的 因为带动态路由参数的路由必须要有参数才能加载组件 如果两个 path 都配置了 component 那么通过/shop/:id 路由加载的组件是独立的 和/shop 的组件没有任何关系 切不会影响他子路由组件的显示 因为子路由组件显示什么需要在 children 里配置。

如果 shop 的子路由中有/xx 那么通过 shop/xx 访问的时候有限展示 shop 动态路由参数路由优先级在后

## n-data-table 选中状态切换触发事件的两种做法

1 是 watch ckecklist 2 是选中事件 on-update:checked-row-keys 这个选中事件与 v-model:checked-row-keys 不冲突

## computed set 用法 灵感来自 若依 vue3 pagination

currentPage 和 pageSize 不再是变量 而是计算属性了 使用时走 get 获取 props 的值 修改时出发 emit 修改 prop

```
const currentPage = computed({
  get() {
    return props.page
  },
  set(val) {
    emit('update:page', val)
  }
})
const pageSize = computed({
  get() {
    return props.limit
  },
  set(val){
    emit('update:limit', val)
  }
})
```

## step css animation

step 不可与 ease linear 等属性共用 否则不生效 因为本质上他们都是同一个属性（animation-timing-function）

steps 不传第二个参数默认是 end 也就是跳过最后位置

https://blog.csdn.net/dongguan_123/article/details/62416576

infinite 是无限执行动画 forwards 是执行完毕停留在动画结束终点位置 backwards;动画结束后立即回到初始位置

alternate 正反序交替执行

infinite +alternate 动画会无限执行完再反向执行 再正向 以此类推

reverse 反序执行

https://developer.mozilla.org/zh-CN/docs/Web/CSS/easing-function

http://web.chacuo.net/css3transition#google_vignette

颜色也是有动画和过度切换的，文字大小和颜色不知道以后用到的时候再测试。

step-end/start 会没有动画效果

https://blog.csdn.net/qq_21567385/article/details/108915286

https://blog.csdn.net/a460550542/article/details/129255916

https://www.cnblogs.com/mengff/p/17648492.html

https://www.51cto.com/article/758090.html

## 若依接口节流的实现逻辑

针对所有接口 每次请求将 url 和 data 以及调用时间存在 session 里 每次掉接口与 session 里的对比 相同就报警告 return 不同直接调用然后存下

## 关于使用三维实景建模软件「ContextCapture」的经验总结

使用图片自动生成模型的工具

## 定位的元素 百分比宽高 left top 等属性 相对的父元素是父元素中最近的具有定位的元素

但 font-size 不是

## fixed 元素 如果在其他定位的元素内 那么会受 和定位元素平级的其他定位元素的 z-index 影响被遮挡

## axios.post params 要写在第三个参数对象里

没有 data 的话第二个参数就传任何表示 false 的东西即可

## 报错：has naming conflicts with other components, ignored

https://blog.csdn.net/gongm24/article/details/139878762

unplugin-vue-components 报错 组件命名重复

## 可以在 element 的 rules 中 通过 type 去指定输入框类型

比如 email

## 无障碍模式与 aria-label

https://www.cnblogs.com/longmo666/p/18005646

## route 的 matched 属性 表示当前展示的内容包含哪些组件

不知道 keep alive 的算不算

## el-checkbox-group vmodel 绑定的必须是一个数组 否则无法点击选择

## 1kb 可以存放 1024 个英文字符或者 512 个汉字

这也是为什么若依会用 Object.keys(JSON.stringify(obj)))来判断接口请求数据大小了，虽然不咋准确 但是大概是 因为谁会请求的时候带很多汉字呢。

1 字节(Byte) 等于 8 比特 bit 1kb = 1024 字节 1 字节可以存放 1 个英文字符或半个汉字

1 字节最多存放 8 个 0/1 最大可表示 255

## 定位优先级高于 flex 绝对定位不会被父元素的 flex 影响

## proxy serve 代理 /api:

最终 api 转换的地址是 127.0.0.1/api 而不是 127.0.0.1 因为这是简写 如果不想带 api 则需要 rewrite 属性去替换为空

rewrite 可以匹配请求的完整路径 而不仅仅是代理的那个字符串

## match 正则匹配的方法

返回一个数组 第一个值是被匹配的完整字符串，第二个是

## 定位优先级高于 flex 绝对定位不会被父元素的 flex 影响

前提是定位设置了自己的 top left

## call 可以实现 class 继承的 polyfill

https://blog.csdn.net/Everyonesfather/article/details/111397385

## 若依的字典匹配做法

字典组件要求传 2 个参数一个是字典的 keyvalue map 一个是需要匹配的值 value 他可以是数组可以是单个 然后让字典根据 options 去 v-for 去渲染 只有当 value includes options 的 item 的时候才创建 tag 值是 label

## pre 标签

可以在其中放置 行内与文本元素 并且会保留空格与换行符

## code 标签

`<code>` 标签是一个短语标签，用来定义计算机代码文本。

## 父子组件传值时，如果子组件中某个属性来自于 props，当父组件将那个属性重新赋值时，此时如果那个属性是对象则断开引用，导致子组件赋值 props 属性的那个变量从此失去响应式。

解决办法 toRef

toRef 只传一个参数，等于直接对其使用 ref 返回一个 RefImpl

toRef 传一个 getter 函数 返回一个 getterRef

toRef 传两个参数 第一个参数是 reactive 对线 第二个是属性则返回一个 ObjectRef

toValue 用来规范化值 将值、refs 或 getters 转为值 但不改变原本的 ref 对象 只是得到一个新值

## HTMLInputElement

**`HTMLInputElement`** 接口提供了特定的属性和方法，用于管理 [`<input>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input) 元素的选项、布局和外观。

https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement

这个就是专门表示 input 标签的接口

## fileList 是只读的 input 的 files 属性是只读的 这就意味着多选上传的文件是不可以删除的

element 的 upload 删除是假删 文件还在只是 ui 不显示了 上传也是过滤掉

## 要避免多个组件传值的时候 通过每个组件内部 v-model + watch + toRef 的方式更新初始值

否则易造成 无限触发 watch 的情况 子的 watch 会触发父数据的更新 而父数据的更新又会造成子 watch 再触发

可配合父子组件传值更新 传同一个值是否会 update 测试

## el-tree 初始就带 current 选中做法

highlight-current :current-node-key="id"

node-key="deptId"

highlight-current 是点击节点高亮 取消高亮的做法是 setCurrentKey(null)

setCurrentKey 想用必须设置 nodekey 属性 nodekey 是什么无所谓 不一定非要有的属性

# 三者缺一不可 不过 tree 每次 id 更换都要 v-if 重新创建不然 下次切换 id 不会重新 current 不过用 tree 内置的 setCurrentKey 可以解决这个问题 缺点是这个有延迟 得用异步任务调用

## async 函数 内部 return 同步的内容会被作为 promise 的状态返回

包括 await 的内容和之后的 但是不能有异步的 异步的会认为 return undefined

## emits 触发子传父传的参数如果和父传子的值一样 不会触发更新

## 子组件 watch props 然后 emit 更新 props 是有可能造成无线循环的

## vue 不让我们给 Object.prototype 身上加自定义属性

## 如果需要获取一个可能不存在的类型需要用三元式

item: { name:string } extendsProductDetail["skus"]["0"]

    ?ProductDetail["skus"]["0"]

    :any

skus 可能是空数组

## 一个算术式中 三元式的运算优先级最低

1 + 2 \* b? b:0

先算 2\*b 再 1+ 2 x b 然后再判断存不存在 存在 b 不存在 0

这也就意味着 算术表达式中有三元式参与运算的话 要用括号包起来

1 + 1 +1 +1 +1 +1 + 2 ===0? 2:3

结果是 3

## rgba 与 hsla 颜色值的区别

https://blog.csdn.net/m0_65012566/article/details/138498978

后者可以控制颜色的亮度与对比度。

## filter 与 backdrop-filter 的区别

https://zhuanlan.zhihu.com/p/696110713

前者是对元素整体设置一个滤镜 后者是为元素的背景设置滤镜 一般用于制作透明导航栏加点模糊效果的时候用 夸克浏览器的固定导航栏就用的这个

## vue3 计算属性本质是 get 和 set 是 ref 因此在 script 里使用时要.value

因为计算属性 本身得到的就是一个 computedRefImpl

## flex 不设置 align-items 的话 默认是 stretch 平铺占满侧轴 设置成 center 或者 flex-start 则是元素自身大小

## 元素高度不等于内部图片高度解决办法

https://blog.csdn.net/weixin_45272449/article/details/102678481

原因： 因为 img 标签是行内标签自带间距，导致图片和 div 之间有间隙

https://zhuanlan.zhihu.com/p/634696273

[ ] vertical-align**: **middle**;** 也可以解决这个问题 感觉还是对齐方式的锅 是的 因为行内元素 文字这种 img 都是基线对齐的 而基线的话 gq 这种 文字在基线之下 底线上 因此图片会留出 基线到底线的高度

## vertical-align 各个属性值的含义

https://blog.csdn.net/qq_44960253/article/details/106946823

之前设置了一个 img 高度为 50px 但有 1px 的 border 放在高度为 50px 的盒子里 发现底部的 1px border 不显示了 鼠标检视一看 50px 的盒子里面包裹图片的盒子变 54 了 了 显示不全图片 border 修改了 vertical-align top 让图片顶部对齐才解决

## window.screenX screenY

是窗口距离电脑左上角的距离

要注意的是 如果电脑是分屏的话 可能会不准确

## 组件使用时 如果传递属性 且 组件内部有根节点 那么 组件上的属性最终会透传到 根节点上

如果组件内部是组件的话 会透传到组件身上

也就是说 子组件如果有根节点或者单个组件 被父组件使用时 父组件写在子组件上的 attribute 属性 就等于直接写在子组件中的根节点上。

因为构建 dom 树的时候，遇到子组件时候就等于是把子组件的代码片段 替换掉 自定义标签。

准确来说是 创建虚拟 dom 的时候使用 createVnode 传递子组件 render 函数 然后把 props 作为第二个参数传递，若子组件内部只有一个根组件 则会在执行 render 函数的时候 将父组件传递来的 props+子组件内部使用根组件时的 props 合并后 渲染。

这一点在 react 的 render 函数转虚拟 dom 时学过

## html 元素位置的几个参数总结

https://blog.csdn.net/hannah2233/article/details/128425977

offsetTop,offsetLeft 任一元素相对于祖先元素中具有定位的元素的上边距与左边距，无定位祖先元素以 body 为准

clientTop clientLeft 元素的 border 宽度 上 左

scrollTop scrollLeft 获取一个元素 xy 方向上滚动被卷去的距离

clientX clientY 距离可视窗口的距离 只有点击事件有

offsetX offsetY 距离父容器的距离 只有点击事件有

offsetWidth offsetHeight content+padding+滚动条+border

clientWidth clientHeight content+padding

scrollWidth scrollHeight 无滚动条情况下等于 clientWidth clientHeight

有滚动条情况下 clientWidth clientHeight 元素 width height+padding

scrollWidth scrollHeight 内容真实大小 + padding 这里真是大小指滚动条的全部内容

clientWidth scrollWidth 大小都不计算滚动条在内

offsetWidth 计算滚动条在内 滚动条会占用 content 导致 content 内容变小 比实际大小减去滚动条的宽度

滚动条在 padding 外在 border 内 但是占用的 content 的大小而非 padding

也可以理解为 content 大小 = 元素宽高 - 滚动条大小

**`Element.getBoundingClientRect()`** 方法返回一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，其提供了元素的大小及其相对于[视口](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)的位置。

该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

## box-shadow

box-shadow 可以逗号写多个属性 这些属性会叠加 并且 box-shadow 是给盒子四边设置的 如果只想给三边则需要 x y 自己移动

## el-date-picker 通过 disabled-date 做时间禁止选择

## 比如统一解决 手机号码让输入中文 如果每个都加 input 事件太麻烦 使用自定义指令可以解决这个问题

```javascript
el.querySelector('input')!.addEventListener('input', (event: Event) => {

    consttarget = event.targetasHTMLInputElement;

    constvalue = target.value;

    target.value = value.replace(/[^\d]/g, '')

    console.log(binding);

    binding.value = target.value

    });
```

## maxlength 输入时就生效 minlength 得表单提交才生效

## body 中最后一个元素得 margin-bottom 不属于 body 属于 html

同理第一个元素得 margin-top 也一样

## upload 上传一张或者多张后隐藏上传按钮做法

与之前通过 v-bindcss 绑定属性的麻烦相比 最简单的方式是 设置一个 class 放在 upload 组件上 让里面的 upload 属性 display none 然后自定义 class 使用 因为 card 与 upload 是两个分开的盒子

## el-upload file-list 加不加 vmodel 的区别

这个属性是默认上传文件列表 不加 v-model 通过上传选择文件后 数据不会加入到 file-list 里 加了 v-model 才会加入到 list 里 并且删除也会同步删除数据和 ui

另外 change 事件里自己通过 v-model 的数据来移除图片 比如大小不符合时 需要异步 同步的话 那个时候数据还没有更新过来执行 pop 不生效

但是可以直接通过 change 第二个参数去 pop 移除图片 这个移除是同步的 好处是与异步自己处理比不会图片先出现又移除 而是直接不出现

添加图片也一样 一个需要异步一个直接添加 另外通过往数据里 push 添加的图片默认状态是 success 也就是图片上带钩子

```typescript
// 一个完整的上传方法
async function upload(
  uploadFile: UploadFile,
  uploadFiles: UploadFiles,
  flag: number
) {
  console.log(flag, list)

  const type = uploadFile.raw?.type.replace(/image\//, "")
  if (uploadFile.size! > 1024 * 1024 * 5) {
    window.$message.error("文件大小不能超过5M")
    uploadFiles.pop()
    return
  } else if (!accept.includes(type!)) {
    window.$message.error("文件格式不正确")
    uploadFiles.pop()
    return
  }
  const obj = {
    url: await ossUpload(
      "infra/file/product-list-url",
      uploadFile.name,
      uploadFile.raw!
    )
  }
  switch (flag) {
    case 1:
      uploadObj.data.frontOfCardImg = [obj]
      break
    case 2:
      uploadObj.data.cardReverseImg = [obj]
      break
    case 3:
      uploadObj.data.businessLicense = [obj]
      break
    case 4:
      uploadFiles.pop()
      uploadObj.data.otherImg.push(obj)
      break
    default:
      break
  }
}
```

## ts 如果设置了 interface 并且给对象使用 然后如果 delete 删除属性 会报错

属性可选符号 有一个就行了

```javascript
form.address?.provinceAreaId ||
  form.address.cityAreaId ||
  form.address.countyAreaId
```

## el-input 和 datepicker 虽然都有 input 框 但是 二者 input 内部的元素还不相同 因此有时候设置高度需要两个都设置 只设置 input 会导致 datepicker 的 el-input 高度不变使用了默认值 但是如果高度统一设置在 el-input 上则没问题

设置 el-input-warp 上只有 input 生效 而 date-picker 的 el-input 没有生效 el-input-warp 生效了

## input 通过正则匹配不让输入中文时遇到的问题

一开始匹配电话 电话只能要数字 因此通过 `[^\d]` 与 `\D`

在正则表达式中，`[^\d]` 与 `\D` 的功能相同，都是用来匹配任何非数字字符。方括号 `[]` 定义了一个字符集，其中的 `^` 符号放在开头表示“不包括”，也就是说 `[^\d]` 意味着“不在 \d 定义的范围内”，也就是除了数字以外的任何字符。

在正则表达式中，`\d` 和 `\D` 是两个用于匹配数字和非数字字符的元字符

但是发现了问题就是 如果使用输入法输入中文时 如果输入拼音未选择文字 会自动删除以存在的数字 英文输入下不会

即便改成通过 event.data 匹配每次输入的文字 也不能解决这个问题 后续可以思考一下

而另外一个匹配身份证的正则也就是只能输入 X 与数字/[^a-z\dX]/gi 则没这个问题

## 手动往 filelist 里 push 的文件信息 默认会有 status 和 uid 因此我们只需要给 url 就行

## dayjs 获取本周时间的坑

https://blog.csdn.net/weixin_43653606/article/details/137257732

startOf('month') 和 year 没这个问题

## **proto** 注意事项

构造函数的 prototype 等于 实例对象的**proto** 但是 要注意的是 这里的意思是 他俩的引用指向同一个对象 实例对象生成的时候 会把他的**proto** 指向构造函数的 prototype 但是如果我们重新给构造函数的 prototype 赋值 那么之前的实例对象的 proto 和构造函数的 prototype 对象没关系了因为 他们还是原来的指向 但是之后再新建的对象就指向新赋值的对象了

## instance 用法

[https://blog.csdn.net/weixin_40013817/article/details/103182967](https://blog.csdn.net/weixin_40013817/article/details/103182967)

## css 多行溢出隐藏 省略号下面还显示文字踩坑

原因是因为 给容器设置高度了 相设置多行溢出隐藏的话 就不要设置容器高度

## provide/inject 标注类型

https://cn.vuejs.org/guide/typescript/composition-api.html#typing-provide-inject

注意事项 :provide 和 inject 都可以标注类型且互不影响 一个是标传的时候 一个标接收 只要接收标就行 标传的话需要引入一个 symbol 并且使用 inject 要导入这个 symbol 并以他为 key

## wangEditor v-html 样式回显

导入 css 然后设置两个 div 一个 class 是 w-e-text-container 内部的设置 attr 是 data-slate-editor 二者缺一不可 另外导入的 css 不能加 scoped 这是由于 v-html 渲染的 dom 身上是不会有 data-v 标识的 如果我们给 css 导入了 scoped 的话 css 里每个 class 的最后面都会自动加上 data-v 导致不匹配

css 里 如果样式是 .a .b 这种写法 则 data-v 是加在 .b 后的 而不是.a 后的 也难怪 匹配{}是最容易的正则 匹配 第一个 class 要考虑的就多了

而:root :host 这种则加在之前[data-v-xx] :root 也难怪 :root 本身不属于某个元素 但是即便这样 root 也不会生效 root 前后都不应该有 data-v

## :host 作用 Shadow DOM

在 CSS 中，`:host`选择器是一个特殊的选择器，主要用于 Shadow DOM 上下文中，它用于选择当前组件的宿主元素（即定义了 Shadow DOM 的元素）。当在一个组件的 Shadow DOM 内部编写 CSS 时，`:host`允许你针对宿主元素应用样式，而不会影响到页面上的其他同名元素。

`:host`选择器有两种形式：

- `:host()`：这是一个伪类选择器，可以接受一个选择器作为参数，用来更精确地选择宿主元素或宿主元素的特定状态。
- `:host`：没有括号的形式，它默认选择当前的宿主元素。

例如，如果你有一个自定义元素 `<my-element>`，并且在它的 Shadow DOM 中，你想仅当这个元素被激活时改变它的颜色，你可以这样写：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">css</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="08bf49ae-c910-47e6-8f36-00c5ad39d453" tasktype="FREE_INPUT"><code class="language-css"><span class="token pseudo-class">:host</span><span class="token">(</span><span class="token pseudo-class">:hover</span><span class="token">)</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">color</span><span class="token">:</span><span></span><span class="token color">red</span><span class="token">;</span><span>
</span><span></span><span class="token">}</span></code></div></div></pre>

这将只会影响 `<my-element>`元素在鼠标悬停状态下的颜色，而不会影响页面上其他的元素。

需要注意的是，`:host`选择器是 Web Components 和 Shadow DOM 规范的一部分，因此它只能在支持这些特性的现代浏览器中使用。在不支持这些特性的旧浏览器中，可能需要使用 polyfills 或其他方法来达到类似的效果。

Shadow DOM 是一种 Web Components 技术的一部分，它提供了在 Web 页面中创建封装的 DOM 子树的能力。这种子树独立于文档的其余部分，拥有自己的样式和事件处理逻辑，从而避免了样式和脚本之间的潜在冲突，增强了组件的复用性和维护性。

以下是 Shadow DOM 的一些关键特性：

1. **封装** ：Shadow DOM 允许你创建一个私有的 DOM 树，这个树不会受到外部样式的影响，同样也不会影响外部的 DOM。这意味着组件内部的样式和脚本可以在不影响页面其他部分的情况下自由修改。
2. **独立的样式作用域** ：在 Shadow DOM 内部使用的样式不会泄漏到外部 DOM 树，反之亦然。这使得组件的样式能够保持一致，即使页面上有多个相同的组件，它们的样式也不会相互干扰。
3. **组件化** ：Shadow DOM 是构建自定义组件的关键技术之一，它使得 Web Components 可以拥有自己的内部结构、样式和行为，同时仍然能够像普通 HTML 元素一样在页面中使用。
4. **事件传播** ：尽管 Shadow DOM 提供了封装，但它并不会阻止事件从 Shadow DOM 内部向外部传播。事件仍然遵循 DOM 的标准事件传播机制，这确保了组件可以与页面的其他部分交互。
5. **可观察的变化** ：Shadow DOM 提供了 API 来观察其内部 DOM 树的变化，这对于响应式设计和性能优化非常有用。
6. **浏览器支持** ：Shadow DOM 是 W3C 的一个标准，现代浏览器如 Chrome、Firefox、Safari 和 Edge 都支持这一特性。

在实际使用中，创建 Shadow DOM 通常涉及到使用 `attachShadow()`方法在元素上附加一个 Shadow Root。然后，你可以在这个 Shadow Root 中插入 HTML 和 CSS，这些内容将被视为一个独立的 DOM 树。

例如，创建一个简单的自定义元素并添加 Shadow DOM：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="04ab589e-7a26-48a6-bbc5-b2e57d0f76ee" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token">class</span><span></span><span class="token">MyElement</span><span></span><span class="token">extends</span><span></span><span class="token">HTMLElement</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">constructor</span><span class="token">(</span><span class="token">)</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">super</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">const</span><span> shadow </span><span class="token">=</span><span></span><span class="token">this</span><span class="token">.</span><span class="token method property-access">attachShadow</span><span class="token">(</span><span class="token">{</span><span></span><span class="token literal-property">mode</span><span class="token">:</span><span></span><span class="token">'open'</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span><span>
</span><span>    shadow</span><span class="token">.</span><span class="token property-access">innerHTML</span><span></span><span class="token">=</span><span></span><span class="token template-string template-punctuation">`</span><span class="token template-string html language-html">
</span><span class="token template-string html language-html"></span><span class="token template-string html language-html"><</span><span class="token template-string html language-html">style</span><span class="token template-string html language-html">></span><span class="token template-string html language-html plain-text">
</span><span class="token template-string html language-html plain-text">        :host {
</span><span class="token template-string html language-html plain-text">          display: block;
</span><span class="token template-string html language-html plain-text">          color: blue;
</span><span class="token template-string html language-html plain-text">        }
</span><span class="token template-string html language-html plain-text"></span><span class="token template-string html language-html"></</span><span class="token template-string html language-html">style</span><span class="token template-string html language-html">></span><span class="token template-string html language-html">
</span><span class="token template-string html language-html"></span><span class="token template-string html language-html"><</span><span class="token template-string html language-html">p</span><span class="token template-string html language-html">></span><span class="token template-string html language-html plain-text">Hello, World!</span><span class="token template-string html language-html"></</span><span class="token template-string html language-html">p</span><span class="token template-string html language-html">></span><span class="token template-string html language-html">
</span><span class="token template-string html language-html"></span><span class="token template-string template-punctuation">`</span><span class="token">;</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span>
</span>
<span>customElements</span><span class="token">.</span><span class="token method property-access">define</span><span class="token">(</span><span class="token">'my-element'</span><span class="token">,</span><span></span><span class="token maybe-class-name">MyElement</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

这段代码定义了一个名为 `my-element`的自定义元素，它有一个蓝色文本的段落，且这个元素的样式不会影响到页面上的其他元素。

说白了影子 dom 就是 web component 的一种实现方式 他 js 原生支持的组件实现方式

并且影子 dom 无法通过 document.queryselect 等方法找到他 但是可以通过设置影子 root mode: "open" 然后通过 root 去找内部的影子 dom

:host 则是用来父组件中去修改 子影子 dom 中样式穿透的 css 选择器

https://developer.mozilla.org/zh-CN/docs/Web/CSS/:host_function

https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components/Using_shadow_DOM

## nexttick 细节

https://zhuanlan.zhihu.com/p/676106429

## 进阶插件和技巧：使用 Autoprefixer 自动管理浏览器前缀

https://blog.csdn.net/mzgxinhua/article/details/137166311

是 postcss 的插件 tailwind css 安装时会自动安装 postcss 和 Autoprefixer

## prettier 的 bug

prettier 会自动移除;号 这导致如果是写在 template 中事件 内联代买会导致 两行代码中间去掉了分隔符报错 但 js 里不会

## 带浏览器前缀的 css 其他浏览器不支持

比如-webkit-scrollbar 设置 网页滚动条的 火狐就不支持

```css
html {
  scrollbar-color: var(--gradient) #ddd;
  scrollbar-width: thin; /* 或 auto, thin, none */
}
```

火狐支持的写法 且不持支渐变色 第一个颜色滑块颜色 第二个轨道颜色 width 也只能用给的这几个属性 但是这种写法同样谷歌也支持且 优先级高于伪元素那个自定义滚动条样式

## 新版 scss 不支持 一个{}里 先写子类 在写父类样式了 父类要提前

这个警告信息来自于 Sass（Syntactically Awesome Style Sheets），它是一种流行的 CSS 预处理器，用于增强 CSS 的可维护性和灵活性。警告信息指出，在即将到来的 Sass 版本中，嵌套规则（nested rules）与属性声明（declarations）的交互行为将会改变，以更紧密地遵循 CSS 的规范。

在当前的 Sass 版本中，你可以在一个嵌套规则之前或之后放置属性声明，而 Sass 会将这些声明应用到嵌套规则的所有子选择器上。然而，这种行为并不是 CSS 规范所规定的，CSS 规范要求属性声明必须位于任何嵌套规则的内部。

为了更符合 CSS 规范，Sass 计划在未来版本中改变这一行为。在新的行为下，嵌套在另一个规则内的属性声明将仅应用于最直接的父规则，而不会自动应用到所有子规则。

警告信息给出了两种建议来适应这一变化：

1. **保持现有行为** ： 如果你想保持当前的行为，即让属性声明应用于嵌套规则的所有子选择器，你应该将声明移动到嵌套规则的上方，即紧接在嵌套规则之前。

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">scss</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="741eb316-a756-4bbc-ab92-120f81da7b09" tasktype="FREE_INPUT"><code class="language-scss"><span class="token">.parent </span><span class="token">{</span><span>
   </span><span></span><span class="token parent">&</span><span class="token">::before </span><span class="token">{</span><span>
   </span><span></span><span class="token">content</span><span class="token">:</span><span></span><span class="token">""</span><span class="token">;</span><span>
   </span><span></span><span class="token">}</span><span>
   </span><span></span><span class="token">color</span><span class="token">:</span><span></span><span class="token color">red</span><span class="token">;</span><span></span><span class="token">// 移动到此处</span><span>
   </span><span></span><span class="token parent">&</span><span class="token"> > .child </span><span class="token">{</span><span>
   </span><span></span><span class="token">margin-bottom</span><span class="token">:</span><span></span><span class="token">10</span><span class="token unit">px</span><span class="token">;</span><span>
   </span><span></span><span class="token">}</span><span>
   </span><span></span><span class="token">}</span></code></div></div></pre>

1. **采用新行为** ： 如果你愿意采用即将推出的 Sass 新行为，你可以将声明包裹在一个空的嵌套规则中，以明确表示它只应用于直接的父规则。

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">scss</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="741eb316-a756-4bbc-ab92-120f81da7b09" tasktype="FREE_INPUT"><code class="language-scss"><span class="token">.parent </span><span class="token">{</span><span>
   </span><span></span><span class="token parent">&</span><span class="token">::before </span><span class="token">{</span><span>
   </span><span></span><span class="token">content</span><span class="token">:</span><span></span><span class="token">""</span><span class="token">;</span><span>
   </span><span></span><span class="token">}</span><span>
   </span><span></span><span class="token parent">&</span><span class="token"></span><span class="token">{</span><span>
   </span><span></span><span class="token">color</span><span class="token">:</span><span></span><span class="token color">red</span><span class="token">;</span><span></span><span class="token">// 包裹在 & {} 中</span><span>
   </span><span></span><span class="token">}</span><span>
   </span><span></span><span class="token parent">&</span><span class="token"> > .child </span><span class="token">{</span><span>
   </span><span></span><span class="token">margin-bottom</span><span class="token">:</span><span></span><span class="token">10</span><span class="token unit">px</span><span class="token">;</span><span>
   </span><span></span><span class="token">}</span><span>
   </span><span></span><span class="token">}</span></code></div></div></pre>

这个警告信息是为了让你提前准备，了解 Sass 即将做出的改变，并根据你的需求调整代码风格，以避免将来升级 Sass 版本时出现意外的样式问题。

## cloneDeep 后的 reactive 对象返回的对象不是响应式对象 会失去响应式

## input type=file 不能上传重复文件 如果再 change 里给出提示说上传文件不正确 应该清空 input 的 value 或者移除掉那个不需要的 file 后再重新赋值

由于 typefile value 只能重新赋值为空字符串 这就导致没法移除不需要的 file 再重新赋值。

我看了一下 element 的做法 他们是 input 原生每次上传完记录下来 作为 filelist 但是本质上文件每次上传都是覆盖的 也就是说 input 原生每次只会有一个文件或者开始多选情况下的那一次多选文件 后续每次上传都会覆盖他 但是文件会被 el 记录下来作为 raw 属性

## 运算式中有问号运算符 也就是包含三元表达式要加括号 否则结果可能受影响

return sum + a > 0? b:c 这里不会先去判断 a 是否大于 0 再用 b/c 去加 sum 而是去判断 sum+a 是否大于 0 返回 b/c

```typescript
detailData.data.inquiryProductList!.reduce((sum, item) => {
  if (defaultCheck.value.includes(item.id!)) {
    // 这里如果sum+后面 不加括号的话 如果upProductTotalPrice全是0 则只有单选商品有价格 多选永远为0 因为 第一次得出了有值 后续全都走upProductTotalPrice 最终得哥0
    return (
      sum +
      (item.upProductTotalPrice!
        ? item.upProductTotalPrice!
        : item.productTotalPrice!)
    )
  } else {
    return sum + 0
  }
}, 0)
```

## ts 中 大于小于号两侧必须是数值 判断的话 比如 data.a 可能不存在但是我们去判断 data.a === 1? 这种不需要断言 因为 data.a 不存在 那 undefined === 1 不成立也可以走通

大于小于需要 等于全等于不需要

## element 的级联和 select change 事件触发时机 是手动选择的时候 组件 v-model 绑定的值发生变化 不会触发

## getNode el-tree 的内置方法

根据 data 或者 key 拿到 Tree 组件中的 node 这个方法可以只拿一个 id 来获取 node 的信息 应用场景一般是 级联菜单和树数据相同但级联 change 只能拿到 value 拿不到更多数据

不过级联也有内置方法 getCheckedNodes 和 el-tree 一样可以拿到选中节点的 node 数据 也可以用这个

## 三元表达式 template 里渲染图片时，不能直接用字符串如果是本地图片 需要 new Url 或者 import

## img 可以直接使用 border-radius 图片会自动显示圆角 不需要套盒子 overflowhidden

## background css 简写属性写法

https://developer.mozilla.org/zh-CN/docs/Web/CSS/background#position

此属性是一个 [简写属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties)，可以在一次声明中定义一个或多个属性：[`background-clip`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip)、[`background-color`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color)、[`background-image`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image)、[`background-origin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin)、[`background-position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position)、[`background-repeat`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat)、[`background-size`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size)，和 [`background-attachment`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment)。

`background-clip` 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。

border-box 延伸到边框 padding-box 延伸到 padding content-box 只内容部分 text 只文字 默认是 border-box 前提如果不设置 bg-size 的话 默认不设置 position 和 repeat 的话 上 border 和左 border 会有自己的背景图片二者相交处也有自己的背景 而其他部分共用一个背景图 设置 no-repeat 的话 上左 border 没有背景 其他部分有一张背景

https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip

[background-color](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color) 背景色 背景色可与背景图共存

**`background-image`** **`background-image`** 属性用于为一个元素设置一个或者多个背景图像。 可叠加

`background-origin` 规定了指定背景图片[`background-image`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image) 属性的原点位置的背景相对区域。

也就是图片从哪开始显示 默认是 border-box 从边框

**`background-position`** [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性为每一个背景图片设置初始位置。这个位置是相对于由 [`background-origin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin) 定义的位置图层的。

可以是 1 2 3 4 个值

https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position

一个值的话 另外一个值会被设置为 50%

也就说图片居中只有 center 没有 center center 只是 background-position: center center;的时候 只生效了一个 center 罢了 但是放到 background 里写就不生效了 只有一个生效

**`background-repeat`** [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。

`background-size` 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。 百分比不是以元素大小为准 还是以 padding-box 除非手动更改[`background-origin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin)设置 为 border-box

**`background-attachment`** [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性决定背景图像的位置是在[视口]()内固定，或者随着包含它的区块滚动。

fixed 相对饰扣固定 scroll 背景相对于元素本身固定，而不是随着它的内容滚动 [`local`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment#local)此关键属性值表示背景相对于元素的内容固定。

background 简写的话 size 必须紧跟 position 用/分隔才能生效 如 center/100% 100%

origin 决定图片怎么放（从哪里开始）、clip 决定图片的尺寸大小 以及是否要在 border padding 上设置背景图 二者各有各的功能

https://blog.csdn.net/w875471321/article/details/120802835

origin content-box clip 再设置 border-box 图片也就只有 origin 那一块大小

origin 设置 border-box clip 设置 content-box 图片被放大了 但是只有 content-box 那块有背景图 这是设置 size 的情况 不设 size 默认就是 border-box 占满

cover 的话 图片是保持宽高比 尽可能大缩放背景 clip border-box origin 设置 padding-box 被裁掉的部分会展示出来

contain 是让长边能够完整展示 可能会铺不满背景

## ts ！号断言 要比 js?号可选链式操作符 更安全

Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong

这个问题出现在

```typescript
interface A {
  a?: {
    a: number
  }
}
const a: A = {}
console.log(a.a?.a! * 2)
```

给 可选链式操作符 的属性断言是危险的操作 因为会冲突 它自己都有可能是 undefined 怎么又会是肯定有值呢

## vite preview 是预览 build 后的文件

所以需要预览最新的文件 需要先 build 一下 否则看的还是旧的

不过不知道如果不打包直接运行 preview 会怎样

## shallowReactive watch 只能监听到 第一层子元素变动

加 deep 也不好使

reactive 对象默认就是深层监听

## reactive 对象如果属性也是对象 那么 isReactive 属性也是 true

## route 是 proxy 但是 route.query 居然不是 不是就算了 修改 route.query 居然还会触发 watch 不用 deep 的情况下

route query 改变 会触发组件 updated 无论有没有用到 route 变量

## pinia 定义的 store 会在第一次 useStore 的时候初始化 后面每次执行 useStore 都是从仓库里拿了

## VNODE 是虚拟 dom 他是对象

VNodeChild = VNodeChildAtom | VNodeArrayChildren;

VNodeChildAtom = VNode | string | number | boolean | null | undefined | void;

n-table render 需要的是 VNodeChild 因此他可以直接是字符串

h 返回 vnode

## 如果定义 store 的时候 内部引用了某个方法 方法的来源那个模块中导入了 自身这个 store 并使用 会报错说 不能在 store 被初始化前使用它

经过我测试 问题是出在模块化导入上

export 导出的如果是 function 那么无论是模块互相导入还是正常导入都能直接用 但是如果导出的是变量 导入时 如果是正常导入可以用 如果是互相导入 则会导致 最先执行 最根本的那个模块 而最基本的那个模块是无法使用别的模块中导出的变量的 导致报错说 Cannot access 'xxx' before initialization 不过可以使用导出的函数 但函数内部不可以使用模块内的变量 否则也会报错。

不过这里的测试也没有问题 的确是这样 方法可以导入执行 但变量不可以

知道了 模块话一层层导入的时候 每进入到一个模块 会把模块内 var 或者 function 的内容变量提升到最前面 或者说词法环境可以访问的到 这样即便是模块内部 import 导入的其他模块 又导入本模块 导致其他模块先执行 也依然可以使用本模块的方法和变量 只不过变量值是 undefined 因为没执行 还没有赋值 但是如果变量是 const let 定义的则会报错 说不能在定义前使用

后来经过测试发现是 useStore 使用在 app.use(pinia)之前报的错了 至于为什么会报这个错 就是模块化得问题 模块执行顺序 以 最基层模块开始先执行

## 异步函数返回 promise template 不能使用异步函数执行 不然渲染是 promise object

我在想如果使用 异步组件可不可以使用 以后试试

## 如果 template 中需要多次执行函数 那不妨用 computed 替代

## el-radio v-model 绑定的是 label 或者 value 属性 而不是布尔值

change 事件 必须是点击 radio 修改值才会触发 直接修改 v-model 属性不会 如果 el-radio 不写 v-model 则每次点击都会触发 change 事件 这里我猜测是没有 v-model 导致每次组件内部触发了 change 事件 后 又重置为空 导致可以 不停地触发

## console.log %d 保证打印的是整数

const b = 1.99
console.log('count:%d',b)
VM548:1 count:1

## el-select 点击插槽里的内容不算 click out 因此不会关闭 如果点击了插槽中可能出现的 poper 那么会导致 el-select 关闭 因此 poper 不属于 click out 的范畴了

解决方案是 当插槽 poper 弹出时 设置一个变量为 true 当变量存在时 el-select 的关闭事件 el-select 的 visible 为 true 便不会关闭 当插槽 poper 关闭时 变量为 false 这样点击弹出 poper 不会关闭 select 了

## v-model input 这种组件可以双向数据绑定的 自定义指令默认只能去修改 e.target.value 的值 修改不了 v-model 的值

除非 input 事件里修改 或者 自定义指令将 v-model 的值传过去 在指令里赋值。

v-model 本质还是:value=xxx input 的时候自动把 xxx 赋值给 e.target.value 本质上是个语法糖

## router.push 导航到不同 URL，会产生一条新的 history 记录 这是 vue 底层向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL

这里前进后退 和 router.push 功能类似 只是不会产生新的历史记录 并且同个路由页面不会再次执行生命周期，而不同组件的路由会重新执行组件生命周期

当你点击 `<router-link>` 时，内部会调用这个方法，所以点击 `<router-link :to="...">` 相当于调用 `router.push(...)`

路由 push 的时候 增加 replace true 并不会让相同路由发生二次更新 因此如果想根据路由地址变化做搜索或者其他功能的话，只能采用增加其他参数的方案。

router.push 执行时机在下一个宏任务中 而不是 立即执行

## 响应式对象收集依赖 除了 computed 和 watch 外 收集的都是 template 中用到的依赖 而比如路由参数用到了响应式对象 不会因为响应式对象变化 路由自动切换 路由切换只会执行 push 方法切换

## css 单行/多行文本溢出隐藏 /超出隐藏，效果展示...

https://blog.csdn.net/m0_69257679/article/details/128636269

## el-tooltip 使用时报错[ElOnlyChild] no valid child node found

https://huaweicloud.csdn.net/638ef017dacf622b8df8dd2b.html

但是我的报错原因和这个不一样 我是二次封装 tooltip 报错了 把 v-for $slots 换成写死的 slot 就好了

另外插槽使用时不可以先放一个 div 然后在 div 里放 template #xxx 这是因为元素是没有插槽的 但组件的话可以 插槽可以嵌套组件与组件插槽 但是元素没有插槽

## el-tooltip 修改默认样式做法

effect 是主题 这个配置什么字符串后 默认 el-popper 弹出提示会多一个样式 is-effect 配置的那个字符串 然后再去修改全局 css is-xxx 达到修改 el-tooltip 的做法 否则修改的就是默认样式了

## el-select 不会触发 blur 的 rules

## 默认数字和长单词不会换行 即便设置了 word-wrap:break-word; white-space:nowrap;

还要设置 word-break:break-all

错误的 长单词换行 word-wrap 就满足需求了。

word-wrap:break-word; 允许在长单词或 URL 地址内部进行换行

比如 111111111111111111 和 aaaaaaaaaaaaaaaaaaa 这种 默认是不会换行的长单词和数字 但是加上这个就会换行了

white-space 属性指定元素内的空白怎样处理。 默认是长度够了会换行 nowarp 是不换行 pre 和 pre-wrap 都是保留空白和换行符 而不是长度不够才换行 区别是 pre 文字不会自动换行必须要换行符 pre-wrap 则可以自动换行 pre-line 去掉空白 保留换行

word-break break-all 也是单词换行 不过它是尽可能换行 而 word-wrap 是尽可能保留完整单词。

这三个属性可以结合使用 显示优先级是 white-space 最优先 其次 word-break 最后 word-wrap

## gif 和 webp 都是 image 类型的文件 image/gif 与 image/webp

另外 掘金下载的 awebp 文件就是 webp 文件只是改了名字 本地还打不开 改个名立马能用 awebp 应该是 为了防止下载 特意修改的文件后缀

## flex 会让 line-height text-align 以及 float 失效

默认 flex 容器的子元素每一个只占内容大小的宽度

## 自定义指令里，第二个参数 binding 中的那个参数不是响应式的 除非传过来的是响应式对象 传参数的话传过来是字符串

我想给 input 设置一个自定义指令 用于不让用户输入 汉字或者特殊符号 正常可以使用 但是不知道为什么 比如输入 111a 虽然 input 里只有 111 但实际上 v-model 的值是 111a

你遇到的问题是因为 Vue 的 `v-model` 是一种语法糖，它实际上是在内部实现了对 `input` 事件的监听以及对 `value` 属性的双向绑定。当你在 `input` 事件处理程序中修改 `<a>target.value</a>` 时，只是改变了 DOM 中的值，而没有触发 `v-model` 的更新机制。

为了使 `v-model` 的值也得到更新，你需要在事件处理程序中手动触发一个 `input` 事件，以通知 Vue 更新绑定的值。你可以这样做：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">typescript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="0ab81b6d-fb7a-4e0f-a5b2-445eb6e5050e" tasktype="FREE_INPUT"><code class="language-tsx"><span class="token">const</span><span></span><span class="token maybe-class-name">Phone</span><span></span><span class="token">=</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">mounted</span><span class="token">(</span><span>el</span><span class="token">:</span><span></span><span class="token maybe-class-name">HTMLElement</span><span class="token">,</span><span> binding</span><span class="token">:</span><span></span><span class="token">{</span><span> value</span><span class="token">:</span><span></span><span class="token">any</span><span></span><span class="token">}</span><span class="token">)</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">const</span><span> inputElement </span><span class="token">=</span><span> el</span><span class="token">.</span><span class="token method property-access">querySelector</span><span class="token">(</span><span class="token">'input'</span><span class="token">)</span><span class="token">!</span><span class="token">;</span><span>
</span><span>    inputElement</span><span class="token">.</span><span class="token method property-access">addEventListener</span><span class="token">(</span><span class="token">'input'</span><span class="token">,</span><span></span><span class="token">(</span><span>event</span><span class="token">:</span><span></span><span class="token maybe-class-name">Event</span><span class="token">)</span><span></span><span class="token arrow">=></span><span></span><span class="token">{</span><span>
</span><span></span><span class="token">const</span><span> target </span><span class="token">=</span><span> event</span><span class="token">.</span><span class="token property-access">target</span><span></span><span class="token module">as</span><span></span><span class="token maybe-class-name">HTMLInputElement</span><span class="token">;</span><span>
</span><span></span><span class="token">const</span><span> value </span><span class="token">=</span><span> target</span><span class="token">.</span><span class="token property-access">value</span><span class="token">;</span><span>
</span><span></span><span class="token">const</span><span> newValue </span><span class="token">=</span><span> value</span><span class="token">.</span><span class="token method property-access">replace</span><span class="token">(</span><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\D</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span><span class="token">,</span><span></span><span class="token">''</span><span class="token">)</span><span class="token">;</span><span></span><span class="token">// 移除非数字字符</span><span>
</span><span></span><span class="token control-flow">if</span><span></span><span class="token">(</span><span>newValue </span><span class="token">!==</span><span> value</span><span class="token">)</span><span></span><span class="token">{</span><span>
</span><span>        target</span><span class="token">.</span><span class="token property-access">value</span><span></span><span class="token">=</span><span> newValue</span><span class="token">;</span><span></span><span class="token">// 更新 DOM 的值</span><span>
</span><span>        target</span><span class="token">.</span><span class="token method property-access">dispatchEvent</span><span class="token">(</span><span class="token">new</span><span></span><span class="token maybe-class-name">Event</span><span class="token">(</span><span class="token">'input'</span><span class="token">,</span><span></span><span class="token">{</span><span> bubbles</span><span class="token">:</span><span></span><span class="token">true</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span></span><span class="token">// 触发 input 事件</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span class="token">;</span></code></div></div></pre>

这里的改动在于：

1. 使用 `newValue !== value` 来检查是否真的发生了变化，避免不必要的事件触发。
2. 使用 `target.dispatchEvent(new Event('input', { bubbles: true }));` 来手动触发 `input` 事件，这会让 Vue 知道值已经改变，并更新 `v-model` 的值。

这样，当用户输入非数字字符时，这些字符会被过滤掉，并且 `v-model` 的值也会同步更新。

### 完整示例

假设你有一个 Vue 3 的组件，你可以这样使用这个自定义指令：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">vue</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="0ab81b6d-fb7a-4e0f-a5b2-445eb6e5050e" tasktype="FREE_INPUT"><code class="language-html"><span class="token"><</span><span class="token">template</span><span class="token">></span><span>
</span><span></span><span class="token"><</span><span class="token">div</span><span class="token">></span><span>
</span><span></span><span class="token"><</span><span class="token">input</span><span class="token"></span><span class="token">v-phone</span><span class="token"></span><span class="token">v-model</span><span class="token">=</span><span class="token">"</span><span class="token">phoneNumber</span><span class="token">"</span><span class="token"></span><span class="token">placeholder</span><span class="token">=</span><span class="token">"</span><span class="token">Enter phone number</span><span class="token">"</span><span class="token"></span><span class="token">/></span><span>
</span><span></span><span class="token"><</span><span class="token">p</span><span class="token">></span><span>Phone Number: {{ phoneNumber }}</span><span class="token"></</span><span class="token">p</span><span class="token">></span><span>
</span><span></span><span class="token"></</span><span class="token">div</span><span class="token">></span><span>
</span><span></span><span class="token"></</span><span class="token">template</span><span class="token">></span><span>
</span>
<span></span><span class="token"><</span><span class="token">script</span><span class="token"></span><span class="token">lang</span><span class="token">=</span><span class="token">"</span><span class="token">ts</span><span class="token">"</span><span class="token">></span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript module">import</span><span class="token script language-javascript"></span><span class="token script language-javascript imports">{</span><span class="token script language-javascript imports"></span><span class="token script language-javascript imports maybe-class-name">Directive</span><span class="token script language-javascript imports"></span><span class="token script language-javascript imports">}</span><span class="token script language-javascript"></span><span class="token script language-javascript module">from</span><span class="token script language-javascript"></span><span class="token script language-javascript">'vue'</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">const</span><span class="token script language-javascript"></span><span class="token script language-javascript literal-property">Phone</span><span class="token script language-javascript">:</span><span class="token script language-javascript"></span><span class="token script language-javascript maybe-class-name">Directive</span><span class="token script language-javascript"></span><span class="token script language-javascript">=</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">mounted</span><span class="token script language-javascript">(</span><span class="token script language-javascript parameter literal-property">el</span><span class="token script language-javascript parameter">:</span><span class="token script language-javascript parameter"></span><span class="token script language-javascript parameter maybe-class-name">HTMLElement</span><span class="token script language-javascript parameter">,</span><span class="token script language-javascript parameter"></span><span class="token script language-javascript parameter literal-property">binding</span><span class="token script language-javascript parameter">:</span><span class="token script language-javascript parameter"></span><span class="token script language-javascript parameter">{</span><span class="token script language-javascript parameter"></span><span class="token script language-javascript parameter literal-property">value</span><span class="token script language-javascript parameter">:</span><span class="token script language-javascript parameter"> any </span><span class="token script language-javascript parameter">}</span><span class="token script language-javascript">)</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">const</span><span class="token script language-javascript"> inputElement </span><span class="token script language-javascript">=</span><span class="token script language-javascript"> el</span><span class="token script language-javascript">.</span><span class="token script language-javascript method property-access">querySelector</span><span class="token script language-javascript">(</span><span class="token script language-javascript">'input'</span><span class="token script language-javascript">)</span><span class="token script language-javascript">!</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript">    inputElement</span><span class="token script language-javascript">.</span><span class="token script language-javascript method property-access">addEventListener</span><span class="token script language-javascript">(</span><span class="token script language-javascript">'input'</span><span class="token script language-javascript">,</span><span class="token script language-javascript"></span><span class="token script language-javascript">(</span><span class="token script language-javascript parameter literal-property">event</span><span class="token script language-javascript parameter">:</span><span class="token script language-javascript parameter"></span><span class="token script language-javascript parameter maybe-class-name">Event</span><span class="token script language-javascript">)</span><span class="token script language-javascript"></span><span class="token script language-javascript arrow">=></span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">const</span><span class="token script language-javascript"> target </span><span class="token script language-javascript">=</span><span class="token script language-javascript"> event</span><span class="token script language-javascript">.</span><span class="token script language-javascript property-access">target</span><span class="token script language-javascript"></span><span class="token script language-javascript module">as</span><span class="token script language-javascript"></span><span class="token script language-javascript maybe-class-name">HTMLInputElement</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">const</span><span class="token script language-javascript"> value </span><span class="token script language-javascript">=</span><span class="token script language-javascript"> target</span><span class="token script language-javascript">.</span><span class="token script language-javascript property-access">value</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">const</span><span class="token script language-javascript"> newValue </span><span class="token script language-javascript">=</span><span class="token script language-javascript"> value</span><span class="token script language-javascript">.</span><span class="token script language-javascript method property-access">replace</span><span class="token script language-javascript">(</span><span class="token script language-javascript regex-delimiter">/</span><span class="token script language-javascript regex-source language-regex">\D</span><span class="token script language-javascript regex-delimiter">/</span><span class="token script language-javascript regex-flags">g</span><span class="token script language-javascript">,</span><span class="token script language-javascript"></span><span class="token script language-javascript">''</span><span class="token script language-javascript">)</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript control-flow">if</span><span class="token script language-javascript"></span><span class="token script language-javascript">(</span><span class="token script language-javascript">newValue </span><span class="token script language-javascript">!==</span><span class="token script language-javascript"> value</span><span class="token script language-javascript">)</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript">        target</span><span class="token script language-javascript">.</span><span class="token script language-javascript property-access">value</span><span class="token script language-javascript"></span><span class="token script language-javascript">=</span><span class="token script language-javascript"> newValue</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript">        target</span><span class="token script language-javascript">.</span><span class="token script language-javascript method property-access">dispatchEvent</span><span class="token script language-javascript">(</span><span class="token script language-javascript">new</span><span class="token script language-javascript"></span><span class="token script language-javascript">Event</span><span class="token script language-javascript">(</span><span class="token script language-javascript">'input'</span><span class="token script language-javascript">,</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript"></span><span class="token script language-javascript literal-property">bubbles</span><span class="token script language-javascript">:</span><span class="token script language-javascript"></span><span class="token script language-javascript">true</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">)</span><span class="token script language-javascript">)</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">)</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">,</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript module">export</span><span class="token script language-javascript"></span><span class="token script language-javascript module">default</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript literal-property">directives</span><span class="token script language-javascript">:</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript"></span><span class="token script language-javascript literal-property">phone</span><span class="token script language-javascript">:</span><span class="token script language-javascript"></span><span class="token script language-javascript maybe-class-name">Phone</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">,</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">data</span><span class="token script language-javascript">(</span><span class="token script language-javascript">)</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript control-flow">return</span><span class="token script language-javascript"></span><span class="token script language-javascript">{</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript literal-property">phoneNumber</span><span class="token script language-javascript">:</span><span class="token script language-javascript"></span><span class="token script language-javascript">''</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">,</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token script language-javascript">}</span><span class="token script language-javascript">;</span><span class="token script language-javascript">
</span><span class="token script language-javascript"></span><span class="token"></</span><span class="token">script</span><span class="token">></span></code></div></div></pre>

这样设置之后，无论你在输入框中输入什么非数字字符，`v-model` 的值都会被正确地更新为只包含数字的字符串。

## forin 在 key 后断言会报错

```ts
for (const key in uploadObj.data) {

    constobj = uploadObj.data

    if (Object.prototype.hasOwnProperty.call(obj, key)) {

    obj[keyas keyof UploadObj["data"]] = []

    }

    }
```

如果断言 在 const key 后断言会报错 要在使用时断言不会报错

## 正则匹配汉字

[\u4e00-\u9fa5] 这是匹配汉字的 必须加中括号

[^\u4e00-\u9fa5] 这是匹配非汉字的 因为取反需要中括号 但是这里本来就有中括号 就可以省略了

test 是检测 字符串是否符合正则表达式 有一部分符合就 true 而不是全部 如果想匹配全部的话 得用取反后得正则 比如想要输入得字全是中文 那就用全部不是中文得正则去匹配 只要匹配到就证明不符合要求

## el-upload 上传遇到得问题

uploadFiles.pop() 只可以删除直接上传回显得图片 如果是再 change 回调里通过 push 添加的图 不可以通过 uploadFiles.pop()删除 需要手动 找到 v-model 得 filelist 去 pop 但是点击删除按钮的确可以直接 v-model 的删除 ui 和界面都删 handleRemove 是数据删除后的回调

## naiveui 的水印 需要手动设置 pointer-events:none; 否则水印上的字 回遮盖 后面元素的事件 文字外的部分不会

## window.scroll()、window.scrollTo()、window.scrollBy()

window.scroll(X,Y)：X 代表着 X 轴滚动多少 px，Y 代表着 Y 轴滚动多少，px 假如是 Y 方向滚动 100px，window.scroll(0,100)。这个 window.scrollTo()方法和 window.scroll()方法一样的。
window.scrollBy(X,Y)方法,这个 scrollBy()方法和上面的这两个方法的不同之处在于会累加，例如 window.scrollBy(0,100)，下次继续调用 window.scrollBy(0,100)会累加起来，位置移动到 200 的地方

滚动带过度

```js
window.scrollTo({
  top: 0,
  behavior: "smooth"
})
```

## 级联或 select 这种组件 rules 只有 change 没有 blur blur 的不会触发

## 自定义事件 父传子 修改父中的某个属性 子立刻就能获取到最新的这个属性吗

## watch 是异步的 也就是微任务

路由 route 不需要 deep

## 路由 watch 是从大路由往小路由 watch 的 先触发父 watchroute 然后子

## 项目中 .js 文件中 使用计时器最好加上 window.xxx 这样会认为是浏览器环境 返回 number 类型的计时器 如果不加 window 会认为是 node 环境返回 node 的类型 浏览器没法用

## dialog 的 close 事件和 closed 事件 只要 v-model 的值变成 false 就会触发 而点击关闭图标 会直接把那个值变成 false

## array.push 返回值是 数组的新长度 array.push 中元素如果用到了 array.length 这个 length 是旧的

## new Date 的 Date 对象 是可以直接比较大小的 本质还是 js 自动转成 number

## 枚举中如果值是字符串的情况下 无法直接赋值字符串 数值可以

https://www.jb51.net/javascript/30299895t.htm

并且 枚举类型最终编译完是可以使用的 编译完本身就是一个函数

在 TypeScript 中，当你使用 `enum` 来定义枚举类型时，它会在编译成 JavaScript 之后以不同的形式存在。具体来说，当你使用 `const enum` 定义枚举时，TypeScript 编译器会完全移除枚举的定义，只保留其成员的赋值。这意味着在编译后的 JavaScript 代码中不会有任何与该枚举相关的代码。

### TypeScript 枚举的两种形式

- **常规枚举 (`enum`)** ：编译后会生成一个 JavaScript 对象，其中包含枚举成员及其对应的值。
- **常量枚举 (`const enum`)** ：编译后不会生成任何 JavaScript 代码，仅用于类型检查。

### 示例

假设你有以下 TypeScript 代码：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">typescript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="2d40a0cb-11e6-46b3-a27a-e35726e832e9" tasktype="FREE_INPUT"><code class="language-tsx"><span class="token">enum</span><span></span><span class="token maybe-class-name">ButtonType</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token module">default</span><span></span><span class="token">=</span><span></span><span class="token">"default"</span><span class="token">,</span><span>
</span><span>  primary </span><span class="token">=</span><span></span><span class="token">"primary"</span><span class="token">,</span><span>
</span><span>  cancel </span><span class="token">=</span><span></span><span class="token">"cancel"</span><span class="token">,</span><span>
</span><span>  success </span><span class="token">=</span><span></span><span class="token">"success"</span><span class="token">,</span><span>
</span><span>  danger </span><span class="token">=</span><span></span><span class="token">"danger"</span><span class="token">,</span><span>
</span><span>  minor </span><span class="token">=</span><span></span><span class="token">"minor"</span><span>
</span><span></span><span class="token">}</span><span>
</span>
<span></span><span class="token">const</span><span> a</span><span class="token">:</span><span></span><span class="token maybe-class-name">ButtonType</span><span></span><span class="token">|</span><span></span><span class="token nil">undefined</span><span></span><span class="token">=</span><span></span><span class="token">'cancel'</span><span class="token">;</span><span>
</span><span></span><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span>a</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

编译后，你会得到类似的 JavaScript 代码：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="2d40a0cb-11e6-46b3-a27a-e35726e832e9" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token">const</span><span> a </span><span class="token">=</span><span></span><span class="token">'cancel'</span><span class="token">;</span><span>
</span><span></span><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span>a</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

而如果你使用 `const enum`：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">typescript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="2d40a0cb-11e6-46b3-a27a-e35726e832e9" tasktype="FREE_INPUT"><code class="language-tsx"><span class="token">const</span><span></span><span class="token">enum</span><span></span><span class="token maybe-class-name">ButtonType</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token module">default</span><span></span><span class="token">=</span><span></span><span class="token">"default"</span><span class="token">,</span><span>
</span><span>  primary </span><span class="token">=</span><span></span><span class="token">"primary"</span><span class="token">,</span><span>
</span><span>  cancel </span><span class="token">=</span><span></span><span class="token">"cancel"</span><span class="token">,</span><span>
</span><span>  success </span><span class="token">=</span><span></span><span class="token">"success"</span><span class="token">,</span><span>
</span><span>  danger </span><span class="token">=</span><span></span><span class="token">"danger"</span><span class="token">,</span><span>
</span><span>  minor </span><span class="token">=</span><span></span><span class="token">"minor"</span><span>
</span><span></span><span class="token">}</span><span>
</span>
<span></span><span class="token">const</span><span> a</span><span class="token">:</span><span></span><span class="token maybe-class-name">ButtonType</span><span></span><span class="token">|</span><span></span><span class="token nil">undefined</span><span></span><span class="token">=</span><span></span><span class="token">'cancel'</span><span class="token">;</span><span>
</span><span></span><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span>a</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

编译后的 JavaScript 代码也会类似地删除枚举定义：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="2d40a0cb-11e6-46b3-a27a-e35726e832e9" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token">const</span><span> a </span><span class="token">=</span><span></span><span class="token">'cancel'</span><span class="token">;</span><span>
</span><span></span><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span>a</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

### 总结

- 如果你需要在运行时访问枚举成员，应该使用普通的 `enum`。
- 如果你只需要在编译时进行类型检查，可以使用 `const enum`，这样可以减少生成的 JavaScript 代码的大小。

希望这解答了你的疑问！如果有更多问题或需要进一步的帮助，请随时告诉我。

常量枚举无法 由枚举值返回枚举 key

https://zhuanlan.zhihu.com/p/663501430

## 无论是 router.push 还是 router.replace 地址相同都不会重新触发组件生命周期

## 计算属性 对于响应式对象 是懒侦听的 假如计算属性使用到了某个响应式对象的 a 属性 b 属性发生更改 不会重新计算

这是 get 的功劳 计算属性会 get 收集真正用到的那个属性作为依赖

## ts 中回去数组某个元素类型除了可以用['0']还可以用[number]

## if else 分支里面 如果用到了同一个变量 ts 断言只需要断言最开始的一次就可以

## 插槽的问题报错 Non-function value encountered for default slot. Prefer function slots for better performance.

原因 使用 h 函数渲染组件时 插槽要使用函数形式

## Failed to resolve directive: create at <IndexVue onVnodeUnmounted=fn `<onVnodeUnmounted>` ref=Ref< undefined > >

这种报错一般是通过 v-xxx 使用自定义指令 而指令不存在

## el-form 表单校验后 如果通过手动赋值后触发表单再次校验 input 的 rules 要设置 change 并且 input 要 v-model 绑定值

el-upload 和 date-picker 需要手动触发校验 赋值后

## el 级联选择器 props 禁用选项 除了是布尔值也可以是其它可以表示 true 和 false 的值 比如 0 表示 false 1 表示 true 没必要转换成 boolean 类型

幸亏 项目里 0 表示启用 1 表示禁用 完美贴合禁用情况下不可选 这里 01 都是数字

## 运算符 逻辑与优先级大于逻辑或

<pre><div class="answer-code-wrap"><div node="[object Object]" class="answer-code-wrap-body" requestid="715b9a87-e96c-4583-994b-8ce928f9e682" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span class="token">true</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span></span><span class="token">&&</span><span></span><span class="token">false</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">// 输出: true</span></code></div></div></pre>

在这个例子中，`true && false` 会被先计算，结果是 `false`。然后 `true || false` 被计算，结果是 `true`。

### 示例 2: 使用括号改变优先级

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-content"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="715b9a87-e96c-4583-994b-8ce928f9e682" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span class="token">(</span><span class="token">true</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span class="token">)</span><span></span><span class="token">&&</span><span></span><span class="token">false</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">// 输出: false</span></code></div></div></pre>

在这个例子中，括号改变了运算的顺序，首先计算括号内的 `true || true` 得到 `true`，然后 `true && false` 结果是 `false`。

### 示例 3: 复杂表达式

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-content"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="715b9a87-e96c-4583-994b-8ce928f9e682" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span class="token">false</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span></span><span class="token">&&</span><span></span><span class="token">false</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">// 输出: true</span></code></div></div></pre>

在这个例子中，`true && false` 先计算得到 `false`，所以表达式变为 `false || false || true`。接下来，从左向右计算 `false || false` 得到 `false`，最后 `false || true` 得到 `true`。

### 示例 4: 混合使用

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-content"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="715b9a87-e96c-4583-994b-8ce928f9e682" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token console">console</span><span class="token">.</span><span class="token method property-access">log</span><span class="token">(</span><span class="token">(</span><span class="token">false</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span class="token">)</span><span></span><span class="token">&&</span><span></span><span class="token">(</span><span class="token">false</span><span></span><span class="token">||</span><span></span><span class="token">true</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span><span></span><span class="token">// 输出: true</span></code></div></div></pre>

在这个例子中，两个括号内的表达式分别计算得到 `true`，所以整个表达式变为 `true && true`，最终结果是 `true`。

总结一下，如果你希望改变默认的优先级，可以使用括号来明确地指定计算顺序。这有助于提高代码的可读性和减少潜在的错误。

## el-tooltip 插槽内容的执行时机是 当 tooltip 要显示的时候 而不是 render 函数 vnode 创建的时候

这或许就是为什么插槽是函数的原因吧 只有该使用的时候才调用它

但如果是自定义属性使用 content 的话 会在 render 函数执行时 使用

但 tooltip 的确是用 v-if 渲染的

## elementplus 中 v-loading 和 v-if 一起用会存在问题 用在同一组件身上可能会有问题 因为 v-loading 必须要有 dom

## el-table 合并表格后 鼠标经过 tr 可以所有合并的 tr 背景色一致的做法

我本来以为会是很难的。没想到最终实现起来却非常简单

做法是首先通过 el-table 的自定义 tr 名 为每行 tr 绑定一个属于自己的与数据匹配的 classname 可以是 id 可以是 no 要唯一不重复

然后使用 table 的鼠标 enter 事件 通过全选 data 中为 id 或者 no 的对应 classname 的 tr 背景颜色修改为想要的颜色 leave 时再重置为 fff 这里一定要 fff 如果设置透明色会出现 table 固定列 透明和底下的 cell 数据重叠了

## js toFixed 四舍五入采用的银行家算法 不符合中国人四舍五入的习惯。

它既不是四舍五入，也不是[银行家算法](https://zhida.zhihu.com/search?q=%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)四舍六入。 实际开发中建议用 `lodash` 的 `_.round()`。

https://zhuanlan.zhihu.com/p/712757869

toFixed 不是严格意义上的四舍五入

`_.round()` lodash 对于负数也是 .5 取正无穷大方向上的数

## commonjs 与 esm

https://segmentfault.com/a/1190000041396029

commonjs 循环加载时从缓存里找值 没有缓存的则进入执行。

esm 循环加载的找到最底层的那个模块开始执行 也就是依赖关系最底层的那个模块 也可以说是最后一个被缓存的模块开始执行。

## 浏览器记住验证码和密码，而非用户名和密码

https://blog.csdn.net/lyn1772671980/article/details/122196120

## flex 布局 使用 overflow-y scroll 注意事项

使用 flex-**direction**: **column**; 的情况下就不要用 justify-content: **center**;

这是因为 超出的部分滚动显示 但实际超出的部分 是放在最后的 而显示的内容是放在滚动条一开始的 但如果使用了 justify-content: **center**; 那么侧轴居中 会导致滚动的整体内容跑到容器中间去 这就导致 前面的内容会溢出容器不显示 而后面滚动的不受影响 滚动条可滚动距离变短

## 记录 vue 里一次离谱的 bug

```javascript
            obj.other.forEach((item) => {
              item.count = obj.count!
              item.sku = item.skus[0].id
            })
```

item.skus[0] 可能为 undefined 但是 浏览器居然没有报错 离谱 而是直接跳出了后续的执行了

## el-tree 的问题 查看 test5

## setup 中不用 ref 获取 实例的方 s 式 使用 proxy 实例$refs 来获取可以

## dayjs 内置方法

.day(number) 返回本周（0 是上周日）开始第几天 number=1 是周一

startOf(string) week month year 返回开始日期 本周本月本年 week 从周日开始

add 增加一定时间 参数 number + 单位

subtract 减去 同上

diff 返回指定单位下两个日期时间之间的差异 默认情况下 `dayjs#diff` 会将结果进位成整数。 也就是舍去小数

```javascript
dayjs().diff(dayjs(1718258944185), "day")
```

## router-view 使用 keep-alive

<router-viewv-slot="{ Component, route }">

    <keep-alive :include="tagsViewStore.cachedViews"exclude="Index">

    <componentv-if="!route.meta.link" :is="Component" :key="route.path" />

    `</keep-alive>`

    `</router-view>`

## vue3 生产环境报错 Cannot read properties of null (reading 'insertBefore')

开发环境没问题，打包部署到生产环境有问题

目前网上找到的几种解决方案 1 v-if 用 v-show 替换 2 如果是 el-dialog 报错 则使用时加上 destroy-on-close 3 插槽属性使用?.可选链式操作符读取属性

https://blog.csdn.net/weixin_46856618/article/details/132673960

https://blog.csdn.net/m0_75107188/article/details/132045297

https://zhuanlan.zhihu.com/p/590277507

https://juejin.cn/post/7203701875531268157

https://blog.csdn.net/hln136285/article/details/138674300

## 导航守卫 next 使用注意事项

导航守卫里要求 每个环节 或者条件分支里 都要执行 next 否则会报错 并且是同步的 因此如果遇到需要接口处理的 要使用 await 转同步

## rgba 的另外一种书写的方式

rgba($color:black, $alpha:0.25)

## 正则表达式匹配任意字符

[\s\S]\*

- `[\s]` 表示，只要出现空白就匹配
- `[\S]` 表示，非空白就匹配

  那么它们的组合，表示所有的都匹配，与它相对应的，有 `[\w\W]` 等，意义完全相同

`\s` 是指空白，包括空格、换行、Tab 缩进等所有的空白

\w 表示匹配所有数字与字母不分大小写 下划线\_

\W 匹配所有出数字与字母\_外的字符

[\\w\\W] 则匹配全部的字符

.匹配除换行符 外所有的字符

https://baijiahao.baidu.com/s?id=1707305887806908453&wfr=spider&for=pc

https://www.jb51.net/article/19713.htm

正则表达式元字符是指在正则表达式中具有特殊意义的专用字符，它们可以用来规定其前导字符在目标对象中的出现模式

https://www.runoob.com/regexp/regexp-metachar.html

https://baike.baidu.com/item/%E5%85%83%E5%AD%97%E7%AC%A6/6062776?fr=ge_ala

## css 画三角形

https://hellobug.github.io/blog/css-triangle-with-shadow/

https://blog.csdn.net/m0_67841039/article/details/130605105

drop-shadow 只设置三边怎么设置

## 带滚动条的定位，子绝父相 子元素 定位参照的是父元素设置的宽与高的边 而不是滚动的

如果想实现 固定的话 要使用粘性定位 类似于 fixed 定位 粘性定位以 content 为准 不以 border 为准

https://www.jianshu.com/p/f97e4ec1fe91?nomobile=yes

## el-form 的 model 属性设置的是 form 的表单数据对象

aiEditor 基于 tiptap

配置自定义上传时 uploader 配置自定义上传 返回的是 response onUploadBefore 配置上传文件前回调 onSuccess 上传成功时回调 也就是 response 返回成功而不是错误时 接受参数两个 文件 file 和上面的 response 这里 response 要按照固定格式 图片才会回显 由于不是自动上传 因此无法兼听 网络超时等服务器错误 只有前三个回调可以用 如果在自定义上传里 return false 会走 onFailed 回调

```javascript
aiEditor = new AiEditor({
  element: editor.value,
  placeholder: "点击输入内容...",
  content: form.data.answerText || "",
  toolbarKeys: [
    "undo",
    "redo",
    "brush",
    "eraser",
    "|",
    "heading",
    "font-family",
    "font-size",
    "|",
    "bold",
    "italic",
    "underline",
    "strike",
    "link",
    "code",
    "subscript",
    "superscript",
    "hr",
    "todo",
    "emoji",
    "|",
    "highlight",
    "font-color",
    "|",
    "align",
    "line-height",
    "|",
    "bullet-list",
    "ordered-list",
    "indent-decrease",
    "indent-increase",
    "break",
    "|",
    "image",
    "video",
    "attachment",
    "quote",
    "code-block",
    "table",
    "|",
    "source-code",
    "printer",
    "fullscreen"
  ],
  contentRetention: true,
  image: {
    uploader: async (file, uploadUrl, headers, formName) => {
      console.log(file)
      //可自定义图片上传逻辑
      return await ossUpload("/file/banner", file.name, file)
    },
    uploaderEvent: {
      onUploadBefore: (file, uploadUrl, headers) => {
        //监听图片上传之前，此方法可以不用回任何内容，但若返回 false，则终止上传
        if (file.size > 1024 * 1024 * 5) {
          ElMessage.error("图片大小不能超过5M")
          return false
        }
      },
      onSuccess: (file, response) => {
        return {
          errorCode: 0,
          data: {
            src: response,
            alt: file.name
          }
        }
      },
      // 本质上这里onFailled和onError的执行是在自定义上传函数后catch里执行的 success执行是在then里
      onFailed: (file, response) => {
        // 自定义上传时未返回url地址 或者返回格式不正确走这个
        //监听图片上传失败，或者返回的 json 信息不正确
      },
      onError: (file, error) => {
        // 自定义上传throw Error 或者 Promise.reject 时走这个
        //监听图片上传错误，比如网络超时等
      }
    }
  },
  onChange: (content) => {
    form.data.answerText = content.getHtml()
  }
})
```

## .prevent 修饰符 和自己写 e.preventDefault 有区别吗

## window.open（文件 url） 可下载内容 但会新打开页面在关闭

直接 js 创建 a a.click 不会

## 绝对定位没有宽度将影响文字溢出省略号

## el-table 宽度不够 el-button 里面的 button 后面可能会出现黑点

## a 链接 download 控制 文件名 默认只有同源下生效 跨域不生效 解决办法是

使用 http 下载文件 也就是 get 要注意的是 axios 要把 responseType 设置成 blob ~~然后 res 中 new Blob 获得一个 blob 文件~~ 使用 responseType blob 后 res 直接就是 blob 了无需再转换了 然后使用 URL.createObjectURL 将 blo 转为本地 url 地址再创建 a 链接 修改 download 下载文件 最后使用 window.URL.revokeObjectURL(url) 移除 url

# 函数作用域按理说创建的 url 结束就该回了 但是 mdn 里只说关闭浏览器回收 chatgpt 也这么说 保险起见 还是手动释放吧

## 下载文件时候 设置文件格式的两种办法

1 是 new blob 的时候指定 type 2 是设置 upload 的时候手动拼接后缀名

文件下载传输好像 axios 就支持两种 blob 和 stream 流 这两种序列化

## slot 默认内容的展示时机

## el-table 的默认 tooltip 展示

tooltip 展示狠智能 必须是 table 一行显示不全的时候 并且只展示 table 每一行中的文字 图片 组件之类的不会

## VUE 前端本地代理出现 Whitelabel Error Page

proxy 代理与路由地址重复 https://blog.csdn.net/qq_53689264/article/details/133861743

## template background 能否用 reslove 配置的路径

## offsettop

## 阻止 enter input 换行要在 keydown 时而不是 keyup

## Cannot read properties of null (reading 'shapeFlag') vue 报错

一般是没有定义变量,但是 template 里通过变量.xx 访问其属性了

但不定义的变量直接使用不会报错 只会报警告

或者函数作用域内使用了一个不存在的变量

## v-slot 替换 slot 与 slot-scope

https://www.cnblogs.com/zjjDaily/p/10518546.html

## 请求拦截器第一个函数也是异步的 执行时机是在微任务里

## [js 浏览器窗口 刷新、关闭事件](https://www.cnblogs.com/phermis/p/13373335.html "发布于 2020-07-24 17:51")

检测浏览器关闭与刷新的事件 包含彻底关闭浏览器

## d.ts 与 ts 区别

## TS 文件|declare 及 namespace 关键字声明区别，及 export 异同

https://blog.csdn.net/junhuahouse/article/details/131954613

## 动态组件是异步吗

## 一些公共的 api 比如阿里云高德这种 使用咱们自己封装的 http 请求 不要带上本地 token 否则会出现跨域等问题

## watch 监听对象属性的时候 old 和 new 是同样的值 这是因为打印的时候指向是一样的 记录的是指向 old 和 new 记录的是引用

## 高德 api 初始化渲染地图不生效踩坑解决方法

onmounted 中再加个计时器 或者 nexttick

## address ship 的 onUpdate 为什么没有执行 我明明修改了 address 的数据

## 富文本编辑器

https://zhuanlan.zhihu.com/p/460528428

https://juejin.cn/post/7201883287937990712?searchId=202409122238112BCCC911F490823D9570

TinyMCE 新的

http://tinymce.ax-z.cn/ https://www.tiny.cloud/

CKEditor 5 新的

https://ckeditor.com/ckeditor-5/demo/feature-rich/

quill 老的

https://quilljs.com/

Froala 新的

https://froala.com/wysiwyg-editor/

**summernote 老的 猜测是 jquery+bootstrap**

https://summernote.org/ https://www.fastadmin.net/store/summernote.html

老的

**Trumbowyg**

jquery 的 官网都找不到 https://www.jq22.com/(A(caqiry))/plugin/515

UEditor

百度的就是很老的那个编辑器

Kindeditor 老编辑器跟百度差不多

simditor 老编辑器 jquery

https://simditor.tower.im/

suneditor js+bootstrap

http://suneditor.com/sample/index.html

slate react 界面简单干净 可以定制化开发

https://www.slatejs.org/examples/richtext

draftjs react 英文文档 果断放弃

https://draftjs.org/docs/getting-started

lexical react 也不错

https://playground.lexical.dev/

editor.js 块编辑器 非常干净好看 输出 json 格式 与普通的 html 格式不同 跨平台性好

https://editorjs.io/

prosemirror 不好看

https://prosemirror.net/

vditor markdown 编辑器 很酷

milkdown markdown 编辑器 布局和上面的 editor.js 很像

https://milkdown.dev/playground

tiptap 基于 prosemirror 好看 无头 屋头编辑器就是没有 ui 的编辑器？ 那这里面有好几个

https://cloud.tencent.com/developer/article/2355422

https://juejin.cn/post/7341690415744958505

https://templates.tiptap.dev/BmrwhHfhzK

XNote 无头 https://textbus.io/playground/

几个新的都很漂亮，老的 ui 比较丑技术也比较老 jquery+bootstrap

更多

https://zhuanlan.zhihu.com/p/641539504

## 若依菜单 svgicon 图标颜色是跟随字体颜色的

因此我们 icon 最好用纯色 单色的 否则 svg 内部颜色会覆盖跟随的颜色

## dialog 之类的功能最好在接口获取详情后在展示 dialog 这样 ialog 中的组件拿到的值就是最新的值了 无需 watch

## updated 生命周期与 watch 的执行关系 watch 内修改两次 updated 执行几次呢

watch 执行两次连续 updated 好像才执行一次

## el-descriptions 里 default 插槽里必须是 el-descriptions-item el-descriptions-item 里才可以放真实内容

## 在使用 el-button 的时候我发现有这么一个 css

```css
.el-button + .el-button {
  margin-left: 12px;
}
```

这样 如果同时使用多个 el-button 那么会自动给后面的 button 设置边距 保持距离 学到了

```
.dict-tag:not(:first-child) {
    margin-left: 6px;
  }
// 这样也可以
```

https://blog.csdn.net/weixin_42881768/article/details/138277507

## 与远程仓库建立连接时报错

> fatal: Could not read from remote repository.
>
> Please make sure you have the correct access rights
>
> and the repository exists.

通常是由于 SSH 不正确 本地与线上不同 需要重新生成本地 重新生成时用户名和邮箱填的对不对应该不影响 最后的秘钥 生成的秘钥加入到 git 应用的 ssh 秘钥中即可

https://docs.atomgit.com/user/sshkey/

https://blog.csdn.net/weixin_69773376/article/details/135673638

## Web Component

https://www.cnblogs.com/onecainiao/p/18356198

## 读取本地文件 js 的确需要 fetch 或者 ajax 因为本质上读取本地文件 就是在请求文件

## .d.ts 和.ts 的区别

https://www.soinside.com/question/hVXhhexW8gHRAGYgZgwobi

一些注意事项：

- 有 import 或者 export 的文件不会自动识别到全局 (https://www.5axxw.com/questions/content/1nrxa6)
- declare global 中可以声明全局变量以及拓展 storage 和 window 需要拓展的就 interface 声明 需要定义的 const 声明 用 interface 不管乎
- declaremodule 可以拓展模块
- declare namespace 的类型.ts 中不能 import 否则会导致 namespace 失效 同理还有 interface（https://www.cnblogs.com/sefaultment/p/10244685.html）
- 不 export 也不 import 的 interface 是全局的 type 也一样 这意味着使用时无需 import export 导入导出 而是直接变量：类型 就可以使用他们 namespace 也一样 （https://blog.csdn.net/qq_37766810/article/details/134802641，https://juejin.cn/post/7322024308162953251）
- 没有 import 和 export 的.ts 中 interface namespace type module 等加不加 declare 都无所谓 全局可用 但 declare 有自己的使用场景 （https://juejin.cn/post/7359764922727219251） 不过 declare 实现全局函数定义的 再 vue 项目里实现了 ts 文件里没有会报错 可能版本不同？
- d.ts 最终不会编译成 js 因此其中不要订阅 enum 和 class
- reference types 中不可用 import 否则会导致 不起作用 （https://blog.csdn.net/MinfCONS/article/details/129586839，https://cn.vitejs.dev/guide/env-and-mode#intellisense）
- 如果必须使用 import 导入外部类型 可通过类型:import('类型文件').类型 不会影响全局类型
- namespace 里也可写具体的实现 比如变量 比如函数 好多类型也可直接定义为变量值 （.ts）
- declare 的 namespace 和 class 中不允许有具体实现 因此 declare 适合在 d.ts 中用
- namespace 可以通过 namespace.xx 读取值或者类型 但 interface 不行 另外 interface 定义时可以定义值 但无法使用 因为他是类型 （vue 项目里没有报错 单独 ts 文件会报错）
- 不知道为什么 再 vue+ts 项目里 declare 的那些规则都不报错了 比如函数实现
- namespace 可以和 interface type enum class 名字重复 因为 namespace 和 interface 等用起来不一样 namespace.xx 和 interface['xx']

## 为什么 vue key 不能用 index

https://blog.csdn.net/m0_64572085/article/details/129228019

## ERROR: Invalid assignment target：v-model 中使用可选链操作符报错。

https://blog.csdn.net/youyudehan/article/details/132451801

v-model 绑定的值有可选操作符 不能用可选操作符是因为 双向数据绑定的时候 不能给可选操作符的变量赋值 直接对 number 或者 boolean 值 赋值也会触发这个错误

对只读变量赋值也会触发这个错误 解构的时候 不使用变量使用值给值赋值也会提示这个错误

## 计算属性无限执行的情况 bug 记录

```javascript
const fileList = computed({
  get: () =>
    evaluate.value!.evaluateImg.filter(
      (item: any) => item.status !== "success"
    ),
  set: async (
    val: {
      name: string
      raw: File
      size: number
      uid: number
      status: string
    }[]
  ) => {
    console.log(val)
    if (val.length > 5) {
      window.$message.error(`最多上传5张图片，当前选择${val.length}张`)
      evaluate.value!.evaluateImg = []
      return
    }
    evaluate.value!.evaluateImg = await Promise.all(
      val.map(async (item) => {
        const obj: any = item
        if (item.size > 1024 * 1024 * 2) {
          window.$message.error("上传图片不能超过2M")
          obj.url = ""
          return obj
        }
        if (!["jpeg", "png", "jpg"].includes(item.raw.type.split("/")[1])) {
          window.$message.error("仅支持上传jpeg,png,jpg格式的图片")
          obj.url = ""
          return obj
        }
        obj.url = await ossUpload(
          "/infra/file/member-avatar",
          item.name,
          item.raw
        )
        obj.status = "success"
        return obj
      })
    )
  }
})
```

问题就出在在 get 里 filter evaluate.value!.evaluateImg 了

不过又 get 了一个新的上传方式 就是写在计算属性里 如果设置了 limit 手动上传是不会触发 on-exceed 的 因此也无法提示用户超出上传了 这是由于如果设置 limit 选的多了 直接不执行任何事情了 因此不能写 limit 需要手动判断

## map 返回的是每个 cb 执行的返回结果 如果 cb 是 async 则执行结果全部是 promise

得用 promise.all 取最终的结果

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map

## v-model 的 filelist 不再需要自己写删除事件了

## .fill 方法 如果传入的是引用类型 则全部指向统一引用

fil 方法最多可传三个参数 内容 其实位置 终止位置 从起始位置换到终止位置不包含终止位置 不传终止位置 默认起始位置后全部

## 动态增删表单 把 rules 绑定在 el-form-item 上 单独写在 form 上不生效

https://blog.csdn.net/i_am_a_div/article/details/125544267

## 数组循环时 空属性会跳过

new Array(4).map(item=>{
console.log(1)
})

1 一次也不会打印 空属性不等于 undefined undefined 会遍历

## v-for 遍历时 直接把 item 作为 v-model 给子组件不可以 但使用变量[index]不会报错

## 计算 滚动条到页面底部距离

JS 获取滚动条到底部得距离 https://blog.csdn.net/qq_45272642/article/details/122900530

https://blog.csdn.net/weixin_55688275/article/details/140341674

```javascript
// 变量 scrollHeight 是滚动条的总高度
let scrollHeight =
  document.documentElement.scrollHeight || document.body.scrollHeight

// 变量 windowHeight 是可视区的高度
let windowHeight =
  document.documentElement.clientHeight || document.body.clientHeight

// 变量scrollTop为当前页面的滚动条纵坐标位置
let scrollTop = document.documentElement.scrollTop || document.body.scrollTop
// 滚动条到底部得距离 = 滚动条的总高度 - 可视区的高度 - 当前页面的滚动条纵坐标位置
scrollHeight - windowHeight - scrollTop
```

## el-rate 他妈的不会主动触发 rules 得手动去触发

## 踩坑：el-input textarea 不触发 rules 校验

需要设置初始值 测试没这个问题 但是项目里有 不止 textarea input 也有

## element:nth-child

这个意思是 父元素的第 n 个子元素且是 element 的元素

nth-type-child 意思是第 n 个是那个 type 的元素

如果 nth-type-child 前跟的是 class 那么实际选择的是 element.class:nth-type-child 最终选中的是 element 的第几个且 class 一致的元素

元素索引从 1 开始 函数符号 2n+1 这种 n 从 0 开始

## text-decoration 属性不会覆盖而会叠加

父元素有下划线 子元素设置 none 最终有下划线 父元素下划线子元素上划线 最终两条线

## el 表格合并 index 不包含 header 区域

## 多个组件/element 使用同一 ref

## Slidev web 制作 ppt

## 高德 api 修改目标位置

https://wenku.csdn.net/answer/49e22b886f7845db840e9c75d2defa9a

## 高德 api 设置鼠标样式

https://blog.csdn.net/solocao/article/details/103600817

## 宽度为 200px 的图片 img 宽度设置多一少一像素都会让图片变得模糊

https://www.zcool.com.cn/article/ZMTM0MjYwOA==.html?

## el-rate 貌似无法通过用户操作触发 rule

不过可以手写 change 事件触发表单校验

正则表达式（） 表示分组 匹配括号内的全部算作一个整体捕获

[]表示匹配的范围 [1234] 表示 1234 匹配其中一个就行 {} 用来表示匹配的长度 {1,4}是匹配 1-4 位 {3}表示匹配 3 位

https://blog.csdn.net/zhihaoma/article/details/50894114

(\d+) 表示 匹配任意的数字段

https://www.php.cn/faq/627814.html

## 正则表达式中问号(?)的正确用法详解

https://www.jb51.net/article/248118.htm

表示 0-1 次 非贪婪模式

[a-zA-Z]{1,5}? 最终生效的是[a-zA-Z]{1}？

aaaaaaaaaaaaacaaaaacaaaacaaaaa 不用问号使用贪婪模式 尽可能每一组都匹配 5 个字母 加了问号 每一组匹配一个

\*表示 0-无限 +表示至少一个

*号匹配 字符串长度比如是 10 但是会匹配 11 次 这是因为空字符串也算一次 *号匹配 0-更多 0 也算一次 但是这个空字符的 index 不是 0 而是 length 处

https://www.jb51.net/article/248118.htm

这里 regexp 的 $属性不知道是干嘛的

https://www.cnblogs.com/doublefeng0605/p/17661197.html

正数的正则表达式

## JSON.parse 只能解析 json 字符串 汉字字母字符串这种不是 json 字符串

[ ]这个也是 json 字符串 解析完就是空数组 布尔数字字符串也可解析

## props 默认值对象数组都要用函数形式返回

props 的属性可以直接在 template 里使用 不需要写 props. 但是如果 props 中的属性名是 props 那么想要使用它在 template 里则需要 props.props

props 传递过来的对象是一个引用 在子组件修改它的属性会修改掉父组件中的属性 可以在子组件中通过 clonedeep 深拷贝后 再转成响应式对象使用

## el 骨架屏组件 直接用 loading 控制显示隐藏就行 不需要 v-if loading 意思是是否进行加载效果 false 不进行展示真实 dom true 进行加载效果

官网写的默认值是 false 也就是说默认展示真实 dom 但我测试不是的

## Uncaught Error: Codegen node is missing for element/if/for node. Apply appropriate transforms first.

没写 v-if 就写 v-else

## 如果 style 里没有任何 css 那么插槽内容上也不会有父组件 data-v 标识

只要 style 里有任意 style 则插槽内容上会有父组件 dataa-v 标识

## box-shadow inset 会被图片覆盖

## show-overflow-tooltip 原理

https://www.cnblogs.com/lijinwen/p/6254148.html

https://blog.csdn.net/weixin_40451732/article/details/140521048

https://juejin.cn/post/7411160922645446690

https://blog.51cto.com/marsxh/5647585

## **`Range`** 接口表示一个包含节点与文本节点的一部分的文档片段

## background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。

前提：border 不能为有颜色不透明的实线

## html 可替换元素

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element

需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性（例如 [`vertical-align`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align)）加入计算之中。只有可替换元素才能具有这种自带值。

比如 img 标签

## range 对象实现 DOM 精确操作

https://blog.csdn.net/yfm120750310/article/details/109492462

## background 属性包括 clip 属性因此后者要写在前者之后才不会被覆盖

## border-radius 与 border-image 不兼容

https://www.jianshu.com/p/b9d34f384e67

## [纯 CSS 实现的的 3 种扫光效果](https://segmentfault.com/a/1190000045122864)

## el 的 input id 会在生成 dom 的时候放到真实 input 上 class 才会放到 el-input 上

## js 数字计算问题

19.01 _ 100 / 1113
1.7079964061096138
19.01 _ 100
1901.0000000000002
19.01 _ 1000 / 10
1901
1901 / 1113
1.7079964061096136
1.1 _ 100
110.00000000000001
1.1 \* 1000 / 10
110

js 小数计算时最好先转换成整数计算完再除 这里整数最好先转成 10 位的 因为各位还是容易出现小数的情况 比如 19.01 \* 100

e 表示科学计数法 1e + 5 表示 1\*100000 13e -5 表示 13 / 100000

number 类型的安全范围是 2 的 53 和-2 的 53 次方 超出这个范围的整数计算会有精度问题 比如 `Number.MAX_SAFE_INTEGER + 1` 和 `Number.MAX_SAFE_INTEGER + 2` 会被视为相等

## el 级联选择器 props 配置说明

multiple 是否多选 设置这个后也可选中每一级 并且会自动选择其子级

checkStrictly 父子不关联 设置这个 true 后 就可以选任意一级 但不会自动选择其子级

emitPath 这个设置 false 后 最后产生的数据每一项不是数组类型的 也就是不带路径。 即便是半选的节点也会被添加到 emitPath 里 很多场景下咱们是不需要的 只需要被完全选中的节点

leaf 叶子结点 也就是最后一级 一般做 lazyloading 用到

这些属性可以叠加使用 比如 multiple true checkStrictly true emitPath false 最后选中的数据是多选的每一个节点 不包含本身的子节点 且不带路径

## el-table 的 select 没有双向数据绑定 但是内部提供了方法手动选择与取消选择

## vue3.5 支持 解构 props

写法是 const {xx} = defineProps()

不可以先 const props = defineProps() 然后再 const {xx} = props 这样解构出来的是死数据

defineModel 解构同理 defineModel 可以使用 get set 转换器来处理修饰符 但 get 怎么用暂不清楚 暂时测试感觉是这么用的 get 从 props 里取 而

```javascript
const [modelValue] = defineModel("b", {
  get() {
    return props.b
  },
  set(value) {
    return value
  }
})
```

## element 中 rules 如果需要检测的数据是嵌套的 那么 rules 中的结构也需要嵌套

## undefined == 0 结果是 false 因为 undefined 转换后是 NaN 而不是 0

- 空字符串或仅包含空格的字符串转换为 `0`。
- Math.pow(x,y) 计算 x 的 y 次方

## el 和 naive 的 table 如何记录翻页的选中

## el-input-number mounted 后 值如果修改了 则会触发 min 和 max 的校验

数据变化不会触发 change 事件 手动改变才会

## v-for 也可条件选择 循环哪个数组 比如 v-for="item in a||b" 这里 a||b 不需要括号 因为 v-for 会优先判断 a 和 b 哪个存在 再执行 v-for 这和 forin a||b 一样

但 a===b||c b||c 就需要括号 不然会判断为 a===b 和||c

## bigInt 表示大于 `2^53 - 1` 的整数

5n 10n 这种就是 bigInt 类型 bigint 计算时会舍弃小数

## reserve-selection 可以让 el-table 数据切换时还保存之前的选中状态

## ES6 导出后 导入时 import xx from xxx 会先执行 from 的文件 后再从文件里 import 内容

这也是为什么有时候我们会报错说 pinia 未注册就调用的原因 因为可能在某些 import 的文件里 import 了别的文件里 用到了一些 store 的实例导致优先执行了 useXXX() 在 app.use(pinia)前（比如 App.vue 里）

## 对于 import 的组件 会在下载父组件的时候一并下载 而对于路由组件渲染 则要分情况

如果是 app.vue 里的组件 也就是一定会渲染的根组件 会先执行 setup 里的代码 直到挂载结束 再根据 template 里的 router-view 去下载对应的组件 而对于除 app.vue 外的子路由 则是先把子路由嵌套的所有需要展示的路由组件全部下载好 然后依次执行。

这应该是 vue-router 的 router-view 的解析执行原理

> 后经过我的测试发现执行顺序跟路由模块是同步还是异步导入有关系。如果子路由是 import xx from 这种形式导入的 那么最终渲染会等子组件下载完跟父组件一起执行（生产环境下是打包到一起的 因此必定一起执行）
>
> 而通过 import 方法同步导入的路由模块也就是按需导入的路由 会先渲染 app.vue 路由 再等待子组件下载完毕后再去渲染子组件及其生命周期，要注意的是如果某个嵌套路由中最深层的路由组件是 import 同步导入的 那么这个子组件的执行时机依旧是等待最深层的路由组件下载完毕，而不是先渲染父组件再去渲染子组件，因为组件的渲染是同步的，异步组件除外，app.vue 也除外，它不会等待同步子组件下载好再渲染。应该是因为 app.vue 自始至终都是一个文件吧？（待测试）
>
> 凡是 router.js 中通过 import 导入的组件 不按需导入的 都会和 app 组件打包到同一 js，并且渲染时只要遇到同步导入的组件就会等到其下载完毕后一并渲染，app 除外。即便组件正常下载也会等待子组件下载完毕再执行。

## lodash round 只会对小数执行四舍五入 整数不会 比如 round(5,2) 结果还是 5 而不是 5.00

## router.push() 字符串的话会当 fullpath 处理 对象的话则要分别写 path query 等 全写 path 里只解析 path 部分

## 两个 v-model 会出现 Maximum 的问题

## 关于若依里 system/config 路由 会 404 的问题

> 除代理配置的 url 不能与路由地址重复外，接口地址也不要与路由地址重复，不然 get 请求会优先请求接口 而不是 js

> 这是 history 情况下 hash 情况下应该不会 因为 hash 不会去发起请求

上面本来是我原本猜测的结论 但实际中发现如果直接将路由 system/config 配置在 router 里而不通过动态路由导入 则不会有问题 那么问题肯定不是出在后端

知道问题所在了 原因是因为我们的路由 name 重复了 在路由中 name 重复的话 后面的 name 会覆盖前一个 name 而在路由守卫中如果直接 nextpath 会跳转 path 如果 next 的是一个对象 {name:xxx,path:xxx} 以 name 为准 经过我测试 router.push 优先级也是先匹配 name。

重点：name 不可重复

## el-form 表单元素的 error 元素定位的原因

不定位的话每次提示错误 el-form-item 高度会变化

## overflowscroll 注意事项

overflowscroll 的元素不设置高度 高度默认以内部元素（非绝对定位）高度为准。scrollHeight 受内部定位或者 transform 的元素影响 而不仅仅是文档流的元素影响。

## rules validator 中 不使用 callback 使用 throw new Error 也会弹出规则校验 这说明内部应该是用 catch 去捕获错误 然后将 err 展示在 item 上的

但 throw 123 这种却不会报错 难道内部判断了是不是 Error 对象？

## git 提交规范

常见的 subject 种类以及含义如下：

1. **feat** : 新功能（feature）

- 用于提交新功能。
- 例如：`feat: 增加用户注册功能`

1. **fix** : 修复 bug

- 用于提交 bug 修复。
- 例如：`fix: 修复登录页面崩溃的问题`

1. **docs** : 文档变更

- 用于提交仅文档相关的修改。
- 例如：`docs: 更新README文件`

1. **style** : 代码风格变动（不影响代码逻辑）

- 用于提交仅格式化、标点符号、空白等不影响代码运行的变更。
- 例如：`style: 删除多余的空行`

1. **refactor** : 代码重构（既不是新增功能也不是修复 bug 的代码更改）

- 用于提交代码重构。
- 例如：`refactor: 重构用户验证逻辑`

1. **perf** : 性能优化

- 用于提交提升性能的代码修改。
- 例如：`perf: 优化图片加载速度`

1. **test** : 添加或修改测试

- 用于提交测试相关的内容。
- 例如：`test: 增加用户模块的单元测试`

1. **chore** : 杂项（构建过程或辅助工具的变动）

- 用于提交构建过程、辅助工具等相关的内容修改。
- 例如：`chore: 更新依赖库`

1. **build** : 构建系统或外部依赖项的变更

- 用于提交影响构建系统的更改。
- 例如：`build: 升级webpack到版本5`

1. **ci** : 持续集成配置的变更

- 用于提交 CI 配置文件和脚本的修改。
- 例如：`ci: 修改GitHub Actions配置文件`

1. **revert** : 回滚

- 用于提交回滚之前的提交。
- 例如：`revert: 回滚feat: 增加用户注册功能`

作者：JacksonChen
链接：https://juejin.cn/post/7374295163625521161
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## @vueuse/core 中的 useClipboard 失效问题

https://blog.csdn.net/yunchong_zhao/article/details/131324828

## customRef 再 get 中修改 ref 的值 不会触发父组件的副作用 但子组件会触发

https://play.vuejs.org/#eNqFVEtT2zAQ/itbzXTiDMZppz2FwJQyHOihZSg3xMHISiKQJY8k5zEZ//fuSnZIpoVebO1Dq28f3+7YZdMUq1ayKZt54VQTwMvQNhfcqLqxLsAOROuDre/kPAdHn3UZxBI6mDtbwwgvj/bOV7Zukp6zYkISBeeMG26ENT5A4+xmC+cUKXvgbG4tZzl6P5WOs8fxGTdaBlCmkhv0+jRcq/3Co7yHkmXBleIlh+DUYiHdGM4vINtxA7CQIRtDPAKa0SsbJyFGPTlJgsM0nUl4ilWpW1k4WbVCZlkpRA4qhuzDAKCuaFq/zBScwOjzCL8xHCFOHn1AdOxVXQ4Pj2MgocupAkC1zVYH4CL2bIhxgAVzXUVtx003RvzcTCYgbGuCdENRerGv5icKw03sTkb1yoHe2idBd6yWhTJzm3F2v5QwIrcRiGVpFrLChOCjwIFIHRFWWzeFJ0RDitX4jDAiipsAa2tG9HUvHxBfnl6opGymmBT6I2ZuZpM0UThLKARZN7oMEiWAWaVWIHTp/Tlna1c2DWbFoglgtyNYHWZO0uypDcEaCNtGonOSOINvQivxgpq+CthXdnFZVXh9X5ium03ShT70LA7olOLjTfrhpVkc1IRrgsAusGWzyQFeFH3Y6gS96OEOTayUR7/tFOZabvpG0vG0Uk6KoKyZIh7d1qY3llotzKnC+B4tkoD2lmecbjXfnmKnAuqPrFgNrGdEwXIWPPrM1aJ49tYgdyMWKkXdKC3dr4bexdymA0rOSq3t+kfUUYtwIJNeLKV4+Yf+2W9Ix9mtk166FQ3BYAulQ5Yl8/Xvn3KD572xtlWr0fsd453ESWwJY3L73poKYR/4RbQ3cakos7j31xusiB+SSjOWaEXeuGOohW+l/gr3S/F1IBVWcdhP7yy/yKZ+1cV3OIss2y+zhtZSJefKyFuS0g6iydoDoMmdwqVz5bbPD/3LVmODcVHR3sI1sef6AYmTNT5S/E3ot/m8Lv0xp6+WSldHrMZVN5C6Z7TS+pDQr2T+D5WRbnE5E1+PWMO6P2ANGKU=

我们通过修改父组件中其他的响应式变量 然后让组件更新 触发 customRef get 值变化 但不会触发父组件的 watch 但会触发子组件的

当使用 customRef 时，我们应该谨慎对待其 getter 的返回值，尤其是在每次运行 getter 时都生成新对象数据类型的情况下。当这样的 customRef 作为 prop 传递时，将影响父组件和子组件之间的关系。

父组件的渲染函数可能会被其他的响应式状态变化触发。在重新渲染过程中，我们会重新评估 customRef 的值，并返回一个新的对象数据类型作为子组件的 prop。这个 prop 会与其上一个值进行比较，由于两者不同，子组件中 customRef 的响应式依赖将被触发。与此同时，因为没有调用 customRef 的 setter，父组件中的响应式依赖不会运行。

## effectScope

创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。

可以阻止 watch 与 computed 的执行

https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md

## **Vue RFC 是一个正式的功能提议和讨论流程** ，确保透明度和社区参与

https://worktile.com/kb/p/3512460

## **[@vue/reactivity](https://www.baidu.com/s?rsv_dl=re_dqa_generate&sa=re_dqa_generate&wd=%40vue%2Freactivity&rsv_pq=9304e5d5012c23e8&oq=%40vue%2Freactivity&rsv_t=1d36rAzfGtz64YVxup5MfRBtlWgjihzkT+UPMkhQ9qcqLXVPY508OfNcrrZVGyGb0NkM&tn=baiduhome_pg&ie=utf-8)**

它是 vue3 响应式的核心依赖，包含 computed reactive ref 等 api 可脱离 vue3 独立使用进行响应式开发 （比如在 react 里使用 https://cloud.tencent.com/developer/article/1830562）

https://zhuanlan.zhihu.com/p/403156535

同时 vue3 中的 computed 其实是对[@vue/reactivity](https://www.baidu.com/s?rsv_dl=re_dqa_generate&sa=re_dqa_generate&wd=%40vue%2Freactivity&rsv_pq=9304e5d5012c23e8&oq=%40vue%2Freactivity&rsv_t=1d36rAzfGtz64YVxup5MfRBtlWgjihzkT+UPMkhQ9qcqLXVPY508OfNcrrZVGyGb0NkM&tn=baiduhome_pg&ie=utf-8)的 computed 又包了一层

reactive 则是直接用了 reactivity 的 reactive

[reactivity](https://www.baidu.com/s?rsv_dl=re_dqa_generate&sa=re_dqa_generate&wd=%40vue%2Freactivity&rsv_pq=9304e5d5012c23e8&oq=%40vue%2Freactivity&rsv_t=1d36rAzfGtz64YVxup5MfRBtlWgjihzkT+UPMkhQ9qcqLXVPY508OfNcrrZVGyGb0NkM&tn=baiduhome_pg&ie=utf-8)中提供了 stop api 来解绑副作用

## TS interface 声明说明

在 ts 文件里 如果 ts 文件里 如果不导入导出 那么就是全局声明类型 可以在其他文件里直接使用 如果导入导出 那么就是局部声明类型 只能在当前文件里使用 或导出导入使用

ts：什么是声明文件（declare,全局声明和模块声明

https://juejin.cn/post/7400584032621281280

详情看 ts 的测试 ts 项目中 .d.ts 与.ts 尽量不要同名(同一目录下 不同目录无所谓)

## jsx 和 h 函数

jsx 的组件 不需要 h 函数 直接 return jsx 格式就是组件了。

## setHours setMonth 这种函数可以传多个参数

比如 hour 后面可以跟分钟秒数毫秒数 month 后面可以跟 day

设置时间是今天/今年的几月几日 几分几秒

**`setDate()`** 只能传 day 设置是本月的第几天 **`setFullYear()`** 只能传 year 设置是几几年 这里要做区分

## v-bind css 编译

定义在 script 中的变量 style 中 v-bind 使用时 最终编译的时候是在当前组件的根节点 element 上增加定义的变量然后在 css 中 var 使用它（多个根组件就加多个 仅根组件）

## as 和 `<T> 都可以类型断言`

const extendWindow = `<T>window`

// @ts-ignore

哪一行 ts 报错用在哪一行上面 让那行忽略 ts 的检查

https://www.cnblogs.com/niehao/p/17970685

## 毛玻璃效果 backdrop-filter

https://blog.csdn.net/gtLBTNq9mr3/article/details/136277679

## vue 中避免过多的组件抽象

有些时候我们会去创建[无渲染组件](https://cn.vuejs.org/guide/components/slots.html#renderless-components)或高阶组件 (用来渲染具有额外 props 的其他组件) 来实现更好的抽象或代码组织。虽然这并没有什么问题，但请记住，组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。

需要提醒的是，只减少几个组件实例对于性能不会有明显的改善，所以如果一个用于抽象的组件在应用中只会渲染几次，就不用操心去优化它了。考虑这种优化的最佳场景还是在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。

## vue 组合式函数（hooks）

https://cn.vuejs.org/guide/reusability/composables#comparisons-with-other-techniques

## petite-vue

https://github.com/vuejs/petite-vue

简单 mini 的 vue 库适用于 html 文件无需构建工具

## [flex-shrink](https://m.baidu.com/s?word=flex-shrink&sa=re_dqa_zy) 计算规则

https://blog.csdn.net/HH18700418030/article/details/127006977

## SSR 会让代码在服务端和客户端各执行一次

https://stackblitz.com/edit/vue-ssr-example-7be79kpe?file=server.js

store 最好放在服务端创建应用时初始化，这样可以避免跨请求状态污染

## v-memo

https://www.jb51.net/article/263353.htm

## toString 可以将数字转换成二进制或者 16 进制的字符串

```
{} + []  和 +{} + +[] 是两种概念
```

前者会先把每个对象转原始值再相加 后者会先把每个对象转成原始值后再转数字相加

空数组是 0 转布尔是 true

[`==`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality) 运算符也是转换成原始值比较

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2

## [Number 强制转换](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2)

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2

## Symbol.toPrimitive

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive

## Number.isInteger()

**`Number.isInteger()`** 静态方法判断传入值是否为整数。 一般用于 后端返回的值 可能是 null undefined 0 123 时 0123 需要展示内容 当然加一个为 0 判断也可以

## Date.prototype[Symbol.toPrimitive]

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/Symbol.toPrimitive

## 标识符与关键字

*标识符*用于将值与名字进行连接。 类名 函数名 变量名 对象 key 都是标识符

关键字是 JavaScript 中看起来像标识符但又具有特殊含义的标记。 let const await 这种就说关键字 他是代码的一部分有特殊效果或者说含义

## 数字精度问题

5.0000000000000001 === 5 true

## vue-draggable-plus 踩坑

如果 target 是 ul 里面只有 li 元素可以拖动 div 里除了 iframe 之外都可以拖动

## webpack 配置

```javascript
const { Configuration } = require("webpack")
const path = require("path")

/**
 * @type {Configuration} //配置智能提示
 */
const config = {
  entry: "./src/index.ts",
  output: {
    filename: "wujie.js",
    path: path.resolve(__dirname, "./lib"),
    library: "Wujie",
    libraryTarget: "umd",
    umdNamedDefine: true
  },
  externals: {
    vue: "vue",
    wujie: "wujie"
  },
  mode: "none",
  cache: true,
  module: {
    rules: [
      {
        test: /\.ts$/, //解析ts
        loader: "swc-loader" //使用新技术swc-loader
      }
    ]
  }
}

module.exports = config
```

这段代码是一个 Webpack 配置对象，用于定义如何打包和输出 JavaScript 模块。以下是每个部分的详细解释：

### 1. `entry`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">entry</span><span class="token">:</span><span></span><span class="token">"./src/index.ts"</span><span class="token">,</span></code></div></div></pre>

- **说明** ：指定入口文件，Webpack 将从这个文件开始解析依赖关系。
- **值** ：`"./src/index.ts"`，表示入口文件是项目根目录下的 `src` 文件夹中的 `index.ts` 文件。

### 2. `output`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">output</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">filename</span><span class="token">:</span><span></span><span class="token">"wujie.js"</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">path</span><span class="token">:</span><span> path</span><span class="token">.</span><span class="token method property-access">resolve</span><span class="token">(</span><span>__dirname</span><span class="token">,</span><span></span><span class="token">'./lib'</span><span class="token">)</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">library</span><span class="token">:</span><span></span><span class="token">"Wujie"</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">libraryTarget</span><span class="token">:</span><span></span><span class="token">"umd"</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">umdNamedDefine</span><span class="token">:</span><span></span><span class="token">true</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span></code></div></div></pre>

- **filename** ：输出文件的名称。
- **值** ：`"wujie.js"`，表示输出的文件名为 `wujie.js`。
- **path** ：输出文件的路径。
- **值** ：`path.resolve(__dirname, './lib')`，表示输出文件的路径是当前配置文件所在目录下的 `lib` 文件夹。
- **library** ：库的名称。
- **值** ：`"Wujie"`，表示生成的库名称为 `Wujie`。
- **libraryTarget** ：库的目标格式。
- **值** ：`"umd"`，表示生成的库可以被多种模块系统（CommonJS、AMD、全局变量）使用。
- **umdNamedDefine** ：是否在 UMD 包装器中定义命名的 AMD 模块。
- **值** ：`true`，表示在 UMD 包装器中定义命名的 AMD 模块。

### 3. `externals`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">externals</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">vue</span><span class="token">:</span><span></span><span class="token">'vue'</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">wujie</span><span class="token">:</span><span></span><span class="token">'wujie'</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span></code></div></div></pre>

- **说明** ：指定外部依赖，这些依赖不会被打包到最终的输出文件中，而是假设它们已经在运行环境中存在。
- **值** ：
- `vue: 'vue'`：表示 `vue` 库不会被打包，而是假设在运行环境中已经存在 `vue`。
- `wujie: 'wujie'`：表示 `wujie` 库不会被打包，而是假设在运行环境中已经存在 `wujie`。

### 4. `mode`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">mode</span><span class="token">:</span><span></span><span class="token">"none"</span><span class="token">,</span></code></div></div></pre>

- **说明** ：指定 Webpack 的模式。
- **值** ：`"none"`，表示不使用任何预设的优化模式（如 `development` 或 `production`）。

### 5. `cache`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">cache</span><span class="token">:</span><span></span><span class="token">true</span><span class="token">,</span></code></div></div></pre>

- **说明** ：启用缓存以提高构建速度。
- **值** ：`true`，表示启用缓存。

### 6. `module`

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="fb54ebec-a1ec-43f5-a19c-af481c1eb2a0" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token literal-property">module</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">rules</span><span class="token">:</span><span></span><span class="token">[</span><span>
</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">test</span><span class="token">:</span><span></span><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.ts$</span><span class="token regex-delimiter">/</span><span class="token">,</span><span>
</span><span></span><span class="token literal-property">loader</span><span class="token">:</span><span></span><span class="token">"swc-loader"</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">]</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span></code></div></div></pre>

- **说明** ：定义模块规则，用于处理不同类型的文件。
- **rules** ：一个数组，包含多个规则对象。
- **test** ：匹配文件路径的正则表达式。
  - **值** ：`/\.ts$/`，表示匹配所有扩展名为 `.ts` 的文件。
- **loader** ：使用的加载器。
  - **值** ：`"swc-loader"`，表示使用 `swc-loader` 来处理 `.ts` 文件。`swc-loader` 是一个基于 SWC（Rust 编写的 JavaScript 编译器）的加载器，通常比传统的 Babel 加载器更快。

### 总结

这段代码配置了一个 Webpack 项目，指定了入口文件、输出文件、库的名称和目标格式、外部依赖、模式、缓存和模块规则。主要目的是将 TypeScript 文件编译并打包成一个可以在多种模块系统中使用的库文件。

## `>>>`运算符

作用：在 JavaScript 中，`>>>` 是一个无符号右移运算符（Unsigned Right Shift Operator）。它的作用是将一个数的二进制表示向右移动指定的位数，同时在左侧填充 0。

对于负数结果可能得到一个很大的正数

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift

它与>>相比是无符号的，因为前面始终填充的是 0，这也是为什么对于负数结果可能得到一个很大的正数

先把左侧的数计算为无符号数 再根据右侧的数字位移，向右移动的多余位将被丢弃，零位从左移入。

请注意，负十进制（以 10 为基数）数字 `-9` 的二进制表示形式是正十进制（以 10 为基数）数字 `9` 的[二进制补码](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)。也就是说，它是通过反转 `00000000000000000000000000001001` 的所有位并添加 `1` 来计算的。

`>>>` 和 `>>` 最大取模只能是 32 位二进制 超过 32 位的二进制 只会保留后面 32 位

这里的“取模 32”指的是对右操作数进行取模运算，确保最终的移位偏移量在 0 到 31 之间。具体来说：

- 右操作数首先会被转换为一个无符号的 32 位整数。
- 然后，这个无符号的 32 位整数会对 32 取模，即计算 `right_operand % 32`。
- 取模的结果将作为实际的移位偏移量。

例如：

- `100 >>> 32` 中，32 对 32 取模的结果是 0，所以 `100 >>> 32` 实际上等价于 `100 >>> 0`，结果仍然是 100。
- `100 >>> 35` 中，35 对 32 取模的结果是 3，所以 `100 >>> 35` 实际上等价于 `100 >>> 3`。

这样做的目的是确保移位偏移量始终在有效的范围内（0 到 31），避免不必要的重复移位。

https://blog.csdn.net/u014465934/article/details/91412762 更多位运算介绍 开发中不太用得到 了解即可

只需要记住 右移可以取整 左移可以计算倍数

两次按位非也可以取整~~

按位与 &

按位或| 一个整数与 0 按位或运算可以得到它本身，一个小数与 0 按位或运算可以得到取整效果

按位异或 ^ 按位异或的两个数值相同时返回 0，不同时返回 1

连续对两个数 a 和 b 进行三次异或运算，aˆ=b, bˆ=a, aˆ=b，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值 这样可用不新建变量而更换两个变量值（数字才行）

一个整数与 0 按位异或可以保持其自身，一个小数与 0 按位异或可以取整

左移 0 位可以实现取整效果

## 通过 proxy 对象上下文拿 refs 的时候无需.value 因为上下文本身就是一个 proxy 对象 ref 被解包了

## `document.defaultView` 返回的就是 window 对象

## URLSearchParams

一个带查询参数的网址，虽然 path 这种很好获取通过 location 属性但是 search 参数拿到的不是对象而是字符串 可用通过 URLSearchParams 来解析查询参数

## 函数参数默认值生效 的时机是不传参数 传 undefined 默认值也会生效 null 不行

## el-radio-group 如果默认值是字符串'0' 而 radio 的 value 是 0 1 那么的那一项不能点击 选中 并且默认是没有被选中的 这估计是 radio 内部没有用完全相等===

## FileSaver.js 一个客户端文件下载解决方案

saveAs(Blob/File/Url, optional DOMString filename, optional Object { autoBom })

## [axios ondownloadprogress 中 total 总为零，content-length 不返回](https://www.cnblogs.com/kaibo520/p/15380988.html "发布于 2021-10-08 17:45")

https://www.cnblogs.com/kaibo520/p/15380988.html

## 3xx location

#### Content-Location 和 Content

Content-Location 首部表明返回数据的另一种位置。主要的使用场景是用来表明作为内容协商结果响应的资源的 URL。

Location 和 Content-Location 是不同的：Location 表明重定向的目标（302），而 Content-Location 表明无需进行进一步的内容协商就可以直接访问的资源的 URL，例如英文环境客户端发送 url_file_a 可以得到文件 fileA,那么假设响应中 Content-Location 中内容为 url_file_a_en ,则这个 url 可以直接访问到对应的那个英文文件，此时其实就不存在内容协商了。 Location 是一个与响应相关的头信息，而 Content-Location 是与返回的内容主体相关的头信息。

Content-Location 的作用是返回与当前接口/资源的相关接口/资源方便客户端可直接使用而无需再次发起请求接口查询该资源/接口而 location 是当网站迁移新地址或者临时地址时返回 304 时直接跳转 location 的地址

https://cloud.tencent.com/developer/section/1189969

https://blog.csdn.net/weixin_30900589/article/details/94797157

## http 字段介绍

https://zhuanlan.zhihu.com/p/60753405

https://blog.csdn.net/Thea12138/article/details/136211596

## ERR_UNSAFE_PORT 浏览器安全问题无法访问的解决方案

https://blog.csdn.net/kjcxmx/article/details/118122483

## curl 命令行发送请求的方式

cmd / powershell 跟 REST client 区分开 后者虽说写的时候也是命令行 但写法不相同 虽然后者也支持 curl 的方式

## element-plus el-radio 自动执行 change 事件解决办法

https://juejin.cn/post/7140219063392796708

出现场景：el-radio 初始化时 v-model 的值既不属于 active-value 也不属于 inactive-value

## 为什么价格计算要先保留 4 位小数再保留两位而不是先保留 3 位再保留 2 位

如果先保留三位的话会影响到 2 位小数保留 比如 1.45491 保留三位会变成 1.455 再保留两位是 1.46 这与 1.45491 差距较大不符合四舍五入 1.45 更接近原数但如果是四位的话 1.45491 则会转换成 1.4549 再转两位是 1.45 完美符合我们的需求只有第五位大于 5 时保留三位与保留 4 位得到的结果一致咱们需要避免的是小数精度问题比如 0.6647 因为精度问题变成 0.66469999 如果此时咱们保留三位再保留两位会变成 0.67 而先保留四位是 0.6647 再保留 2 位是 0.66

```javascript
import _ from "lodash"
const appStore = useStore()
export default (number: number) => {
  const num = number.toString()
  // console.log(number,appStore.discount)
  let result = 0
  // 获取小数位
  if (num.includes(".")) {
    const decimal = num.split(".")[1]
    if (decimal.length <= 2) result = number
    else if (
      decimal.length > 2 &&
      decimal.length <=
        2 * (appStore.discount.toString().split(".")[1]?.length || 1)
    ) {
      result = _.round(number, 2)
      // 防止四舍五入时 影响 小数点后两位
    } else result = _.round(_.round(number, 4), 2)
  } else {
    result = number
  }

  // console.log(result)
  return result
}
```

## Math.round 与 \_.round

math.round 就是四舍五入 但是如果小数正好是.5 的话 则往正无穷大的轴上舍入 -1.5 round 是 -1 小数离哪个整数近就取哪个 .5 的话取大的

但是 math.round 最终的结果是整数 无法去做小数包含位数的四舍五入 lodash.round 可以

对于负数的处理 lodash 和 math 一样

## undefined 转数值是 NaN 而不是 0

```javascript
// 闭包
;(function () {
  /**
   * Decimal adjustment of a number.
   *
   * @param {String}  type  The type of adjustment.
   * @param {Number}  value The number.
   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
   * @returns {Number}      The adjusted value.
   */
  function decimalAdjust(type, value, exp) {
    // If the exp is undefined or zero...
    // 如果指数exp是undefined或者0或者 false null 空字符串 空白字符串等 则不带指数参与运算 空换行符不可
    if (typeof exp === "undefined" || +exp === 0) {
      return Math[type](value)
    }
    value = +value
    exp = +exp
    // If the value is not a number or the exp is not an integer...
    // 如果数值 是非数值 或者 exp是数字但是 小数 则直接NaN
    if (isNaN(value) || !(typeof exp === "number" && exp % 1 === 0)) {
      return NaN
    }
    // 如果数字包含e 则先分割开 不包含e 就直接转成科学计数法  5e5 就是 5 * 100000 = 500000  5e-5 就是5 * 0.00001 = 0.00005
    // Shift
    value = value.toString().split("e")
    value = Math[type](+(value[0] + "e" + (value[1] ? +value[1] - exp : -exp)))
    // 此时value 已是科学计数法 然后将这个科学计数法的值作为参数传入Math 方法 比如math.round 得出正常的值后 再拼接成最终输出的结果 参数是0正常执行四舍五入到个位 参数是1 四舍五入到10位 参数2 四舍五入到百位
    // Shift back
    value = value.toString().split("e")
    return +(value[0] + "e" + (value[1] ? +value[1] + exp : exp))
  }

  // Decimal round
  if (!Math.round10) {
    Math.round10 = function (value, exp) {
      return decimalAdjust("round", value, exp)
    }
  }
  // Decimal floor
  if (!Math.floor10) {
    Math.floor10 = function (value, exp) {
      return decimalAdjust("floor", value, exp)
    }
  }
  // Decimal ceil
  if (!Math.ceil10) {
    Math.ceil10 = function (value, exp) {
      return decimalAdjust("ceil", value, exp)
    }
  }
})()

// Round
Math.round10(55.55, -1) // 55.6
Math.round10(55.549, -1) // 55.5
Math.round10(55, 1) // 60
Math.round10(54.9, 1) // 50
Math.round10(-55.55, -1) // -55.5
Math.round10(-55.551, -1) // -55.6
Math.round10(-55, 1) // -50
Math.round10(-55.1, 1) // -60
Math.round10(1.005, -2) // 1.01 -- compare this with Math.round(1.005*100)/100 above
// Floor
Math.floor10(55.59, -1) // 55.5
Math.floor10(59, 1) // 50
Math.floor10(-55.51, -1) // -55.6
Math.floor10(-51, 1) // -60
// Ceil
Math.ceil10(55.51, -1) // 55.6
Math.ceil10(51, 1) // 60
Math.ceil10(-55.59, -1) // -55.5
Math.ceil10(-59, 1) // -50
```

上面的函数实现了 一个小数的四舍五入 -1 是保留一位小数四舍五入 1 是四舍五入到 10 位 注意最终返回的是数字 因此无法实现 正整数保留 n 位小数的操作

```javascript
function round(number, precision) {
  // Math.pow(10, precision) 次幂
  // 这里 number不可以传科学计数法很大的数否则会NaN  和上面做区分 上面可以保留10位百位  第二个参数如果是负数的话 则整数保留若干位数 -1 保留到10位 -2保留到百位跟上面正好相反传参方式 但得到的结果是一致的 除了科学计数法不能传很大
  // Math.round(2.545 + "e" + 2) / Math.pow(10,2);
  // 2.54   254 / 100

  // Math.pow(10, -1) = 0.1 Math.pow(10, 0) = 1
  // 5e-1 = 0.5 1 / 0.1 = 10
  // -5e-1 = -0.5 0 0/0.1 = 0
  return Math.round(+number + "e" + precision) / Math.pow(10, precision)
  //same as:
  //return Number(Math.round(+number + 'e' + precision) + 'e-' + precision);
}
```

## rules 配置踩坑

rules 的 min 和 max 要配置 type 才能对数字生效否则就是对字符串长度的校验

如果配置了 type：number 则 input 需要.number 修饰符 不然过不了 type：number 的校验

min max 可以是动态的 使用 get 函数 get min(){} 而不是 min:()=>xx 和 min：{get(){}} 前者是一个函数 后者是一个对象 只有 get min(){} 才是 get 函数可执行的

## JS 实现对 11 位手机号码中间 4 位数的隐藏

https://zhuanlan.zhihu.com/p/602231988

## el table 的 default-expand-all 不是响应式的 它是初始化表格时生效 如果想做成响应式的 每次切换时 需要表格销毁再创建一次

## 函数参数默认值只在没传那个参数或者参数值传 undefined 时默认值生效

## 正则表达式捕获组

就是()

## vue-cropper 使用说明

https://github.xyxiao.cn/vue-cropper/

- 必要属性：img 和 autoCrop 后者控制是否显示截图框 img 表示 使用哪个图片
- realTime 是实时预览事件 他是固定的一个结构 代码如下

  ```javascript
  <div :style="previewStyle2">
              <div :style="previews.div">
                <img :src="previews.url" :style="previews.img" />
              </div>
            </div>
  ```

previewStyle2 的大小一定要和咱们设置的 autoCropWidth 和 autoCropHeight 一致，可以通过 zoom 等比例缩放他达到咱们想要的大小

```javascript
const previewStyle2 = ref({
  width: "200px",
  height: "200px",
  overflow: "hidden",
  "border-radius": "50%",
  zoom: 0.5
})
function realTime(data) {
  console.log(data)
  previews.value = data
  // var h = 0.5
  // var w = 0.2
  // previewStyle2.value = {
  //   width: previews.w + 'px',
  //   height: previews.h + 'px',
  //   overflow: 'hidden',
  //   margin: '0',
  //   zoom: w
  // }
  previews.value = data
}
```

div 是 data 里面的一个属性 宽高等于截图框大小 url 就是咱们上传的图片的 url 或者本地 bloburl style 就是图片 tranform 移动 scale 放大缩小 等 css 属性达到和截图框在图片位置处显示的大小和位置一致

## blob 转 file

file blob 这种都是可以互相转换的

new File （blob,name,options） options 必须指定文件的类型 blob 要是数组格式必须

## computed 传入 setget 对象的注意事项

computed 计算属性要收集依赖 因此我们 get 里 return 的一定要是一个响应式对象 并且这个响应式对象还不能定义在 传入的对象里和 getset 同为属性 这样 value 会一直是 undefined

官网也说了 computed 传入的对象只能含有 get 与 set

## el-upload 的删除功能是 slice 删除具体某一项因此不会触发 set

## element-plus 一些低级版本 比如若依的 如果 select 设置多选 但没有给 v-model 默认值或者默认值不是数组 会在初始化时直接触发 rules 报警告

## Github 发现了一个很邪恶的项目，围观一款开源前端投毒包 Evil.js

https://cloud.tencent.com/developer/article/2453838

## [浅尝 rollup-plugin-visualizer——文件打包分析体积大小](https://www.cnblogs.com/iuniko/p/18308838 "发布于 2024-07-18 10:04")

https://www.cnblogs.com/iuniko/p/18308838

## 在 vite build 的 manifest 文件中

```json
"src/views/TestTwo.vue": {
    "file": "assets/TestTwo_chunk.js",
    "src": "src/views/TestTwo.vue",
    "isDynamicEntry": true,
    "imports": [
      "index.html",
      "_el-main_chunk.js",
      "_el-date-picker_chunk.js",
      "_el-popper_chunk.js",
      "_el-button_chunk.js",
      "_el-radio_chunk.js",
      "_SlotTest_chunk.js",
      "_el-dialog_chunk.js",
      "_el-select_chunk.js",
      "_index_chunk5.js",
      "_index_chunk3.js",
      "_arrays_chunk.js",
      "_hasIn_chunk.js",
      "_isEqual_chunk.js",
      "_objects_chunk.js",
      "_aria_chunk.js",
      "_index_chunk6.js",
      "_focus-trap_chunk.js",
      "_scroll_chunk.js",
      "_index_chunk7.js",
      "__baseIteratee_chunk.js",
      "_identity_chunk.js"
    ],
    "css": [
      "assets/TestTwo_asset.css",
      "assets/el-overlay_asset.css"
    ]
  },
  "src/views/Upload.vue": {
    "file": "assets/Upload_chunk.js",
    "src": "src/views/Upload.vue",
    "isDynamicEntry": true,
    "imports": [
      "index.html",
      "_el-progress_chunk.js",
      "_index_chunk3.js",
      "_objects_chunk.js",
      "_cloneDeep_chunk.js",
      "_isEqual_chunk.js",
      "__initCloneObject_chunk.js"
    ]
  },
"index.html": {
    "file": "assets/index_entry_BqmNs-q.js",
    "src": "index.html",
    "isEntry": true,
    "dynamicImports": [
      "src/views/404.vue",
      "src/components/paramsRoute/paramsRouteTwo.vue",
      "src/views/asyncVue.vue",
      "src/components/paramsRoute/paramsRouteOne.vue",
      "src/views/router/SecondRouter.vue",
      "src/views/index.vue",
      "src/views/test.vue",
      "src/components/ChildRoute.vue",
      "src/components/ChildRoute.vue",
      "src/components/ChildRoute.vue",
      "src/components/ChildRoute.vue",
      "src/views/TestTwo.vue",
      "src/views/TestThree.vue",
      "src/views/TestFour.vue",
      "src/views/TestFive.vue",
      "src/views/hooks.vue",
      "src/views/autoImport.vue",
      "src/views/Upload.vue",
      "src/views/path.vue",
      "src/views/update.vue",
      "src/views/ElTest.vue",
      "src/views/el/ElTreeTest.vue",
      "src/views/el/ElTableTest.vue",
      "src/views/el/ElFormTest.vue",
      "src/views/el/ElSkeletonTest.vue",
      "src/views/el/ElInputNumberTest.vue"
    ],
    "css": [
      "assets/index_asset.css"
    ],
    "assets": [
      "assets/lx9pflerpej90fgz8xwd7bx39gt5zw6_asset.png"
    ]
  }
```

build.manifest 当设置为 `true`，构建后将会生成 `.vite/manifest.json` 文件，包含了没有被 hash 过的资源文件名和 hash 后版本的映射。可以为一些服务器框架渲染时提供正确的资源引入链接。当该值为一个字符串时，它将作为 manifest 文件的名字。

file 是 build 后的文件目录 src 是 build 前在项目后的位置

isDynamicEntry 是否是动态引入的 凡是 import()导入的 这个属性是 true 无论其是否被使用

build 时 通过 import 导入的组件 最终会和 router.js 等打包进 entry.js （组件会打包成函数，懒加载的组件不会），切换路由时执行那个函数。

这里没有在 manifest 中找到 isDynamicEntry 为 false 的组件选项。

imports 属性表示依赖哪些内容 绝大部分组件的 imports 第一个都是 index.html 入口 其次才是当前组件内用到的其他组件 亦或者是 js 文件方法文件

index.html 的属性比较特殊 它没有 imports 和 isDynamicEntry

它有 isEntry 是否是入口 以及 dynamicImports 动态进口 它其中包含所有组件（在路由中使用的动态导入的路由组件（排除掉 import 导入的，但不影响子路由是 import()的)））。

css 就是用到的 css asset 静态文件。

- 对于 入口 或动态入口 chunk，键是相对于项目根目录的资源路径。
- 对于非入口 chunk，键是生成文件的名称并加上前缀 `_`。

主要是为服务端渲染服务的。

## 性能优化之 preload、prefetch、preconnect 的区别与使用

https://juejin.cn/post/7128400578467594248

preconnect 预解析 https://blog.csdn.net/wangnanwlw/article/details/142690784

preload 的作用就是 无需解析 js 再下载他引入的其他 js 或者 css 而是解析 html 的时候就开始下载了 省 js 解析时间了

## 无论数字 slice 还是字符串 slice 只要 end 的 index 在 start 前面 最后就返回空数组或者空字符串

[使用 slice() 把类数组对象转化为数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#%E4%BD%BF%E7%94%A8_slice_%E6%8A%8A%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84)

[,,,,,,]这也是一个数组 数组有 6 项 每一项都是空 如果有 6 个逗号就是 6 个空项 分别是第一个逗号前 ....第 n 个逗号前 不包含逗号后 逗号后没内容会被省略

## substr 是浏览器遗留的尽量避免使用 可使用 substring 和 slice 来截取字符串

substring 如果 start 大于 end 则交换二者 如果两个参数中的任何一个或两个都是负数或 `NaN`，`substring()` 方法将把它们视为 `0`。

slice 如果 如果 start 大于 end 则返回空[] 或者空字符串 slice 把负数视为 从 length 往前

substr 第二个参数是截取的长度 第一个参数是起始位置

- 如果 `start < 0`，则索引从字符串末尾开始计数。更准确地说，在这种情况下，子字符串从 `max(start + str.length, 0)` 开始。

## 通义灵码对于 preconnect 的解释

### `<link rel="preconnect">` 的作用及影响

`<link rel="preconnect">` 是一种资源提示（Resource Hints）技术，它允许浏览器提前与指定的服务器建立连接，从而减少后续资源加载时的延迟。具体来说，它会提前进行 DNS 解析、TCP 握手和 TLS 协商等操作。

#### 加不加 `preconnect` 的区别

1. **DNS 解析**：

   - **不加 `preconnect`**：当浏览器首次遇到需要从该域名加载资源时，才会开始 DNS 解析。
   - **加 `preconnect`**：浏览器在解析 HTML 文件时立即开始 DNS 解析，减少了后续资源加载时的等待时间。

2. **TCP 握手**：

   - **不加 `preconnect`**：每次请求资源时都需要进行 TCP 握手。
   - **加 `preconnect`**：提前进行 TCP 握手，后续请求可以直接复用已建立的连接，减少了握手的时间开销。

3. **TLS 协商**（对于 HTTPS 请求）：

   - **不加 `preconnect`**：每次请求资源时都需要进行 TLS 协商。
   - **加 `preconnect`**：提前进行 TLS 协商，后续请求可以直接复用已建立的安全连接，减少了协商的时间开销。

4. **总体性能提升**：

   - **不加 `preconnect`**：浏览器会在需要资源时才开始连接过程，这会导致额外的延迟。
   - **加 `preconnect`**：提前完成这些准备工作，可以显著减少资源加载的时间，尤其是在页面中有多个来自同一域名的资源时。

#### 示例

假设你引入了一个 CDN 库：

```html
<!-- 不使用 preconnect -->
<script src="https://example.com/cdn/library.js"></script>
```

```html
<!-- 使用 preconnect -->
<link rel="preconnect" href="https://example.com" />
<script src="https://example.com/cdn/library.js"></script>
```

在第二种情况下，浏览器会在解析到 `<link rel="preconnect">` 时就开始与 `https://example.com` 建立连接，这样当它遇到 `<script>` 标签时，连接已经准备好，资源可以更快地加载。

#### 实际效果

- **首屏加载速度**：使用 `preconnect` 可以减少关键资源的加载时间，从而加快首屏渲染速度。
- **用户体验**：用户会感受到页面加载更快，尤其是当页面依赖多个外部资源时。
- **网络条件较差的情况**：在高延迟或低带宽的网络条件下，`preconnect` 的效果更为明显，因为它减少了每次请求的初始连接时间。

#### 注意事项

- **过度使用**：虽然 `preconnect` 可以提高性能，但过度使用可能会导致浏览器资源被占用，反而降低整体性能。因此，应该只对关键的第三方资源使用 `preconnect`。
- **优先级管理**：确保 `preconnect` 的目标是那些确实会被频繁使用的资源，而不是所有外部资源。

### 总结

`<link rel="preconnect">` 提前建立了与服务器的连接，减少了后续资源加载时的 DNS 解析、TCP 握手和 TLS 协商的时间开销，从而显著提升了页面加载速度和用户体验。如果你引入了多个来自同一 CDN 的资源，建议使用 `preconnect` 来优化性能。

## map 对象直接访问属性要比数组遍历节省性能很多

```javascript
/**
 * 更符合中国宝宝体制的tree处理
 */

export function listToTree(
  data,
  options = {
    id: "id",
    parentId: "parentId",
    children: "children"
  }
) {
  const result = []
  // 15ms-27ms
  // data.forEach(element => {
  //   console.log(element, element[options.parentId])
  //   if (element[options.parentId] === 0) result.push(element)
  //   else {
  //     const parent = data.find(item => item[options.id] === element[options.parentId])
  //     parent[options.children] = parent[options.children] || []
  //     parent[options.children].push(element)
  //   }
  // })
  const obj = {}

  // 0.5ms-0.9ms
  data.forEach((element) => {
    element.children = []
    obj[element[options.id]] = element
    if (element[options.parentId] === 0) result.push(element)
  })
  for (const key in obj) {
    if (obj[key].parentId === 0) continue
    obj[obj[key].parentId].children.push(obj[key])
  }

  console.log(result)
  return result
}
```

## 主流浏览器都支持原生 CSS 嵌套了！

https://www.51cto.com/article/765563.html

## el-table 的 row-key 如果定义不正确 点击展开会展开全部的菜单（踩坑）

比如 row-key 的哪个属性压根不存在数据里

## link 标签细节

1. 可以通过 media 属性设置 媒体查询多少才加载这个文件
2. ref=preload 预加载 会下载文件但不会执行 后面遇到真正得 script src 或者 link rel=stylesheet 才会执行
3. 当 rel=preload 时 as 是必须得 as 的类型将决定请求的优先级 没有 as 不会下载文件
4. type 可以指定下载的文件类型 如果 type 与 href 文件类型不同 则不会下载文件
5. integrity 子文件完整性校验不通过的文件会被下载 但不会被使用 是下载后才去校验完整性的 bootstrap cdn 的文件 如果加了 integrity 会提示需要跨域请求配置 加了 crossorigin 后 会提示校验不通过但如果 crossorigin="use-credentials" 则直接提示跨域错误 anonymous 则不会 本地文件如果配置了子文件完整校验也会去校验完整性
6. crossorigin 是否发起跨域请求资源 默认不写就是不告诉服务端请求来自哪个源 加了这个的话 会在请求头加一个 origin 值是浏览器的域名
7. referrerpolicy 一个字符串，表示在获取资源时使用哪个 referrer 默认是 origin-when-cross-origin 同源时使用完整地址 不同源时使用协议、主机和端口
8. title 属性文档说是提供让用户自主更换可替换样式 也就是手动切换 css 样式 但只有火狐和 ie 支持 并且操作的地方我都没找到用户估计更找不到

## addRoute 或者说 vue-route 非子级路由的路由 path 必须以/开头 否则会报添加失败

## catch 将捕获 promise 执行的所有错误包括语法错误与 reject 的错误

## router 的 name 必须是唯一的 无论什么层级路由 必须是唯一 否则后面的会覆盖前面

## 预检请求的发送场景是跨域的请求

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS

## 图形形状 根据图片创建形状 比如五角星 可以让文字环绕五角星而不是图片正方形

https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_shapes/Shapes_from_images

## @是一个 css 规则 @keyframes @import @media 等等

https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#conditional_group_rules

## 请求 put 请求 更新数据时 比如头像这种 原本有头像的 想删除头像要把表单数据头像设置成空字符串 而不是 undefined 因为 undefined 转 json 会被删掉

## element 的 table 未提供默认勾选的自定义属性 因此只能用方法一个个勾

## CDN 的好处

https://developer.mozilla.org/zh-CN/docs/Glossary/CDN

## rel=canonical

理解 `rel="canonical"` 可能需要一些具体的例子来帮助说明。以下是更详细的解释和具体场景：

### 1. **处理重复内容**

假设你有一个电子商务网站，同一个商品可以通过不同的 URL 访问：

- `https://example.com/product?color=red`
- `https://example.com/product?color=blue`

这两个页面显示的是同一个商品的不同颜色版本，但搜索引擎会认为它们是两个独立的页面。为了避免这种情况，你可以在每个页面的 `<head>` 部分添加以下代码，指向规范页面（即你希望搜索引擎索引的页面）：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">html</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="37e7dd67-0066-453f-8248-fe0a06ddfbb4" tasktype="FREE_INPUT"><code class="language-html"><span class="token"><</span><span class="token">link</span><span class="token"></span><span class="token">rel</span><span class="token">=</span><span class="token">"</span><span class="token">canonical</span><span class="token">"</span><span class="token"></span><span class="token">href</span><span class="token">=</span><span class="token">"</span><span class="token">https://example.com/product</span><span class="token">"</span><span class="token">></span></code></div></div></pre>

这样，搜索引擎就知道 `https://example.com/product` 是这个商品的首选页面。

### 2. **规范网址选择**

有时候，同一个页面可以通过不同的 URL 访问：

- `https://example.com/page`
- `https://www.example.com/page`
- `https://example.com/page?utm_source=newsletter`

你可以通过设置 `rel="canonical"` 来指定哪个 URL 是你希望搜索引擎索引的：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">html</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="37e7dd67-0066-453f-8248-fe0a06ddfbb4" tasktype="FREE_INPUT"><code class="language-html"><span class="token"><</span><span class="token">link</span><span class="token"></span><span class="token">rel</span><span class="token">=</span><span class="token">"</span><span class="token">canonical</span><span class="token">"</span><span class="token"></span><span class="token">href</span><span class="token">=</span><span class="token">"</span><span class="token">https://www.example.com/page</span><span class="token">"</span><span class="token">></span></code></div></div></pre>

这确保了所有流量都集中到一个 URL 上，避免分散权重。

### 3. **合并分页内容**

如果你有一个博客文章或产品列表被分成多个页面：

- `https://example.com/article?page=1`
- `https://example.com/article?page=2`

你可以为每个分页页面设置 `rel="canonical"` 指向首页：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">html</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="37e7dd67-0066-453f-8248-fe0a06ddfbb4" tasktype="FREE_INPUT"><code class="language-html"><span class="token"><</span><span class="token">link</span><span class="token"></span><span class="token">rel</span><span class="token">=</span><span class="token">"</span><span class="token">canonical</span><span class="token">"</span><span class="token"></span><span class="token">href</span><span class="token">=</span><span class="token">"</span><span class="token">https://example.com/article</span><span class="token">"</span><span class="token">></span></code></div></div></pre>

这样，搜索引擎会将所有分页页面的权重集中到首页，而不是分别索引每个分页。

### 4. **镜像站点管理**

如果你有多个域名指向同一个网站（例如 `example.com` 和 `mirror-example.com`），你可以使用 `rel="canonical"` 来告诉搜索引擎哪个域名是权威的：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">html</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="37e7dd67-0066-453f-8248-fe0a06ddfbb4" tasktype="FREE_INPUT"><code class="language-html"><span class="token"><</span><span class="token">link</span><span class="token"></span><span class="token">rel</span><span class="token">=</span><span class="token">"</span><span class="token">canonical</span><span class="token">"</span><span class="token"></span><span class="token">href</span><span class="token">=</span><span class="token">"</span><span class="token">https://example.com/page</span><span class="token">"</span><span class="token">></span></code></div></div></pre>

这有助于避免搜索引擎将镜像站点视为重复内容。

### 总结

`rel="canonical"` 的主要作用是告诉搜索引擎哪个页面是你希望它优先索引的页面。通过正确使用 `rel="canonical"`，你可以避免重复内容问题，集中页面权重，并提高 SEO 效果。

https://websites.blog.csdn.net/article/details/19196347?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-19196347-blog-140623787.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-19196347-blog-140623787.235%5Ev43%5Epc_blog_bottom_relevance_base8

用途：比如我有个页面叫 b/123 这里的内容是 123 的内容 假如这个内容被放在其他页面的相关链接里 且我需要记录从哪个地方跳转过来的 那么我可能在 b/123 后面加一些参数 跳转过来 此时我可以把 b/123 的 canonical 设置成 b/123 让浏览器把带查询参数的那些不要当作一个新的页面分散权重

## HTML 属性：rel

更多是为 document 文档服务的 更像是一篇文章 有作者 有帮助 有搜索方法

https://zhuanlan.zhihu.com/p/712729889 rel=search 用法 但是我没有实现

## 跨资源共享 CROS

https://developer.mozilla.org/zh-CN/docs/Glossary/CORS

## Accept

**`Accept`** 请求 HTTP 标头表示客户端能够理解的内容类型，以 [MIME 类型](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/MIME_types)的形式表达。借助[内容协商机制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation), 服务器可以从诸多备选项中选择一项进行应用，并使用 [`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 响应标头通知客户端它的选择。浏览器会基于请求的上下文来为这个请求标头设置合适的值，比如，获取一个 CSS 层叠样式表时的值与获取图片、视频或脚本文件时的值是不同的。

比如我想告诉服务器我希望返回的内容是什么类型就设置这个 而请求完毕后 服务器会使用 content-Type 告诉客户端服务器的选择

客户端的 content-type 是告诉服务器我发送的数据是什么类型
