## 创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，***init命令有两个别名create、innit*** (init就是innit的缩写)。

npm init和npm create都是初始化一个package.json文件。

npm init -y 快速生成一个package.json文件。

yarn init也会初始化一个package.json。

 yarn create则会报错。因为yarn create需要跟包名

意思是

* **用指定的工具 创建新项目，但实际上做了两件事情：**
* a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
* b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于vite版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx  实际会去安装 create-xxx这个包 然后执行bin下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue项目编译和打包的时候都需要依据这个文件来进行ts的编译。

而jsconfig.json除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。
2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。
3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。
4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

## 一些依赖

@vitejs/plugin-vue  编译和解析.vue单文件组件。 他是vite与vue之间的桥梁。

typescript typescript依赖库。

vite 就是vite本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

* Vite仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对Vue3进行Typescript类型校验

这里没有发现解析编译typescript的依赖，可能是esbuild也可以编译ts吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite缓存

https://esbuild.github.io/ esbuild官网也说了 内置了js css ts 以及jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build的js代码没有被babel处理 因此如果需要兼容性则需要手动导入babel插件。

## SEO优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置webpack和页面实现预渲染方案，最终build出来多个html文件

不过需要history 路由模式

## vite+vue3+ts 手把手教你创建一个vue3项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

## 说说浏览器中的self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是WebWorker

WebWorker是运行在后台的javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时WebWorker在后台运行。
简单明了的一句话就是在javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker为Web应用程序提供了一种能在后台中运行的方法。通过WebWorker可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用WebWorker

* 解决一些页面的卡顿问题。
* 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

## 使用vite创建vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts中的reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types  env文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts和js混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些eslint规则

https://blog.csdn.net/qq_36305530/article/details/128342186
