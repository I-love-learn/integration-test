## 创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，***init命令有两个别名create、innit*** (init就是innit的缩写)。

npm init和npm create都是初始化一个package.json文件。

npm init -y 快速生成一个package.json文件。

yarn init也会初始化一个package.json。

 yarn create则会报错。因为yarn create需要跟包名

意思是

* **用指定的工具 创建新项目，但实际上做了两件事情：**
* a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
* b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于vite版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx  实际会去安装 create-xxx这个包 然后执行bin下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue项目编译和打包的时候都需要依据这个文件来进行ts的编译。

而jsconfig.json除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。
2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。
3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。
4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

快速上手Vue开发：在项目中如何配置 tsconfig.json 文件？

https://blog.csdn.net/sinat_27933301/article/details/132335904

tsconfigjson中的配置可以在运行vue-tsc命令的时候根据json中的配置项进行编译打包输出js，前提是设置了noEmit 为false 以及outDir。 如果不输出文件的话最终只做了ts代码检查。

## 一些依赖

@vitejs/plugin-vue  编译和解析.vue单文件组件。 他是vite与vue之间的桥梁。

typescript typescript依赖库。

vite 就是vite本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

* Vite仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对Vue3进行Typescript类型校验

这里没有发现解析编译typescript的依赖，可能是esbuild也可以编译ts吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite缓存

https://esbuild.github.io/ esbuild官网也说了 内置了js css ts 以及jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build的js代码没有被babel处理 因此如果需要兼容性则需要手动导入babel插件。

## SEO优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置webpack和页面实现预渲染方案，最终build出来多个html文件

不过需要history 路由模式

## vite+vue3+ts 手把手教你创建一个vue3项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

## 说说浏览器中的self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是WebWorker

WebWorker是运行在后台的javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时WebWorker在后台运行。
简单明了的一句话就是在javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker为Web应用程序提供了一种能在后台中运行的方法。通过WebWorker可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用WebWorker

* 解决一些页面的卡顿问题。
* 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

## 使用vite创建vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts中的reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types  env文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts和js混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些eslint规则

https://blog.csdn.net/qq_36305530/article/details/128342186

1. **`@babel/eslint-parser`** ：

* `@babel/eslint-parser`是一个ESLint解析器，它允许ESLint与Babel插件集成，以便在ESLint中使用Babel解析JavaScript代码。
* 通过使用 `@babel/eslint-parser`，可以确保ESLint能够正确解析使用了最新JavaScript语法或特性的代码，例如ES6/ES7语法、JSX等。

  这是一个代码检查插件。配置完成会自动安装相关依赖并生成 `.eslintrc.cjs` 文件
* `vite-plugin-eslint`允许在Vite项目中集成ESLint，实现对JavaScript和Vue等文件的代码检查。
* 通过该插件，可以在开发过程中实时检测代码风格和潜在问题，并及时提醒开发者进行修复，有助于提高代码质量和可维护性。

  [Prettier](https://so.csdn.net/so/search?q=Prettier&spm=1001.2101.3001.7020) 代码格式化工具，eslint是代码质量检查工具，二者可以搭配使用，一个负责检测代码书写错误，规范代码，一个用于自动修改代码中的错误。

  https://blog.csdn.net/m0_62762847/article/details/127072823

二者可以结合使用

https://zhuanlan.zhihu.com/p/659839223

https://zhuanlan.zhihu.com/p/337536349

https://blog.csdn.net/wangsenling/article/details/124944411

1. **eslint-config-prettier** ：

* `eslint-config-prettier`是一个ESLint配置，它的作用是关闭与Prettier重复的ESLint规则，避免ESLint和Prettier之间的冲突。
* 当使用 `eslint-config-prettier`时，它会禁用一些与Prettier冲突的ESLint规则，确保ESLint不会干扰Prettier对代码的格式化。

1. **eslint-plugin-prettier** ：

* `eslint-plugin-prettier`是一个ESLint插件，它的作用是在ESLint中运行Prettier进行代码格式化，并将格式化结果与原始代码进行比较。
* 当使用 `eslint-plugin-prettier`时，它会在ESLint检查代码之前运行Prettier，如果发现代码格式不符合规范，会将格式化后的代码与原始代码进行比较，并输出差异。
  eslint作用就是编辑一套适合团队的代码风格，而 `prettier`是自动格式化代码。

  https://blog.csdn.net/weixin_64051447/article/details/128262929
* eslint-config-prettier 会关闭ESLint中有关代码格式化的配置，具体参考这里。
* eslint-plugin-prettier 把Prettier配置成ESLint的一个插件，让其当做一个linter规则来运行，可参考其官网。

## npm cnpm yarn pnmp

https://zhuanlan.zhihu.com/p/457698236

https://blog.csdn.net/qq_68086484/article/details/127235359

总结 pnmp>yarn>npm3>npm2  cnpm是npm的国内镜像。

pnpm安装速度快且会有一个全局store来存储包，node_modules中是引用指向全局store中的包。

而yarn和npm是放到modules中把包。

## 使用TS时，解决.vue文件导入时报错说找不到类型

```typescript
// 声明一个模块，用于匹配所有以 ".vue" 结尾的文件
declare module "*.vue" {
// 从 "vue" 中导入 DefineComponent 类型
  import { App, defineComponent } from "vue";
// 定义一个类型为 DefineComponent 的变量 component
// 它具有三个泛型参数，分别表示组件的 props、组件的 data 和其他的类型。
// 在这里，我们使用空对象（{}）表示没有 props，使用空对象（{}）表示没有 data，使用 any 表示其他类型可以是任意值。
  const component: ReturnType<typeof defineComponent> & {
    install(app: App): void;
  };
// 导出 component 变量，这样其他地方在导入 ".vue" 文件时，TypeScript 编译器会将它识别为一个 Vue 组件
  export default component;
}
```

declare module typescript声明模块的语法。 上面的代码作用就是告诉ts .vue也是一个ts模块 而不是仅仅只是ts结尾的文件才是ts模块

d.ts文件是项目中的类型声明文件。如果想要ts能够获取默认类型则需要在d.ts文件中声明。

https://www.jianshu.com/p/85bd7e25e1e5

`declare module` 是在 TypeScript 中声明一个模块的语法。它通常用于为 JavaScript 模块（如 npm 包）或其他非 TypeScript 文件（如 Vue 的单文件组件）提供类型信息。这样，在 TypeScript 代码中引入这些模块时，编译器会使用你在 `.d.ts` 文件中定义的类型信息进行类型检查和代码提示。

## Typescript 中使用 ESLint 和 Prettier

https://www.jianshu.com/p/f363337e7c3e

```
npm i -d eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

这三个依赖分别是：

* eslint: ESLint 的核心代码；
* @typescript-eslint/parser：ESLint 的解析器，解析 TypeScript，检查和规范 TypeScript 代码；
* @typescript-eslint/eslint-plugin：ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

```
npm i -g prettier eslint-config-prettier eslint-plugin-prettier
```

* prettier：prettier 插件的核心代码；
* eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prettier 的样式规范为准，使 ESLint 中的样式规范自动失效；
* eslint-plugin-prettier：将 prettier 作为 ESLint 规范来使用。

暂时没有发现不写.prettierrc.js文件对代码格式化产生的问题，只要配置了eslint的配置文件就行.eslintrc.cjs

## ESlint插件

@vue/eslint-config-typescript   .vue文件支持eslint ts

@typescript-eslint/parser ts eslint解析器

@typescript-eslint/eslint-plugin ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

eslint-plugin-vue .vue文件 eslint插件 js

prettier 自动格式化代码

eslint-config-prettier eslint-plugin-prettier 解决eslint与prettier冲突

安装配置完毕prettier eslint-config-prettier eslint-plugin-prettier后便可实现 保存代码自动格式化eslint报错的代码。

## Vite 添加 ESLint 支持

需要安装一个插件 [vite-plugin-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-plugin-eslint "vite-plugin-eslint")，在 vite.config.ts 中进行使用。

npm install vite-plugin-eslint --save-dev

```javascript
...
import eslint from 'vite-plugin-eslint' // 新增
 
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), eslint()], // 新增 eslint()
})
 
复制代码
```

作用 eslint本身报错 vite会忽略编译的时候，浏览器也不会显示，使用了这个插件后，会在终端和浏览器中显示eslint的报错

https://blog.csdn.net/qq_41581588/article/details/130052727

ts下会报错说找不到声明文件，暂没有解决办法，因为是一个比较小众的依赖。

## 一些额外的eslint

`@babel/eslint-parser` 是一个 ESLint 解析器，它的作用是允许 ESLint 使用 Babel 解析器来解析 JavaScript 代码。通常情况下，ESLint 默认使用 Espree 作为解析器，但有时候我们希望使用 Babel 来解析代码，特别是在涉及到一些新的 JavaScript 语法或者需要支持一些 Babel 插件的情况下。

使用 `@babel/eslint-parser` 可以让 ESLint 在检查代码时使用 Babel 的解析器，这样就可以支持更多的 JavaScript 语法特性，以及使用一些 Babel 插件所带来的好处。这对于在项目中使用了 Babel 进行代码转换的情况下特别有用，可以确保 ESLint 能够正确解析和检查经过 Babel 转换后的代码。

本质这也是一个自定义解析器。

如果要使用自定义解析器（如 @babel/eslint-parser 或 @typescript-eslint/parser），则必须使用该 parserOptions.parser 选项而不是该 parser 选项。因为这个插件需要 vue-eslint-parser 来解析 .vue 文件，所以如果你覆盖这个 parser 选项，这个插件就不起作用。

**diff** 差异

```json
- "parser": "@typescript-eslint/parser",
+ "parser": "vue-eslint-parser",
  "parserOptions": {
+     "parser": "@typescript-eslint/parser",
      "sourceType": "module"
  }
```

这也是为什么我们的配置文件里是"parser": "vue-eslint-parser" 的原因了。因为我们用了自定义解析器也就是ts的eslint解析器。

vue-eslint-parser 并没有被我们直接安装，而是我们使用安装eslint-plugin-vue的时候自带的。

## 为什么配置了组件自动导入了，还会提示找不到组件的类型？

这是由于，如果我们设置了快捷path 比如views 那么如果我们直接写views/xxx.vue 是会报类型问题的，解决办法就是需要声明.vue的类型。

如果我们通过正常的相对路径的话，则不会有这个问题。

## `tsconfig.node.json`

`tsconfig.node.json` 文件通常用于配置 TypeScript 项目在 Node.js 环境中的编译选项和设置。与普通的 `tsconfig.json` 文件相比，`tsconfig.node.json` 文件是针对在 Node.js 环境下运行的 TypeScript 项目进行特定配置的文件。

一些常见的配置项和用途包括：

1. **目标环境：** 设置 `target` 选项为 `node`，以指定编译后的 JavaScript 代码是针对 Node.js 运行时环境的。
2. **模块系统：** 设置 `module` 选项为 `commonjs`，以确保 TypeScript 编译后的模块系统与 Node.js 兼容。
3. **Node.js 特定库支持：** 可能会配置 `lib` 选项以包含 Node.js 特定的类型声明文件，以便在 TypeScript 代码中使用 Node.js 提供的 API。
4. **其他编译选项：** 可能会根据项目需求配置其他编译选项，如输出目录、源映射、严格模式等。

总的来说，`tsconfig.node.json` 文件用于定制 TypeScript 项目在 Node.js 环境中的编译设置，以确保 TypeScript 代码能够正确地在 Node.js 中运行和执行。

一般用于编译vite.config.ts。

## vite与ts

在使用 Vite 构建 Vue 3 项目时，如果你打算使用 TypeScript 进行开发，通常情况下是需要安装 TypeScript 的。尽管 Vite 内置了对 TypeScript 的支持，并且使用 esbuild 来处理 TypeScript 代码的编译和转换，但 TypeScript 本身仍然是一种独立的编程语言，需要通过安装 TypeScript 包来提供类型检查、语法支持等功能。

因此，为了在 Vue 3 项目中使用 TypeScript，并且能够获得 TypeScript 提供的类型检查和其他功能，你仍然需要在项目中安装 TypeScript 包。你可以通过 npm 或 yarn 来安装 TypeScript：

```bash
npm install typescript --save-dev
# 或
yarn add typescript --dev
```

安装 TypeScript 后，你可以在项目中编写 TypeScript 代码，并利用 Vite 提供的 TypeScript 支持来进行开发。安装 TypeScript 包可以让你在项目中充分利用 TypeScript 的强大功能，同时结合 Vite 的快速构建能力，实现高效的开发体验。

也就是说vite只负责转换ts，不负责语法类型检查，需要typescript和vue-tsc来检查。

https://blog.csdn.net/qq_29689343/article/details/127187921

vscode本身支持ts校验的，虽然不装ts依赖也没关系，但是如果不用vscode呢。

https://blog.csdn.net/qq_41579104/article/details/129856763

tsconfig的配置项说明。

## vite中的tsconfig.json作用

首先就是配置vue-tsc的，让他执行的时候进行ts代码的规则校验。

至于compilerOptions中的配置我发现修改了并不影响最终的打包结果，可能是打包和编译是vite做的，而vue-tsc的打包需要我们设置noEmit为false 才会输出文件，这个输出的文件才是受compilerOptions影响的。

也就是说tsconfigjson其实对我们的打包编译影响很小，主要还是做类型校验的。这个单独使用typescript开发的时候很有用。

.d.ts类型声明文件一定要放到 include下声明的需要编译处理声明的文件目录，否则无效。

## javascript开启严格模式好处

开启 JavaScript 的严格模式（Strict Mode）可以带来以下几个好处：

1. 更严格的语法和错误检查：严格模式会对一些不规范的语法和错误进行更严格的检查，可以帮助开发者发现潜在的问题并避免一些常见的错误。
2. 提升代码质量：严格模式要求更规范的编码方式，可以帮助开发者编写更加健壮、可靠的代码，提升代码质量。
3. 避免全局变量污染：在严格模式下，禁止隐式声明全局变量，可以避免全局变量污染，提高代码的可维护性和可读性。
4. 提高性能：严格模式下的代码通常比非严格模式下的代码更优化，因为严格模式下的一些特性可以让 JavaScript 引擎进行更好的优化。

总的来说，开启 JavaScript 的严格模式可以帮助开发者编写更加规范、健壮的代码，提高代码质量和性能，避免一些常见的问题和错误。因此，推荐在项目中使用严格模式来编写 JavaScript 代码。

## ESlint 傻瓜式配置办法

https://blog.csdn.net/qq_41581588/article/details/130052727

不需要手动安装一堆eslint插件，只安装eslint直接init初始化一个配置选完就好了，自动安装多个eslint依赖。

另外即便选择了typescript，还是需要手动去配置文件里配置的。

其他一些报错eslint的也可以参考这里面的解决办法。

另外，yarn init 和npm init执行不一样后者才是初始化eslint 前者是初始化一个package.json

可以在eslintrc.cjs文件的rules下进行配置 关闭一些不需要的配置。

## ENV文件内部变量新增ts提示。

https://cn.vitejs.dev/guide/env-and-mode.html#intellisense

这样 使用import.meta.env的时候就有提示了。

## html中使用env中变量

语法是%env中变量名% 如果没有那个变量 则会显示字符串你使用的内容%env%

## Pinia支持两种语法 组合式和选项式

组合式和vue组合式api一样使用setup函数然后内部定义响应式变量后return出来。

选项式就和vue的选项式是一样的，状态写在state里，然后最终把每个状态写到这个store实例的根属性上。

也不是把状态写到store的根属性，实际上是在根属性上为$data(data)，store是$state加上了代理，直接通过根属性访问等于访问的是data或者state中的数据源。

打印vm中的this上的data中的根属性，发现其是一个get get return data[key] 而methods中的方法不是get 而是直接是一个方法。

但是pinia不是，他根属性是值，不是get，他的state居然是get ()=>hot ? hotState.value : pinia.state.value[$id]

vue3的data居然也是get ()=>publicPropertiesMap[[key](instance)]

单个store中的state是从pinia这个pinia应用身上的state中根据id作为key取到的，也就是说咱们所有定义的state都存在了pinia应用实例身上。

我打印了vue3的应用实例 app 发现其身上除了use provide unmount directive component mount等等属性和方法外，还有_component根组件或者说组件树结构

**_context**存折全局上下文内容，主要包含如下：

app自身  components 全局组件

propsCache 存着全局的props **emitsCache** 全局emits

optionsCache 存着全局所有组件的options

倒是没找到缓存全局data的key。

## vue组件实例扩展

instance（实例） 一个vue组件就是一个实例，组件实例对象身上有很多方法。

再vue3中 每个组件实例都是一个proxy对象，可以通过这个proxy对象来获取data中的数据与methods方法和computed计算属性从根属性上。

而这个组件真正的实例对象则存在_这个属性身上，这个属性和vue2的组件实例对象很像都有uid，data，props等等。

而vue实例proxy对象身上除了咱们定义的方法属性外，其他的$data $ el 等属性 都是get方法 **() => publicPropertiesMap[key](instance)**（instance） 这个instance就是当前组件的_属性 也就是实例 也就是说哪些属性也是通过_这个组件实例身上来获取属性的。

```javascript
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props) ,
      $attrs: (i) => shallowReadonly(i.attrs) ,
      $slots: (i) => shallowReadonly(i.slots) ,
      $refs: (i) => shallowReadonly(i.refs) ,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i) ,
      $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i) 
    })
  );
```

publicPropertiesMap 本质上是一个Map数据结构，其中每个属性都是一个方法，方法接受instance然后输出对应的内容，其实就是组件proxy快速访问实例身上的属性。

而proxy根属性上的数据也是get获取的 get ()=>data[key] data也是vue内部定义的，方法直接就是方法赋值的。

setup函数中定义的data return 后也会出现在根属性上。

但是setup语法糖不会。不过setup语法糖里的顶层变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用

setup函数可以直接return 一个render函数，这是一个函数组件可以创建虚拟dom。语法糖不可以。 attr参数和slot也都是响应式的。

`setup`中返回的数据，还有官网中罗列的 `$el`，`$data`等都可以通过 `this`访问，底层是使用了 `Proxy`作为代理，当组件初始化的时，设置了代理对象。而这一过程中又设置了_与 `$el`，`$data`等属性，使其可以通过get访问到对应的数据。

## pinia组合式写法

要注意的是pinia组合式写的时候可以不用使用ref或者reactive去定义state，前提是修改数据时通过store.xx = 去修改 因为这个是proxy对象修改会触发响应式，如果通过store中的function去修改state不行，因为数据不是响应式数据，因此最好我们定义成响应式的，使用的时候ref的数据可以不.value，这是由于 `store` 是一个用 `reactive` 包装的对象，这意味着不需要在 getters 后面写 `.value`。 https://pinia.vuejs.org/zh/core-concepts/#using-the-store

## 为什么vue组件data是函数而不是对象

首先一个.vue组件 包含了模板 脚本和样式 。

1. 解析：构建工具（如 Vue Loader）会解析 `.vue` 文件，将模板、脚本和样式部分分离开来。
2. 编译：模板部分会被编译成渲染函数，脚本部分会被转换成 JavaScript 模块，样式部分会被处理成对应的样式表。
3. 实例化：在 JavaScript 模块中，会创建一个 Vue 组件实例对象，该对象包含了组件的数据、方法、生命周期钩子等信息。
4. 挂载：最后，将这个组件实例对象挂载到页面上的某个元素上，使其可以渲染出对应的 UI。

而data的初始化就在组件实例化这一阶段。

https://www.pipipi.net/38792.html

根据文献与源码，大概能够得知是先有虚拟dom，后有组件实例的。

https://segmentfault.com/a/1190000041535107?sort=newest

确实先有虚拟dom再有组件实例。因为组件实例中会用到虚拟dom中的一些属性。

```
createComponentInstance方法
```

```
applyOptions
```

这个方法来给组件实例通过options来apply 方法和data。

多个相同组件在渲染时用的是同一个render函数，也就是.vue文件编译后的render函数，render函数生产虚拟dom，同时会创建组件实例，组件实例中的data来自于options中的data，methods中的方法会被添加到组件实例身上，`computed` 选项会被处理为计算属性，也会被添加到组件实例中，可以像普通属性一样访问，但是会根据依赖的数据动态计算。

而这个options中的data是共享的，一个组件被使用多次是同一个render函数调用生产虚拟dom的，而这个虚拟dom和组件实例的data也是取自同一个options对象的data，如果options的data是对象，那就导致多个组件实例的数据源指向同一对象，因此需要设置一个函数，每次需要实例化的时候调用data函数返回一个新的对象。

.vue组件编译完后会导出一个对象，template会编译成 render函数 其他的options会原封不动的导出，setup组件 导出setup函数。

后续创建vnode，创建组件实例都要用到这些options，因为这个编译好的sfc对象是不变的，后续创建组件实例和vnode的时候基于这个sfc对象的data，如果data是对象，那么数据就会共享，因此要设置成函数。

https://cn.vuejs.org/guide/scaling-up/sfc.html#single-file-components

https://blog.csdn.net/qq_36348403/article/details/136525629

setup里使用的组件，不会出现在实例的components属性中。

https://zhuanlan.zhihu.com/p/612336916

深入组件初始化与响应式。

https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js

vue源码。

## volar和prettier冲突解决

代码格式化选择默认prettier。

## letter-spacing

letter-spacing是可以设置小数的，比如0.9px 0.8px 设置的是文字间距。

## ::after伪类元素会受当前元素的css影响比如文字渐变色等等，本质上他属于当前元素子元素。

## 文字渐变色

background: linear-gradient(left, #ff0000, #ffff00); // 背景渐变色

background-clip: text; // 以文字的范围来裁剪背景图片 简单来说就是可以做一个带背景的艺术文字效果

-webkit-text-fill-color:transparent; // *text-fill-color*是CSS3中的属性,表示文字颜色填充 把裁剪缕空的文字弄透明，这样就可以通过缕空的形状看到背景颜色，这时背景颜色就是字体的颜色

https://www.jb51.net/css/728441.html

## eslint 报错说找不到ref reactive方法解决办法

https://blog.csdn.net/webbirds/article/details/127283504

## ts声明props类型且设置默认值

```typescript
// 枚举的声明方式
enum ButtonType {
  default = "default"
}
// 声明泛型propsType
type propsType = {
// type可传可不传
  type?: ButtonType
}
// 使用vue的语法糖withDefaults声明类型检查props以及default默认值
const props = withDefaults(defineProps<propsType>(), {
// 这里default要用枚举的方式声明 而不是直接写成"default"
  type: ButtonType.default
})

console.log(props)
```

使用ts好处是 vue自带的props校验仅仅针对生产环境，而ts编译时即可找出问题。

## linear-gradient参数学习与使用

inear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。

参数
方法：linear-gradient(direction, color-stop1, color-stop2, ...)

direction：第一个参数表示渐变的方向。其可以是一个具体的角度值如45deg，或者是具体的方向值如to top，表示自下而上渐变；to bottom表示自上而下渐变【默认为to bottom】，还有 to right、to left等。

color-stop：渐变色的起止位置，通常是颜色加起始位置百分比。如 red 10%等。

不写起止位置默认去平分。0deg 由下到上渐变，先写的颜色在下，后写的颜色在上。

不写0deg 默认的由上到下渐变，先写的颜色在上 后写在下 可以认为是180deg

https://blog.csdn.net/Bekind2010/article/details/130269260

## 双引擎架构Vite如何实现？

https://segmentfault.com/a/1190000043784798

开发环境 esbuild

生产环境 rollup 不过代码压缩也用了esbuild 因为快 rollup有自己的ts编译插件

## vite 预构建

https://cn.vitejs.dev/guide/dep-pre-bundling.html

vite构建完毕后会在node_modules中有缓存，只要不更改如viteconfigjs或者删除新增依赖就不会重新构建依赖。 因为依赖常常是不需要被更改的，预构建后会大大提高效率。不必每次都去转换依赖。

https://juejin.cn/post/7310439736828117046?searchId=20240407095912EAA9C5FA0F7CEF7F3563  深入浅出 Vite5 中依赖预构建

## rollup内置了ts依赖插件来打包ts

## vue-tsc 需要typescript依赖

## npm run vite build 过程发生了什么

https://juejin.cn/post/6887013512364130311

rollup和esbuild 都会执行vite.config.json 都会执行其中的plugin 因此.vue的转换是 @vitejs/plugin-vue实现的

## video不设置大小默认是视频自身宽高

## [Vite是如何实现Esbuild打包的](https://segmentfault.com/a/1190000043980887)

https://segmentfault.com/a/1190000043980887

https://www.jianshu.com/p/7b9fa3a4969b

开发环境是请求发送的时候，vite服务才开始编译module然后返回的，而不是一开始就编译好的。 如果缓存中已存在直接返回已经编译好的。 当然这里不包含已经预构建的依赖，仅针对咱们写的 css和.vue .js等文件。

每个组件在客户端被请求的时候都会在头部引入热更新的模块。

## plugin和loader的区别

https://blog.csdn.net/qq_38290251/article/details/134212725

https://blog.csdn.net/baidu_21919557/article/details/134973258

vite中貌似取消loader了，只有plugin了

## 为什么vite服务浏览器可以使用ts文件直接

因为ts的响应标头是text/javascript

另外 vite自身即可编译ts 装ts依赖是为了使用vue-tsc 进行类型检查

## 滚动条样式修改

```css
::-webkit-scrollbar {
// 滚动条宽高  x轴是高度 y轴是宽度
width:6px;
  height: 6px;
}
// 滚动条滑块得样式 可以使用背景色渐变
::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom right, #4d7fff 0%, #1a56ff 100%);
  border-radius: 5px;
}
// 滚动条轨道
::-webkit-scrollbar-track {
  background-color: #ddd;
  border: 1px solid #ccc;
}
// 滚动条两侧按钮
::-webkit-scrollbar-button {
  background-color: #4d7fff;
  border-radius: 5px;
}
// 按钮悬浮样式
::-webkit-scrollbar-button:hover {
  background-color: #999999;
}
```

## [`assetsInclude` 选项](https://cn.vitejs.dev/config/shared-options.html#assetsinclude)

作用是声明可以被import导出的资源。

https://cn.vitejs.dev/guide/assets.html#static-asset-handling

https://cn.vitejs.dev/config/shared-options.html#assetsinclude

## enum类型说明

enum枚举类型最终编译后是一个对象，而不是数组，另外它的声明方式和对象很像key value的形式，如果默认只写key 则会默认是 key = 0 key = 1的形式 编译成一个对象。

https://www.jb51.net/javascript/30299895t.htm

枚举想要赋值字符串的时候必须要使用枚举的属性，而不能直接写字符串 否则报错，但是数值可以直接赋值

成员可以是字符串也是数值，不允许使用其他类型的值。

## props踩雷记录

```javascript

const customClass = {
  small: props.size === "small",
  "super-large": props.size === "super-large",
  default:
    !props.size || props.size === "default" || props.size === "super-large",
  disabled: props.disabled
}
// 这里我声明了一个对象 来保存所有的class 然后template中使用它 但是我发现没有数据驱动视图，原因在于对象中的属性一开始就是固定的了，props在使用时已经变成了值。

// 至于我们使用对象形式父传子 以及template中不写props直接使用props的属性都是可以的
```

## 全局组件用不用最终都会打包进去 因此最好还是按需导入。

## icon图标自动导入

https://github.com/sxzz/element-plus-best-practices/blob/db2dfc983ccda5570033a0ac608a1bd9d9a7f658/vite.config.ts#L21-L58

## vite-plugin-inspect

vite-plugin-inspect 插件的作用是用于在 Vite 构建过程中检查和调试插件的工具。它可以帮助开发者更好地了解和分析 Vite 插件在构建过程中的执行情况，以便进行问题排查和优化调整。

通过 vite-plugin-inspect 插件，开发者可以查看插件在 Vite 构建过程中的执行顺序、输入输出信息、插件钩子的调用情况等，从而更好地理解插件的工作原理和影响。这有助于开发者调试和优化自定义插件，提高构建过程的效率和质量。

总的来说，vite-plugin-inspect 插件提供了一种方便的方式来检查和调试 Vite 构建过程中的插件，帮助开发者更好地理解和优化他们的自定义插件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

目测可以查看每个插件对源码的编译修改过程，和svn有点像，以后有空再研究。

## vite初始化与钩子

https://blog.csdn.net/xiangzhihong8/article/details/130931082

https://blog.csdn.net/u012384510/article/details/124287604

## 为什么已经使用了Components插件来自动导入vue组件了，但是autoImport里还有include声明vue文件呢？

因为autoimport 中导入的一些js 与组件 不属于components的范畴 比如 elmessage。

## 为什么已经安装了element图标库 使用自动导入图标时候还会自动安装ep图标库呢

后经过我测试 不需要安装element图标库了。

## inset  boxshadow 内阴影  外阴影看起来会改变盒子大小 内阴影不会 阴影本身不会改变元素大小  0 0 0 npx 看起来像是边框

## flex和 line-height 不会影响不同文字大小在同一容器内垂直位置上居中对齐。

也就是说垂直居中 使用line-height 不能让文字每一段文字 字号不同大小写不同，但都对盒子中心居中对齐. 文字默认有自己的对齐方式，就是根据文字基线来。

而flex align-items center 也不能保证 所有文字垂直居中对齐，文字有自己的高度。但总体还是大差不差的。

总结 数字 大写字母 汉字 使用line-height + **vertical-align**: **middle**;是可以实现文字居中的效果和flex ac一样 但小写字母不同 小写字母只是 显示小但是默认其高度是和大写字母一样高的 导致看起来 没有居中对齐而是偏下了，最好的所有文字居中对齐 还得是flex

https://www.cnblogs.com/BigFatStar/p/13442914.html

## flex只能保证子盒子位置 但是不能保证子盒子内部的盒子位置

## 自动导入的一些补充

https://blog.csdn.net/weixin_45366616/article/details/134469304

https://blog.csdn.net/qq_38845858/article/details/137112474

https://blog.csdn.net/qq_42611074/article/details/123036252

## template中函数传参细节

如果template中函数传参用到了ref 那么实参拿到的也是ref解包后的参数 不需要.value了

## ts 变量后边的问号和感叹号区别

例如 form？.xxx  意思是 form存在才调用后面方法，不存在不调用，!号意思是此时一定不为空直接调用

## autoimport配置中imports不能直接自动导入只包含一个export default的包

比如axios lodash 这种包只默认导出了一个export default 会报错  除非手动写成对象形式才行

另外ts 导出的文件 只可以默认在ts类型的中 默认导入 js不行  同理配置的tsconfig中@ 这种别名 也只能在支持ts的文件中用js不行，除非手动在tsconfig.json中设置allowJStrue

目前发现类型是无法自动导入的，无论是element的还是自己定义的以后尝试网上有没有解决办法。

## checkJs和allowJs

在 TypeScript 的 `tsconfig.json` 配置文件中，`allowJs` 和 `checkJs` 是两个不同的选项，它们分别用于处理 JavaScript 文件的情况。

1. **`allowJs` 选项**：

   - `allowJs` 是一个布尔类型的选项，用于指定是否允许在 TypeScript 项目中包含 JavaScript 文件（.js 文件）。
   - 当 `allowJs` 设置为 `true` 时，TypeScript 编译器将允许在项目中引入 JavaScript 文件，并对这些 JavaScript 文件进行类型检查和编译。
   - 这个选项通常用于逐步迁移现有的 JavaScript 项目到 TypeScript，或者允许在 TypeScript 项目中使用一些第三方库的 JavaScript 版本。
2. **`checkJs` 选项**：

   - `checkJs` 也是一个布尔类型的选项，用于指定是否对 JavaScript 文件进行类型检查。
   - 当 `checkJs` 设置为 `true` 时，TypeScript 编译器将对引入的 JavaScript 文件进行类型检查，类似于对 TypeScript 文件的处理。
   - 这个选项可以帮助在引入 JavaScript 文件时提供更好的类型检查和代码质量保证。

综合来说，`allowJs` 用于控制是否允许引入 JavaScript 文件，而 `checkJs` 用于控制是否对这些 JavaScript 文件进行类型检查。在需要逐步迁移项目或者引入第三方 JavaScript 库时，可以结合使用这两个选项来更好地管理 TypeScript 项目中的 JavaScript 文件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

## 有时候自动导入没有生效，原因可能是代码没有编译由于其他报错，需要重新编译一下就自动解决了

## elementplus中的表单验证ref 通过ref使用泛型可以 通过Ref就报错 哦 原因是因为忘记默认undefined了

## setInterval 类型是NodeJs.timeout 赋值给变量复制成这个|null

## axios返回值类型设置

https://juejin.cn/post/6969070102868131853

## vue3+ts 在获取接口响应数据时，在ts中报错 类型“AxiosResponse＜any, any＞”上不存在属性“state”

https://blog.csdn.net/m0_57033755/article/details/128547409

## upload组件注意事项

upload组件 file-list参数不要用v-model绑定，要用自定义属性，否则不好控制file-list内容 因为onchange事件执行在前 v-model执行在后,另外如果不想让默认的上传列表出来 不能直接设置file-list = [] 而是要手动 on-change里设置file-list = []

## elementplus表单重置事件

elementplus表单重置事件 不是重置成表单默认值，而是重置成当前这个表单创建时的初始值。
假如表单创建的时候 form的值已经变化了 则以form的当前值为初始值
