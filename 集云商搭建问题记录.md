## 创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，***init命令有两个别名create、innit*** (init就是innit的缩写)。

npm init和npm create都是初始化一个package.json文件。

npm init -y 快速生成一个package.json文件。

yarn init也会初始化一个package.json。

 yarn create则会报错。因为yarn create需要跟包名

意思是

* **用指定的工具 创建新项目，但实际上做了两件事情：**
* a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
* b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于vite版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx  实际会去安装 create-xxx这个包 然后执行bin下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue项目编译和打包的时候都需要依据这个文件来进行ts的编译。

而jsconfig.json除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是TypeScript项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。
2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。
3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。
4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

快速上手Vue开发：在项目中如何配置 tsconfig.json 文件？

https://blog.csdn.net/sinat_27933301/article/details/132335904

tsconfigjson中的配置可以在运行vue-tsc命令的时候根据json中的配置项进行编译打包输出js，前提是设置了noEmit 为false 以及outDir。 如果不输出文件的话最终只做了ts代码检查。

## 一些依赖

@vitejs/plugin-vue  编译和解析.vue单文件组件。 他是vite与vue之间的桥梁。

typescript typescript依赖库。

vite 就是vite本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

* Vite仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对Vue3进行Typescript类型校验

这里没有发现解析编译typescript的依赖，可能是esbuild也可以编译ts吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite缓存

https://esbuild.github.io/ esbuild官网也说了 内置了js css ts 以及jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build的js代码没有被babel处理 因此如果需要兼容性则需要手动导入babel插件。

## SEO优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置webpack和页面实现预渲染方案，最终build出来多个html文件

不过需要history 路由模式

## vite+vue3+ts 手把手教你创建一个vue3项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

## 说说浏览器中的self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是WebWorker

WebWorker是运行在后台的javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时WebWorker在后台运行。
简单明了的一句话就是在javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker为Web应用程序提供了一种能在后台中运行的方法。通过WebWorker可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用WebWorker

* 解决一些页面的卡顿问题。
* 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

## 使用vite创建vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts中的reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types  env文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts和js混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些eslint规则

https://blog.csdn.net/qq_36305530/article/details/128342186

1. **`@babel/eslint-parser`** ：

* `@babel/eslint-parser`是一个ESLint解析器，它允许ESLint与Babel插件集成，以便在ESLint中使用Babel解析JavaScript代码。
* 通过使用 `@babel/eslint-parser`，可以确保ESLint能够正确解析使用了最新JavaScript语法或特性的代码，例如ES6/ES7语法、JSX等。

  这是一个代码检查插件。配置完成会自动安装相关依赖并生成 `.eslintrc.cjs` 文件
* `vite-plugin-eslint`允许在Vite项目中集成ESLint，实现对JavaScript和Vue等文件的代码检查。
* 通过该插件，可以在开发过程中实时检测代码风格和潜在问题，并及时提醒开发者进行修复，有助于提高代码质量和可维护性。

  [Prettier](https://so.csdn.net/so/search?q=Prettier&spm=1001.2101.3001.7020) 代码格式化工具，eslint是代码质量检查工具，二者可以搭配使用，一个负责检测代码书写错误，规范代码，一个用于自动修改代码中的错误。

  https://blog.csdn.net/m0_62762847/article/details/127072823

二者可以结合使用

https://zhuanlan.zhihu.com/p/659839223

https://zhuanlan.zhihu.com/p/337536349

https://blog.csdn.net/wangsenling/article/details/124944411

1. **eslint-config-prettier** ：

* `eslint-config-prettier`是一个ESLint配置，它的作用是关闭与Prettier重复的ESLint规则，避免ESLint和Prettier之间的冲突。
* 当使用 `eslint-config-prettier`时，它会禁用一些与Prettier冲突的ESLint规则，确保ESLint不会干扰Prettier对代码的格式化。

1. **eslint-plugin-prettier** ：

* `eslint-plugin-prettier`是一个ESLint插件，它的作用是在ESLint中运行Prettier进行代码格式化，并将格式化结果与原始代码进行比较。
* 当使用 `eslint-plugin-prettier`时，它会在ESLint检查代码之前运行Prettier，如果发现代码格式不符合规范，会将格式化后的代码与原始代码进行比较，并输出差异。
  eslint作用就是编辑一套适合团队的代码风格，而 `prettier`是自动格式化代码。

  https://blog.csdn.net/weixin_64051447/article/details/128262929
* eslint-config-prettier 会关闭ESLint中有关代码格式化的配置，具体参考这里。
* eslint-plugin-prettier 把Prettier配置成ESLint的一个插件，让其当做一个linter规则来运行，可参考其官网。

## npm cnpm yarn pnmp

https://zhuanlan.zhihu.com/p/457698236

https://blog.csdn.net/qq_68086484/article/details/127235359

总结 pnmp>yarn>npm3>npm2  cnpm是npm的国内镜像。

pnpm安装速度快且会有一个全局store来存储包，node_modules中是引用指向全局store中的包。

而yarn和npm是放到modules中把包。

## 使用TS时，解决.vue文件导入时报错说找不到类型

```typescript
// 声明一个模块，用于匹配所有以 ".vue" 结尾的文件
declare module "*.vue" {
// 从 "vue" 中导入 DefineComponent 类型
  import { App, defineComponent } from "vue";
// 定义一个类型为 DefineComponent 的变量 component
// 它具有三个泛型参数，分别表示组件的 props、组件的 data 和其他的类型。
// 在这里，我们使用空对象（{}）表示没有 props，使用空对象（{}）表示没有 data，使用 any 表示其他类型可以是任意值。
  const component: ReturnType<typeof defineComponent> & {
    install(app: App): void;
  };
// 导出 component 变量，这样其他地方在导入 ".vue" 文件时，TypeScript 编译器会将它识别为一个 Vue 组件
  export default component;
}
```

declare module typescript声明模块的语法。 上面的代码作用就是告诉ts .vue也是一个ts模块 而不是仅仅只是ts结尾的文件才是ts模块

d.ts文件是项目中的类型声明文件。如果想要ts能够获取默认类型则需要在d.ts文件中声明。

https://www.jianshu.com/p/85bd7e25e1e5

`declare module` 是在 TypeScript 中声明一个模块的语法。它通常用于为 JavaScript 模块（如 npm 包）或其他非 TypeScript 文件（如 Vue 的单文件组件）提供类型信息。这样，在 TypeScript 代码中引入这些模块时，编译器会使用你在 `.d.ts` 文件中定义的类型信息进行类型检查和代码提示。

## Typescript 中使用 ESLint 和 Prettier

https://www.jianshu.com/p/f363337e7c3e

```
npm i -d eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

这三个依赖分别是：

* eslint: ESLint 的核心代码；
* @typescript-eslint/parser：ESLint 的解析器，解析 TypeScript，检查和规范 TypeScript 代码；
* @typescript-eslint/eslint-plugin：ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

```
npm i -g prettier eslint-config-prettier eslint-plugin-prettier
```

* prettier：prettier 插件的核心代码；
* eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prettier 的样式规范为准，使 ESLint 中的样式规范自动失效；
* eslint-plugin-prettier：将 prettier 作为 ESLint 规范来使用。

暂时没有发现不写.prettierrc.js文件对代码格式化产生的问题，只要配置了eslint的配置文件就行.eslintrc.cjs

## ESlint插件

@vue/eslint-config-typescript   .vue文件支持eslint ts

@typescript-eslint/parser ts eslint解析器

@typescript-eslint/eslint-plugin ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

eslint-plugin-vue .vue文件 eslint插件 js

prettier 自动格式化代码

eslint-config-prettier eslint-plugin-prettier 解决eslint与prettier冲突

安装配置完毕prettier eslint-config-prettier eslint-plugin-prettier后便可实现 保存代码自动格式化eslint报错的代码。

## Vite 添加 ESLint 支持

需要安装一个插件 [vite-plugin-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-plugin-eslint "vite-plugin-eslint")，在 vite.config.ts 中进行使用。

npm install vite-plugin-eslint --save-dev

```javascript
...
import eslint from 'vite-plugin-eslint' // 新增
 
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), eslint()], // 新增 eslint()
})
 
复制代码
```

作用 eslint本身报错 vite会忽略编译的时候，浏览器也不会显示，使用了这个插件后，会在终端和浏览器中显示eslint的报错

https://blog.csdn.net/qq_41581588/article/details/130052727

ts下会报错说找不到声明文件，暂没有解决办法，因为是一个比较小众的依赖。

## 一些额外的eslint

`@babel/eslint-parser` 是一个 ESLint 解析器，它的作用是允许 ESLint 使用 Babel 解析器来解析 JavaScript 代码。通常情况下，ESLint 默认使用 Espree 作为解析器，但有时候我们希望使用 Babel 来解析代码，特别是在涉及到一些新的 JavaScript 语法或者需要支持一些 Babel 插件的情况下。

使用 `@babel/eslint-parser` 可以让 ESLint 在检查代码时使用 Babel 的解析器，这样就可以支持更多的 JavaScript 语法特性，以及使用一些 Babel 插件所带来的好处。这对于在项目中使用了 Babel 进行代码转换的情况下特别有用，可以确保 ESLint 能够正确解析和检查经过 Babel 转换后的代码。

本质这也是一个自定义解析器。

如果要使用自定义解析器（如 @babel/eslint-parser 或 @typescript-eslint/parser），则必须使用该 parserOptions.parser 选项而不是该 parser 选项。因为这个插件需要 vue-eslint-parser 来解析 .vue 文件，所以如果你覆盖这个 parser 选项，这个插件就不起作用。

**diff** 差异

```json
- "parser": "@typescript-eslint/parser",
+ "parser": "vue-eslint-parser",
  "parserOptions": {
+     "parser": "@typescript-eslint/parser",
      "sourceType": "module"
  }
```

这也是为什么我们的配置文件里是"parser": "vue-eslint-parser" 的原因了。因为我们用了自定义解析器也就是ts的eslint解析器。

vue-eslint-parser 并没有被我们直接安装，而是我们使用安装eslint-plugin-vue的时候自带的。

## 为什么配置了组件自动导入了，还会提示找不到组件的类型？

这是由于，如果我们设置了快捷path 比如views 那么如果我们直接写views/xxx.vue 是会报类型问题的，解决办法就是需要声明.vue的类型。

如果我们通过正常的相对路径的话，则不会有这个问题。

## `tsconfig.node.json`

`tsconfig.node.json` 文件通常用于配置 TypeScript 项目在 Node.js 环境中的编译选项和设置。与普通的 `tsconfig.json` 文件相比，`tsconfig.node.json` 文件是针对在 Node.js 环境下运行的 TypeScript 项目进行特定配置的文件。

一些常见的配置项和用途包括：

1. **目标环境：** 设置 `target` 选项为 `node`，以指定编译后的 JavaScript 代码是针对 Node.js 运行时环境的。
2. **模块系统：** 设置 `module` 选项为 `commonjs`，以确保 TypeScript 编译后的模块系统与 Node.js 兼容。
3. **Node.js 特定库支持：** 可能会配置 `lib` 选项以包含 Node.js 特定的类型声明文件，以便在 TypeScript 代码中使用 Node.js 提供的 API。
4. **其他编译选项：** 可能会根据项目需求配置其他编译选项，如输出目录、源映射、严格模式等。

总的来说，`tsconfig.node.json` 文件用于定制 TypeScript 项目在 Node.js 环境中的编译设置，以确保 TypeScript 代码能够正确地在 Node.js 中运行和执行。

一般用于编译vite.config.ts。

## vite与ts

在使用 Vite 构建 Vue 3 项目时，如果你打算使用 TypeScript 进行开发，通常情况下是需要安装 TypeScript 的。尽管 Vite 内置了对 TypeScript 的支持，并且使用 esbuild 来处理 TypeScript 代码的编译和转换，但 TypeScript 本身仍然是一种独立的编程语言，需要通过安装 TypeScript 包来提供类型检查、语法支持等功能。

因此，为了在 Vue 3 项目中使用 TypeScript，并且能够获得 TypeScript 提供的类型检查和其他功能，你仍然需要在项目中安装 TypeScript 包。你可以通过 npm 或 yarn 来安装 TypeScript：

```bash
npm install typescript --save-dev
# 或
yarn add typescript --dev
```

安装 TypeScript 后，你可以在项目中编写 TypeScript 代码，并利用 Vite 提供的 TypeScript 支持来进行开发。安装 TypeScript 包可以让你在项目中充分利用 TypeScript 的强大功能，同时结合 Vite 的快速构建能力，实现高效的开发体验。

也就是说vite只负责转换ts，不负责语法类型检查，需要typescript和vue-tsc来检查。

https://blog.csdn.net/qq_29689343/article/details/127187921

vscode本身支持ts校验的，虽然不装ts依赖也没关系，但是如果不用vscode呢。

https://blog.csdn.net/qq_41579104/article/details/129856763

tsconfig的配置项说明。

## vite中的tsconfig.json作用

首先就是配置vue-tsc的，让他执行的时候进行ts代码的规则校验。

至于compilerOptions中的配置我发现修改了并不影响最终的打包结果，可能是打包和编译是vite做的，而vue-tsc的打包需要我们设置noEmit为false 才会输出文件，这个输出的文件才是受compilerOptions影响的。

也就是说tsconfigjson其实对我们的打包编译影响很小，主要还是做类型校验的。这个单独使用typescript开发的时候很有用。

.d.ts类型声明文件一定要放到 include下声明的需要编译处理声明的文件目录，否则无效。

## javascript开启严格模式好处

开启 JavaScript 的严格模式（Strict Mode）可以带来以下几个好处：

1. 更严格的语法和错误检查：严格模式会对一些不规范的语法和错误进行更严格的检查，可以帮助开发者发现潜在的问题并避免一些常见的错误。
2. 提升代码质量：严格模式要求更规范的编码方式，可以帮助开发者编写更加健壮、可靠的代码，提升代码质量。
3. 避免全局变量污染：在严格模式下，禁止隐式声明全局变量，可以避免全局变量污染，提高代码的可维护性和可读性。
4. 提高性能：严格模式下的代码通常比非严格模式下的代码更优化，因为严格模式下的一些特性可以让 JavaScript 引擎进行更好的优化。

总的来说，开启 JavaScript 的严格模式可以帮助开发者编写更加规范、健壮的代码，提高代码质量和性能，避免一些常见的问题和错误。因此，推荐在项目中使用严格模式来编写 JavaScript 代码。

## ESlint 傻瓜式配置办法

https://blog.csdn.net/qq_41581588/article/details/130052727

不需要手动安装一堆eslint插件，只安装eslint直接init初始化一个配置选完就好了，自动安装多个eslint依赖。

另外即便选择了typescript，还是需要手动去配置文件里配置的。

其他一些报错eslint的也可以参考这里面的解决办法。

另外，yarn init 和npm init执行不一样后者才是初始化eslint 前者是初始化一个package.json

可以在eslintrc.cjs文件的rules下进行配置 关闭一些不需要的配置。

## ENV文件内部变量新增ts提示。

https://cn.vitejs.dev/guide/env-and-mode.html#intellisense

这样 使用import.meta.env的时候就有提示了。

## html中使用env中变量

语法是%env中变量名% 如果没有那个变量 则会显示字符串你使用的内容%env%

## Pinia支持两种语法 组合式和选项式

组合式和vue组合式api一样使用setup函数然后内部定义响应式变量后return出来。

选项式就和vue的选项式是一样的，状态写在state里，然后最终把每个状态写到这个store实例的根属性上。

也不是把状态写到store的根属性，实际上是在根属性上为$data(data)，store是$state加上了代理，直接通过根属性访问等于访问的是data或者state中的数据源。

打印vm中的this上的data中的根属性，发现其是一个get get return data[key] 而methods中的方法不是get 而是直接是一个方法。

但是pinia不是，他根属性是值，不是get，他的state居然是get ()=>hot ? hotState.value : pinia.state.value[$id]

vue3的data居然也是get ()=>publicPropertiesMap[[key](instance)]

单个store中的state是从pinia这个pinia应用身上的state中根据id作为key取到的，也就是说咱们所有定义的state都存在了pinia应用实例身上。

我打印了vue3的应用实例 app 发现其身上除了use provide unmount directive component mount等等属性和方法外，还有_component根组件或者说组件树结构

**_context**存折全局上下文内容，主要包含如下：

app自身  components 全局组件

propsCache 存着全局的props **emitsCache** 全局emits

optionsCache 存着全局所有组件的options

倒是没找到缓存全局data的key。

## vue组件实例扩展

instance（实例） 一个vue组件就是一个实例，组件实例对象身上有很多方法。

再vue3中 每个组件实例都是一个proxy对象，可以通过这个proxy对象来获取data中的数据与methods方法和computed计算属性从根属性上。

而这个组件真正的实例对象则存在_这个属性身上，这个属性和vue2的组件实例对象很像都有uid，data，props等等。

而vue实例proxy对象身上除了咱们定义的方法属性外，其他的$data $ el 等属性 都是get方法 **() => publicPropertiesMap[key](instance)**（instance） 这个instance就是当前组件的_属性 也就是实例 也就是说哪些属性也是通过_这个组件实例身上来获取属性的。

```javascript
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props) ,
      $attrs: (i) => shallowReadonly(i.attrs) ,
      $slots: (i) => shallowReadonly(i.slots) ,
      $refs: (i) => shallowReadonly(i.refs) ,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i) ,
      $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i) 
    })
  );
```

publicPropertiesMap 本质上是一个Map数据结构，其中每个属性都是一个方法，方法接受instance然后输出对应的内容，其实就是组件proxy快速访问实例身上的属性。

而proxy根属性上的数据也是get获取的 get ()=>data[key] data也是vue内部定义的，方法直接就是方法赋值的。

setup函数中定义的data return 后也会出现在根属性上。

但是setup语法糖不会。不过setup语法糖里的顶层变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用

setup函数可以直接return 一个render函数，这是一个函数组件可以创建虚拟dom。语法糖不可以。 attr参数和slot也都是响应式的。

`setup`中返回的数据，还有官网中罗列的 `$el`，`$data`等都可以通过 `this`访问，底层是使用了 `Proxy`作为代理，当组件初始化的时，设置了代理对象。而这一过程中又设置了_与 `$el`，`$data`等属性，使其可以通过get访问到对应的数据。

## pinia组合式写法

要注意的是pinia组合式写的时候可以不用使用ref或者reactive去定义state，前提是修改数据时通过store.xx = 去修改 因为这个是proxy对象修改会触发响应式，如果通过store中的function去修改state不行，因为数据不是响应式数据，因此最好我们定义成响应式的，使用的时候ref的数据可以不.value，这是由于 `store` 是一个用 `reactive` 包装的对象，这意味着不需要在 getters 后面写 `.value`。 https://pinia.vuejs.org/zh/core-concepts/#using-the-store

## 为什么vue组件data是函数而不是对象

首先一个.vue组件 包含了模板 脚本和样式 。

1. 解析：构建工具（如 Vue Loader）会解析 `.vue` 文件，将模板、脚本和样式部分分离开来。
2. 编译：模板部分会被编译成渲染函数，脚本部分会被转换成 JavaScript 模块，样式部分会被处理成对应的样式表。
3. 实例化：在 JavaScript 模块中，会创建一个 Vue 组件实例对象，该对象包含了组件的数据、方法、生命周期钩子等信息。
4. 挂载：最后，将这个组件实例对象挂载到页面上的某个元素上，使其可以渲染出对应的 UI。

而data的初始化就在组件实例化这一阶段。

https://www.pipipi.net/38792.html

根据文献与源码，大概能够得知是先有虚拟dom，后有组件实例的。

https://segmentfault.com/a/1190000041535107?sort=newest

确实先有虚拟dom再有组件实例。因为组件实例中会用到虚拟dom中的一些属性。

```
createComponentInstance方法
```

```
applyOptions
```

这个方法来给组件实例通过options来apply 方法和data
