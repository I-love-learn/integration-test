## 创建项目的命令

```
npm init  vite@latest
```

```
yarn create vite
```

二者是相等的，**_init 命令有两个别名 create、innit_** (init 就是 innit 的缩写)。

npm init 和 npm create 都是初始化一个 package.json 文件。

npm init -y 快速生成一个 package.json 文件。

yarn init 也会初始化一个 package.json。

yarn create 则会报错。因为 yarn create 需要跟包名

意思是

- **用指定的工具 创建新项目，但实际上做了两件事情：**
- a. 先执行了 `yarn global add create工具包` 命令，**全局安装**了指定的 工具包
- b. 再执行了 `create工具包 项目名` ，通过 工具包 来 创建了项目

npm create 跟包名 同理。

https://zhuanlan.zhihu.com/p/619991024

https://blog.csdn.net/weixin_55697693/article/details/130854304

由于 vite 版本升级，创建项目的命令也会有所不同，咱们以官网为准就行，不必记那么多。

yarn create xxx 实际会去安装 create-xxx 这个包 然后执行 bin 下的可执行文件，然后创建项目。

## tsconfig.json

这个 `tsconfig.json`文件是 TypeScript 项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。

vue 项目编译和打包的时候都需要依据这个文件来进行 ts 的编译。

而 jsconfig.json 除了代码提示和跳转，并不能对代码编译产生什么作用。

这个 `tsconfig.json`文件是 TypeScript 项目的配置文件，用于指定 TypeScript 编译器的编译选项和项目的结构。下面是对这个 `tsconfig.json`文件中各个配置项的解释：

1. **compilerOptions**：编译选项，指定 TypeScript 编译器的行为和输出结果。

   - `target: "ES2020"`：指定编译后的 JavaScript 目标版本为 ES2020。
   - `useDefineForClassFields: true`：启用类字段的定义。
   - `module: "ESNext"`：指定模块输出的格式为 ESNext。
   - `lib: ["ES2020", "DOM", "DOM.Iterable"]`：指定要包含的库文件，包括 ES2020、DOM 和 DOM.Iterable。
   - `skipLibCheck: true`：跳过对声明文件的检查。
   - `moduleResolution: "bundler"`：模块解析策略为 bundler。
   - `allowImportingTsExtensions: true`：允许导入 TypeScript 扩展名的模块。
   - `resolveJsonModule: true`：允许导入 JSON 模块。
   - `isolatedModules: true`：将每个文件视为独立的模块。
   - `noEmit: true`：不生成输出文件。
   - `jsx: "preserve"`：保留 JSX 代码以供后续转换。

2. **Linting**：代码检查选项，用于指定 TypeScript 编译器的严格模式和代码检查规则。

   - `strict: true`：启用所有严格类型检查选项。
   - `noUnusedLocals: true`：禁止未使用的局部变量。
   - `noUnusedParameters: true`：禁止未使用的函数参数。
   - `noFallthroughCasesInSwitch: true`：禁止在 switch 语句中出现不明确的 case。

3. **include**：指定要包含在编译中的文件或目录。

   - `["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]`：包含所有以 `.ts`、`.tsx` 和 `.vue` 结尾的文件。

4. **references**：指定项目的引用关系，可以引用其他项目的配置文件。

   - `{"path": "./tsconfig.node.json"}`：引用了名为 `tsconfig.node.json` 的配置文件。

这个 `tsconfig.json`文件定义了 TypeScript 项目的编译选项、代码检查规则和项目结构，确保 TypeScript 编译器按照指定的方式进行编译和检查代码。

快速上手 Vue 开发：在项目中如何配置 tsconfig.json 文件？

https://blog.csdn.net/sinat_27933301/article/details/132335904

tsconfigjson 中的配置可以在运行 vue-tsc 命令的时候根据 json 中的配置项进行编译打包输出 js，前提是设置了 noEmit 为 false 以及 outDir。 如果不输出文件的话最终只做了 ts 代码检查。

## 一些依赖

@vitejs/plugin-vue 编译和解析.vue 单文件组件。 他是 vite 与 vue 之间的桥梁。

typescript typescript 依赖库。

vite 就是 vite 本身 提供 项目冷启动和热更新功能，处理不同文件优化代码等等。

vue-tsc 用于类型检查和构建 dts。除了 TypeScript 文件，它还支持 Vue 的单文件组件。

- Vite 仅执行 `.ts`文件的转译工作，并不执行任何类型检查。`vue-tsc`可以对 Vue3 进行 Typescript 类型校验

这里没有发现解析编译 typescript 的依赖，可能是 esbuild 也可以编译 ts 吧 https://www.jianshu.com/p/22da8ad5e6a6

https://www.vitejs.net/guide/dep-pre-bundling.html#the-why vite 官网对预构建的解释。

https://www.vitejs.net/guide/dep-pre-bundling.html#file-system-cache vite 缓存

https://esbuild.github.io/ esbuild 官网也说了 内置了 js css ts 以及 jsx。

这些编译的文件应该都存在内存中，因为项目运行的时候，源文件没有发生变化。

## vite build 的 js 代码没有被 babel 处理 因此如果需要兼容性则需要手动导入 babel 插件。

## SEO 优化

https://blog.csdn.net/qq_34235767/article/details/130653221

https://blog.csdn.net/m0_46386854/article/details/129712446

利用库 prerender-spa-plugin + vue-meta-info 配置 webpack 和页面实现预渲染方案，最终 build 出来多个 html 文件

不过需要 history 路由模式

## vite+vue3+ts 手把手教你创建一个 vue3 项目

https://blog.csdn.net/attengtiong/article/details/128393733

## UMD 模块介绍

https://blog.csdn.net/m0_61773971/article/details/130838036

其实就是一个兼容浏览器 nodejs AMD CMD 的集成的模块化处理手段。

AMD 和 CMD 区别 https://baijiahao.baidu.com/s?id=1790113364978673808&wfr=spider&for=pc

## 说说浏览器中的 self, global, globalThis

`self` 对象是在 Web Workers 中引入的一个全局对象，用于表示当前执行上下文的全局范围。与之相对，`window` 对象是浏览器环境中的全局对象，用于表示浏览器窗口的全局范围。尽管在浏览器中，`self` 和 `window` 引用同一个全局对象，但它们在使用上有一些细微的差别。

`window` 对象仅在浏览器环境中可用，而 `self` 对象不仅在浏览器环境，还在 Web Workers 中可用。Web Workers 是一种多线程的 JavaScript 执行环境，允许在后台运行脚本，独立于主线程。

`global` 对象是 JavaScript 环境中的顶级对象，它提供了全局范围的属性和方法。`window` 对象则是浏览器环境中的全局对象，扩展了 `global` 对象并提供了与浏览器窗口相关的功能。

`global` 对象在各种 JavaScript 运行时环境中都存在，包括浏览器、Node.js 等。而 `window` 对象仅在浏览器环境中存在，用于表示当前浏览器窗口的全局范围。

`window` 对象是 `global` 对象的子集，它扩展了 `global` 对象并提供了与浏览器窗口相关的功能。`window` 对象包含了许多与浏览器窗口属性和方法，例如 `document`、`location`、`setTimeout` 等。而 `global` 对象则提供了一些通用的全局性质的属性和方法，例如 `Object`、`Array`、`Math` 等。

`globalThis` 是在最新的 ECMAScript 标准中引入的全局对象。它提供了一种跨平台的方式来访问全局对象，不依赖于具体的环境。无论是在浏览器、Node.js 还是其他 JavaScript 运行时环境中，都可以使用 `globalThis` 来访问全局对象。

https://www.jianshu.com/p/3e3029000629

## WebWorker

### 1.什么是 WebWorker

WebWorker 是运行在后台的 javascript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。点击选取内容等等，而此时 WebWorker 在后台运行。
简单明了的一句话就是在 javascript 单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后，再回到主线程上，在这个过程中，并不影响主线程的执行过程。
WebWorker 为 Web 应用程序提供了一种能在后台中运行的方法。通过 WebWorker 可以生成多个线程同时运行，并保证页面对用户的及时响应，完全不会影响用户的正常操作。

### 2.为什么要使用 WebWorker

- 解决一些页面的卡顿问题。
- 解决某些函数执行时间过长，体验不流畅，卡顿。

https://blog.csdn.net/weixin_45702700/article/details/102655641 用法

react 使用 webworker

https://blog.csdn.net/qq_33539839/article/details/131885078

## 使用 vite 创建 vite3 项目以及遇到的一些问题

https://www.jianshu.com/p/7fd693a34529

## .d.ts 中的 reference types="vite/client"作用

在 TypeScript 项目中，`.d.ts` 文件通常用于声明文件（Declaration Files），用来描述已有 JavaScript 代码库的类型信息。当你在 TypeScript 项目中使用第三方库或模块时，可能会需要引入相应的声明文件来提供类型定义，以便在编译时进行类型检查。

`<reference types="vite/client" />` 是一种特殊的引用指令，用于告诉 TypeScript 编译器在编译时要引入 `vite/client` 这个声明文件中的类型信息。在 Vite 项目中，`vite/client` 是 Vite 提供的客户端模块，用于实现热更新和开发服务器的功能。

通过在 `.d.ts` 文件中添加 `<reference types="vite/client" />`，你可以让 TypeScript 编译器识别并使用 `vite/client` 中定义的类型信息，以便在项目中正确地引用和使用 Vite 提供的客户端模块。这样可以帮助 TypeScript 编译器进行类型检查，提高代码的可靠性和可维护性。

总的来说，`<reference types="vite/client" />` 的作用是告诉 TypeScript 编译器在编译时引入 `vite/client` 声明文件中的类型信息，以便在项目中正确地使用 Vite 提供的客户端模块。这样可以帮助开发者在 TypeScript 项目中更好地利用 Vite 的功能，并确保代码的类型安全性。

https://cn.vitejs.dev/guide/features.html#client-types env 文件类型支持等等。

https://blog.csdn.net/sanfeng_hu/article/details/127939621 TypeScript 的智能提示，如果使用 ts , 我们要要对自定义的环境变量进行提供了类型定义。

https://cn.vitejs.dev/guide/env-and-mode

## ts 和 js 混合开发

https://www.jianshu.com/p/f8d4637320db

## 一些 eslint 规则

https://blog.csdn.net/qq_36305530/article/details/128342186

1. **`@babel/eslint-parser`** ：

- `@babel/eslint-parser`是一个 ESLint 解析器，它允许 ESLint 与 Babel 插件集成，以便在 ESLint 中使用 Babel 解析 JavaScript 代码。
- 通过使用 `@babel/eslint-parser`，可以确保 ESLint 能够正确解析使用了最新 JavaScript 语法或特性的代码，例如 ES6/ES7 语法、JSX 等。

  这是一个代码检查插件。配置完成会自动安装相关依赖并生成 `.eslintrc.cjs` 文件

- `vite-plugin-eslint`允许在 Vite 项目中集成 ESLint，实现对 JavaScript 和 Vue 等文件的代码检查。
- 通过该插件，可以在开发过程中实时检测代码风格和潜在问题，并及时提醒开发者进行修复，有助于提高代码质量和可维护性。

  [Prettier](https://so.csdn.net/so/search?q=Prettier&spm=1001.2101.3001.7020) 代码格式化工具，eslint 是代码质量检查工具，二者可以搭配使用，一个负责检测代码书写错误，规范代码，一个用于自动修改代码中的错误。

  https://blog.csdn.net/m0_62762847/article/details/127072823

二者可以结合使用

https://zhuanlan.zhihu.com/p/659839223

https://zhuanlan.zhihu.com/p/337536349

https://blog.csdn.net/wangsenling/article/details/124944411

1. **eslint-config-prettier** ：

- `eslint-config-prettier`是一个 ESLint 配置，它的作用是关闭与 Prettier 重复的 ESLint 规则，避免 ESLint 和 Prettier 之间的冲突。
- 当使用 `eslint-config-prettier`时，它会禁用一些与 Prettier 冲突的 ESLint 规则，确保 ESLint 不会干扰 Prettier 对代码的格式化。

1. **eslint-plugin-prettier** ：

- `eslint-plugin-prettier`是一个 ESLint 插件，它的作用是在 ESLint 中运行 Prettier 进行代码格式化，并将格式化结果与原始代码进行比较。
- 当使用 `eslint-plugin-prettier`时，它会在 ESLint 检查代码之前运行 Prettier，如果发现代码格式不符合规范，会将格式化后的代码与原始代码进行比较，并输出差异。
  eslint 作用就是编辑一套适合团队的代码风格，而 `prettier`是自动格式化代码。

  https://blog.csdn.net/weixin_64051447/article/details/128262929

- eslint-config-prettier 会关闭 ESLint 中有关代码格式化的配置，具体参考这里。
- eslint-plugin-prettier 把 Prettier 配置成 ESLint 的一个插件，让其当做一个 linter 规则来运行，可参考其官网。

## npm cnpm yarn pnmp

https://zhuanlan.zhihu.com/p/457698236

https://blog.csdn.net/qq_68086484/article/details/127235359

总结 pnmp>yarn>npm3>npm2 cnpm 是 npm 的国内镜像。

pnpm 安装速度快且会有一个全局 store 来存储包，node_modules 中是引用指向全局 store 中的包。

而 yarn 和 npm 是放到 modules 中把包。

## 使用 TS 时，解决.vue 文件导入时报错说找不到类型

```typescript
// 声明一个模块，用于匹配所有以 ".vue" 结尾的文件
declare module "*.vue" {
  // 从 "vue" 中导入 DefineComponent 类型
  import { App, defineComponent } from "vue"
  // 定义一个类型为 DefineComponent 的变量 component
  // 它具有三个泛型参数，分别表示组件的 props、组件的 data 和其他的类型。
  // 在这里，我们使用空对象（{}）表示没有 props，使用空对象（{}）表示没有 data，使用 any 表示其他类型可以是任意值。
  const component: ReturnType<typeof defineComponent> & {
    install(app: App): void
  }
  // 导出 component 变量，这样其他地方在导入 ".vue" 文件时，TypeScript 编译器会将它识别为一个 Vue 组件
  export default component
}
```

declare module typescript 声明模块的语法。 上面的代码作用就是告诉 ts .vue 也是一个 ts 模块 而不是仅仅只是 ts 结尾的文件才是 ts 模块

d.ts 文件是项目中的类型声明文件。如果想要 ts 能够获取默认类型则需要在 d.ts 文件中声明。

https://www.jianshu.com/p/85bd7e25e1e5

`declare module` 是在 TypeScript 中声明一个模块的语法。它通常用于为 JavaScript 模块（如 npm 包）或其他非 TypeScript 文件（如 Vue 的单文件组件）提供类型信息。这样，在 TypeScript 代码中引入这些模块时，编译器会使用你在 `.d.ts` 文件中定义的类型信息进行类型检查和代码提示。

## Typescript 中使用 ESLint 和 Prettier

https://www.jianshu.com/p/f363337e7c3e

```
npm i -d eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

这三个依赖分别是：

- eslint: ESLint 的核心代码；
- @typescript-eslint/parser：ESLint 的解析器，解析 TypeScript，检查和规范 TypeScript 代码；
- @typescript-eslint/eslint-plugin：ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

```
npm i -g prettier eslint-config-prettier eslint-plugin-prettier
```

- prettier：prettier 插件的核心代码；
- eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prettier 的样式规范为准，使 ESLint 中的样式规范自动失效；
- eslint-plugin-prettier：将 prettier 作为 ESLint 规范来使用。

暂时没有发现不写.prettierrc.js 文件对代码格式化产生的问题，只要配置了 eslint 的配置文件就行.eslintrc.cjs

## ESlint 插件

@vue/eslint-config-typescript .vue 文件支持 eslint ts

@typescript-eslint/parser ts eslint 解析器

@typescript-eslint/eslint-plugin ESLint 插件，包含了定义好的检测 TypeScript 代码的规范。

eslint-plugin-vue .vue 文件 eslint 插件 js

prettier 自动格式化代码

eslint-config-prettier eslint-plugin-prettier 解决 eslint 与 prettier 冲突

安装配置完毕 prettier eslint-config-prettier eslint-plugin-prettier 后便可实现 保存代码自动格式化 eslint 报错的代码。

## Vite 添加 ESLint 支持

需要安装一个插件 [vite-plugin-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-plugin-eslint "vite-plugin-eslint")，在 vite.config.ts 中进行使用。

npm install vite-plugin-eslint --save-dev

```javascript
...
import eslint from 'vite-plugin-eslint' // 新增

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), eslint()], // 新增 eslint()
})

复制代码
```

作用 eslint 本身报错 vite 会忽略编译的时候，浏览器也不会显示，使用了这个插件后，会在终端和浏览器中显示 eslint 的报错

https://blog.csdn.net/qq_41581588/article/details/130052727

ts 下会报错说找不到声明文件，暂没有解决办法，因为是一个比较小众的依赖。

## 一些额外的 eslint

`@babel/eslint-parser` 是一个 ESLint 解析器，它的作用是允许 ESLint 使用 Babel 解析器来解析 JavaScript 代码。通常情况下，ESLint 默认使用 Espree 作为解析器，但有时候我们希望使用 Babel 来解析代码，特别是在涉及到一些新的 JavaScript 语法或者需要支持一些 Babel 插件的情况下。

使用 `@babel/eslint-parser` 可以让 ESLint 在检查代码时使用 Babel 的解析器，这样就可以支持更多的 JavaScript 语法特性，以及使用一些 Babel 插件所带来的好处。这对于在项目中使用了 Babel 进行代码转换的情况下特别有用，可以确保 ESLint 能够正确解析和检查经过 Babel 转换后的代码。

本质这也是一个自定义解析器。

如果要使用自定义解析器（如 @babel/eslint-parser 或 @typescript-eslint/parser），则必须使用该  parserOptions.parser  选项而不是该  parser  选项。因为这个插件需要 vue-eslint-parser 来解析  .vue  文件，所以如果你覆盖这个  parser  选项，这个插件就不起作用。

**diff**  差异

```json
- "parser": "@typescript-eslint/parser",
+ "parser": "vue-eslint-parser",
  "parserOptions": {
+     "parser": "@typescript-eslint/parser",
      "sourceType": "module"
  }
```

这也是为什么我们的配置文件里是"parser": "vue-eslint-parser" 的原因了。因为我们用了自定义解析器也就是 ts 的 eslint 解析器。

vue-eslint-parser 并没有被我们直接安装，而是我们使用安装 eslint-plugin-vue 的时候自带的。

## 为什么配置了组件自动导入了，还会提示找不到组件的类型？

这是由于，如果我们设置了快捷 path 比如 views 那么如果我们直接写 views/xxx.vue 是会报类型问题的，解决办法就是需要声明.vue 的类型。

如果我们通过正常的相对路径的话，则不会有这个问题。

## `tsconfig.node.json`

`tsconfig.node.json` 文件通常用于配置 TypeScript 项目在 Node.js 环境中的编译选项和设置。与普通的 `tsconfig.json` 文件相比，`tsconfig.node.json` 文件是针对在 Node.js 环境下运行的 TypeScript 项目进行特定配置的文件。

一些常见的配置项和用途包括：

1. **目标环境：** 设置 `target` 选项为 `node`，以指定编译后的 JavaScript 代码是针对 Node.js 运行时环境的。
2. **模块系统：** 设置 `module` 选项为 `commonjs`，以确保 TypeScript 编译后的模块系统与 Node.js 兼容。
3. **Node.js 特定库支持：** 可能会配置 `lib` 选项以包含 Node.js 特定的类型声明文件，以便在 TypeScript 代码中使用 Node.js 提供的 API。
4. **其他编译选项：** 可能会根据项目需求配置其他编译选项，如输出目录、源映射、严格模式等。

总的来说，`tsconfig.node.json` 文件用于定制 TypeScript 项目在 Node.js 环境中的编译设置，以确保 TypeScript 代码能够正确地在 Node.js 中运行和执行。

一般用于编译 vite.config.ts。

## vite 与 ts

在使用 Vite 构建 Vue 3 项目时，如果你打算使用 TypeScript 进行开发，通常情况下是需要安装 TypeScript 的。尽管 Vite 内置了对 TypeScript 的支持，并且使用 esbuild 来处理 TypeScript 代码的编译和转换，但 TypeScript 本身仍然是一种独立的编程语言，需要通过安装 TypeScript 包来提供类型检查、语法支持等功能。

因此，为了在 Vue 3 项目中使用 TypeScript，并且能够获得 TypeScript 提供的类型检查和其他功能，你仍然需要在项目中安装 TypeScript 包。你可以通过 npm 或 yarn 来安装 TypeScript：

```bash
npm install typescript --save-dev
# 或
yarn add typescript --dev
```

安装 TypeScript 后，你可以在项目中编写 TypeScript 代码，并利用 Vite 提供的 TypeScript 支持来进行开发。安装 TypeScript 包可以让你在项目中充分利用 TypeScript 的强大功能，同时结合 Vite 的快速构建能力，实现高效的开发体验。

也就是说 vite 只负责转换 ts，不负责语法类型检查，需要 typescript 和 vue-tsc 来检查。

https://blog.csdn.net/qq_29689343/article/details/127187921

vscode 本身支持 ts 校验的，虽然不装 ts 依赖也没关系，但是如果不用 vscode 呢。

https://blog.csdn.net/qq_41579104/article/details/129856763

tsconfig 的配置项说明。

## vite 中的 tsconfig.json 作用

首先就是配置 vue-tsc 的，让他执行的时候进行 ts 代码的规则校验。

至于 compilerOptions 中的配置我发现修改了并不影响最终的打包结果，可能是打包和编译是 vite 做的，而 vue-tsc 的打包需要我们设置 noEmit 为 false 才会输出文件，这个输出的文件才是受 compilerOptions 影响的。

也就是说 tsconfigjson 其实对我们的打包编译影响很小，主要还是做类型校验的。这个单独使用 typescript 开发的时候很有用。

.d.ts 类型声明文件一定要放到 include 下声明的需要编译处理声明的文件目录，否则无效。

## javascript 开启严格模式好处

开启 JavaScript 的严格模式（Strict Mode）可以带来以下几个好处：

1. 更严格的语法和错误检查：严格模式会对一些不规范的语法和错误进行更严格的检查，可以帮助开发者发现潜在的问题并避免一些常见的错误。
2. 提升代码质量：严格模式要求更规范的编码方式，可以帮助开发者编写更加健壮、可靠的代码，提升代码质量。
3. 避免全局变量污染：在严格模式下，禁止隐式声明全局变量，可以避免全局变量污染，提高代码的可维护性和可读性。
4. 提高性能：严格模式下的代码通常比非严格模式下的代码更优化，因为严格模式下的一些特性可以让 JavaScript 引擎进行更好的优化。

总的来说，开启 JavaScript 的严格模式可以帮助开发者编写更加规范、健壮的代码，提高代码质量和性能，避免一些常见的问题和错误。因此，推荐在项目中使用严格模式来编写 JavaScript 代码。

## ESlint 傻瓜式配置办法

https://blog.csdn.net/qq_41581588/article/details/130052727

不需要手动安装一堆 eslint 插件，只安装 eslint 直接 init 初始化一个配置选完就好了，自动安装多个 eslint 依赖。

另外即便选择了 typescript，还是需要手动去配置文件里配置的。

其他一些报错 eslint 的也可以参考这里面的解决办法。

另外，yarn init 和 npm init 执行不一样后者才是初始化 eslint 前者是初始化一个 package.json

可以在 eslintrc.cjs 文件的 rules 下进行配置 关闭一些不需要的配置。

## ENV 文件内部变量新增 ts 提示。

https://cn.vitejs.dev/guide/env-and-mode.html#intellisense

这样 使用 import.meta.env 的时候就有提示了。

## html 中使用 env 中变量

语法是%env 中变量名% 如果没有那个变量 则会显示字符串你使用的内容%env%

## Pinia 支持两种语法 组合式和选项式

组合式和 vue 组合式 api 一样使用 setup 函数然后内部定义响应式变量后 return 出来。

选项式就和 vue 的选项式是一样的，状态写在 state 里，然后最终把每个状态写到这个 store 实例的根属性上。

也不是把状态写到 store 的根属性，实际上是在根属性上为$data(data)，store是$state 加上了代理，直接通过根属性访问等于访问的是 data 或者 state 中的数据源。

打印 vm 中的 this 上的 data 中的根属性，发现其是一个 get get return data[key] 而 methods 中的方法不是 get 而是直接是一个方法。

但是 pinia 不是，他根属性是值，不是 get，他的 state 居然是 get ()=>hot ? hotState.value : pinia.state.value[$id]

vue3 的 data 居然也是 get ()=>publicPropertiesMap[[key](instance)]

单个 store 中的 state 是从 pinia 这个 pinia 应用身上的 state 中根据 id 作为 key 取到的，也就是说咱们所有定义的 state 都存在了 pinia 应用实例身上。

我打印了 vue3 的应用实例 app 发现其身上除了 use provide unmount directive component mount 等等属性和方法外，还有\_component 根组件或者说组件树结构

**\_context**存折全局上下文内容，主要包含如下：

app 自身 components 全局组件

propsCache 存着全局的 props **emitsCache** 全局 emits

optionsCache 存着全局所有组件的 options

倒是没找到缓存全局 data 的 key。

## vue 组件实例扩展

instance（实例） 一个 vue 组件就是一个实例，组件实例对象身上有很多方法。

再 vue3 中 每个组件实例都是一个 proxy 对象，可以通过这个 proxy 对象来获取 data 中的数据与 methods 方法和 computed 计算属性从根属性上。

而这个组件真正的实例对象则存在\_这个属性身上，这个属性和 vue2 的组件实例对象很像都有 uid，data，props 等等。

而 vue 实例 proxy 对象身上除了咱们定义的方法属性外，其他的$data $ el 等属性 都是 get 方法 **() => publicPropertiesMap[key](instance)**（instance） 这个 instance 就是当前组件的*属性 也就是实例 也就是说哪些属性也是通过*这个组件实例身上来获取属性的。

```javascript
const publicPropertiesMap =
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
```

publicPropertiesMap 本质上是一个 Map 数据结构，其中每个属性都是一个方法，方法接受 instance 然后输出对应的内容，其实就是组件 proxy 快速访问实例身上的属性。

而 proxy 根属性上的数据也是 get 获取的 get ()=>data[key] data 也是 vue 内部定义的，方法直接就是方法赋值的。

setup 函数中定义的 data return 后也会出现在根属性上。

但是 setup 语法糖不会。不过 setup 语法糖里的顶层变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用

setup 函数可以直接 return 一个 render 函数，这是一个函数组件可以创建虚拟 dom。语法糖不可以。 attr 参数和 slot 也都是响应式的。

`setup`中返回的数据，还有官网中罗列的 `$el`，`$data`等都可以通过 `this`访问，底层是使用了 `Proxy`作为代理，当组件初始化的时，设置了代理对象。而这一过程中又设置了\_与 `$el`，`$data`等属性，使其可以通过 get 访问到对应的数据。

## pinia 组合式写法

要注意的是 pinia 组合式写的时候可以不用使用 ref 或者 reactive 去定义 state，前提是修改数据时通过 store.xx = 去修改 因为这个是 proxy 对象修改会触发响应式，如果通过 store 中的 function 去修改 state 不行，因为数据不是响应式数据，因此最好我们定义成响应式的，使用的时候 ref 的数据可以不.value，这是由于 `store` 是一个用 `reactive` 包装的对象，这意味着不需要在 getters 后面写 `.value`。 https://pinia.vuejs.org/zh/core-concepts/#using-the-store

## 为什么 vue 组件 data 是函数而不是对象

首先一个.vue 组件 包含了模板 脚本和样式 。

1. 解析：构建工具（如 Vue Loader）会解析 `.vue` 文件，将模板、脚本和样式部分分离开来。
2. 编译：模板部分会被编译成渲染函数，脚本部分会被转换成 JavaScript 模块，样式部分会被处理成对应的样式表。
3. 实例化：在 JavaScript 模块中，会创建一个 Vue 组件实例对象，该对象包含了组件的数据、方法、生命周期钩子等信息。
4. 挂载：最后，将这个组件实例对象挂载到页面上的某个元素上，使其可以渲染出对应的 UI。

而 data 的初始化就在组件实例化这一阶段。

https://www.pipipi.net/38792.html

根据文献与源码，大概能够得知是先有虚拟 dom，后有组件实例的。

https://segmentfault.com/a/1190000041535107?sort=newest

确实先有虚拟 dom 再有组件实例。因为组件实例中会用到虚拟 dom 中的一些属性。

```
createComponentInstance方法
```

```
applyOptions
```

这个方法来给组件实例通过 options 来 apply 方法和 data。

多个相同组件在渲染时用的是同一个 render 函数，也就是.vue 文件编译后的 render 函数，render 函数生产虚拟 dom，同时会创建组件实例，组件实例中的 data 来自于 options 中的 data，methods 中的方法会被添加到组件实例身上，`computed` 选项会被处理为计算属性，也会被添加到组件实例中，可以像普通属性一样访问，但是会根据依赖的数据动态计算。

而这个 options 中的 data 是共享的，一个组件被使用多次是同一个 render 函数调用生产虚拟 dom 的，而这个虚拟 dom 和组件实例的 data 也是取自同一个 options 对象的 data，如果 options 的 data 是对象，那就导致多个组件实例的数据源指向同一对象，因此需要设置一个函数，每次需要实例化的时候调用 data 函数返回一个新的对象。

.vue 组件编译完后会导出一个对象，template 会编译成 render 函数 其他的 options 会原封不动的导出，setup 组件 导出 setup 函数。

后续创建 vnode，创建组件实例都要用到这些 options，因为这个编译好的 sfc 对象是不变的，后续创建组件实例和 vnode 的时候基于这个 sfc 对象的 data，如果 data 是对象，那么数据就会共享，因此要设置成函数。

https://cn.vuejs.org/guide/scaling-up/sfc.html#single-file-components

https://blog.csdn.net/qq_36348403/article/details/136525629

setup 里使用的组件，不会出现在实例的 components 属性中。

https://zhuanlan.zhihu.com/p/612336916

深入组件初始化与响应式。

https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js

vue 源码。

## volar 和 prettier 冲突解决

代码格式化选择默认 prettier。

## letter-spacing

letter-spacing 是可以设置小数的，比如 0.9px 0.8px 设置的是文字间距。

## ::after 伪类元素会受当前元素的 css 影响比如文字渐变色等等，本质上他属于当前元素子元素。

## 文字渐变色

background: linear-gradient(left, #ff0000, #ffff00); // 背景渐变色

background-clip: text; // 以文字的范围来裁剪背景图片 简单来说就是可以做一个带背景的艺术文字效果

-webkit-text-fill-color:transparent; // *text-fill-color*是 CSS3 中的属性,表示文字颜色填充 把裁剪缕空的文字弄透明，这样就可以通过缕空的形状看到背景颜色，这时背景颜色就是字体的颜色

https://www.jb51.net/css/728441.html

## eslint 报错说找不到 ref reactive 方法解决办法

https://blog.csdn.net/webbirds/article/details/127283504

## ts 声明 props 类型且设置默认值

```typescript
// 枚举的声明方式
enum ButtonType {
  default = "default"
}
// 声明泛型propsType
type propsType = {
  // type可传可不传
  type?: ButtonType
}
// 使用vue的语法糖withDefaults声明类型检查props以及default默认值
const props = withDefaults(defineProps<propsType>(), {
  // 这里default要用枚举的方式声明 而不是直接写成"default"
  type: ButtonType.default
})

console.log(props)
```

使用 ts 好处是 vue 自带的 props 校验仅仅针对生产环境，而 ts 编译时即可找出问题。

## linear-gradient 参数学习与使用

inear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。

参数
方法：linear-gradient(direction, color-stop1, color-stop2, ...)

direction：第一个参数表示渐变的方向。其可以是一个具体的角度值如 45deg，或者是具体的方向值如 to top，表示自下而上渐变；to bottom 表示自上而下渐变【默认为 to bottom】，还有 to right、to left 等。

color-stop：渐变色的起止位置，通常是颜色加起始位置百分比。如 red 10%等。

不写起止位置默认去平分。0deg 由下到上渐变，先写的颜色在下，后写的颜色在上。

不写 0deg 默认的由上到下渐变，先写的颜色在上 后写在下 可以认为是 180deg

https://blog.csdn.net/Bekind2010/article/details/130269260

## 双引擎架构 Vite 如何实现？

https://segmentfault.com/a/1190000043784798

开发环境 esbuild

生产环境 rollup 不过代码压缩也用了 esbuild 因为快 rollup 有自己的 ts 编译插件

## vite 预构建

https://cn.vitejs.dev/guide/dep-pre-bundling.html

vite 构建完毕后会在 node_modules 中有缓存，只要不更改如 viteconfigjs 或者删除新增依赖就不会重新构建依赖。 因为依赖常常是不需要被更改的，预构建后会大大提高效率。不必每次都去转换依赖。

https://juejin.cn/post/7310439736828117046?searchId=20240407095912EAA9C5FA0F7CEF7F3563 深入浅出 Vite5 中依赖预构建

## rollup 内置了 ts 依赖插件来打包 ts

## vue-tsc 需要 typescript 依赖

## npm run vite build 过程发生了什么

https://juejin.cn/post/6887013512364130311

rollup 和 esbuild 都会执行 vite.config.json 都会执行其中的 plugin 因此.vue 的转换是 @vitejs/plugin-vue 实现的

## video 不设置大小默认是视频自身宽高

## [Vite 是如何实现 Esbuild 打包的](https://segmentfault.com/a/1190000043980887)

https://segmentfault.com/a/1190000043980887

https://www.jianshu.com/p/7b9fa3a4969b

开发环境是请求发送的时候，vite 服务才开始编译 module 然后返回的，而不是一开始就编译好的。 如果缓存中已存在直接返回已经编译好的。 当然这里不包含已经预构建的依赖，仅针对咱们写的 css 和.vue .js 等文件。

每个组件在客户端被请求的时候都会在头部引入热更新的模块。

## plugin 和 loader 的区别

https://blog.csdn.net/qq_38290251/article/details/134212725

https://blog.csdn.net/baidu_21919557/article/details/134973258

vite 中貌似取消 loader 了，只有 plugin 了

## 为什么 vite 服务浏览器可以使用 ts 文件直接

因为 ts 的响应标头是 text/javascript

另外 vite 自身即可编译 ts 装 ts 依赖是为了使用 vue-tsc 进行类型检查

## 滚动条样式修改

```css
::-webkit-scrollbar {
  // 滚动条宽高  x轴是高度 y轴是宽度
  width: 6px;
  height: 6px;
}
// 滚动条滑块得样式 可以使用背景色渐变
::-webkit-scrollbar-thumb {
  background: linear-gradient(to bottom right, #4d7fff 0%, #1a56ff 100%);
  border-radius: 5px;
}
// 滚动条轨道
::-webkit-scrollbar-track {
  background-color: #ddd;
  border: 1px solid #ccc;
}
// 滚动条两侧按钮
::-webkit-scrollbar-button {
  background-color: #4d7fff;
  border-radius: 5px;
}
// 按钮悬浮样式
::-webkit-scrollbar-button:hover {
  background-color: #999999;
}
```

## [`assetsInclude` 选项](https://cn.vitejs.dev/config/shared-options.html#assetsinclude)

作用是声明可以被 import 导出的资源。

https://cn.vitejs.dev/guide/assets.html#static-asset-handling

https://cn.vitejs.dev/config/shared-options.html#assetsinclude

## enum 类型说明

enum 枚举类型最终编译后是一个对象，而不是数组，另外它的声明方式和对象很像 key value 的形式，如果默认只写 key 则会默认是 key = 0 key = 1 的形式 编译成一个对象。

https://www.jb51.net/javascript/30299895t.htm

枚举想要赋值字符串的时候必须要使用枚举的属性，而不能直接写字符串 否则报错，但是数值可以直接赋值

成员可以是字符串也是数值，不允许使用其他类型的值。

## props 踩雷记录

```javascript
const customClass = {
  small: props.size === "small",
  "super-large": props.size === "super-large",
  default:
    !props.size || props.size === "default" || props.size === "super-large",
  disabled: props.disabled
}
// 这里我声明了一个对象 来保存所有的class 然后template中使用它 但是我发现没有数据驱动视图，原因在于对象中的属性一开始就是固定的了，props在使用时已经变成了值。

// 至于我们使用对象形式父传子 以及template中不写props直接使用props的属性都是可以的
```

## 全局组件用不用最终都会打包进去 因此最好还是按需导入。

## icon 图标自动导入

https://github.com/sxzz/element-plus-best-practices/blob/db2dfc983ccda5570033a0ac608a1bd9d9a7f658/vite.config.ts#L21-L58

```javascript
// 自动导入图标组件
        IconsResolver({
          prefix: 'Icon',
        }),
// 自动注册图标组件
        IconsResolver({
          enabledCollections: ['ep'],
        }),
```

这段配置代码是一个 webpack 插件配置的示例，主要包含了三个插件的配置信息。让我来分析一下这段代码：

1. **AutoImport 插件**:

   - 这里配置了 AutoImport 插件，用于自动导入模块。
   - 在 resolvers 中配置了 IconsResolver，表示使用 IconsResolver 来解析图标。
   - IconsResolver 配置了 prefix 为 'Icon'，表示导入图标时的前缀为 'Icon'。

2. **Components 插件**:

   - 这里配置了 Components 插件，用于处理组件相关的逻辑。
   - 在 resolvers 中配置了 IconsResolver，表示同样使用 IconsResolver 来处理组件。
   - IconsResolver 配置了 enabledCollections 为 ['ep']，表示启用特定的图标集合 'ep'。

3. **Icons 插件**:

   - 这里配置了 Icons 插件，用于处理图标相关的逻辑。
   - Icons 插件配置了 autoInstall 为 true，表示自动安装图标。

总的来说，这段配置代码主要是在配置 webpack 插件，其中 AutoImport 插件用于自动导入模块，Components 插件用于处理组件逻辑，Icons 插件用于处理图标逻辑。IconsResolver 被用于处理图标相关的逻辑，并根据配置参数来解析和处理不同的图标集合。希望这个分析对您有帮助。如果您有任何其他问题，请随时告诉我。

我们配置完毕后 会自动下载安装 ep 模块的 icon 然后就可以通过 i-ep-xx 在组件中使用了 并且需要注意的是不再需要手动安装 element-icon 的依赖了

自动导入是从 iconify 中导入图标的，elementplus 中的 icon 默认基于这个图标库

naiveui 和 antdesign 我看官网没有提供自动导入图标的功能

ep 是一个集合，意思是 elementplus 的 iconify 图标库中的 ep 集合。

## vite-plugin-inspect

vite-plugin-inspect 插件的作用是用于在 Vite 构建过程中检查和调试插件的工具。它可以帮助开发者更好地了解和分析 Vite 插件在构建过程中的执行情况，以便进行问题排查和优化调整。

通过 vite-plugin-inspect 插件，开发者可以查看插件在 Vite 构建过程中的执行顺序、输入输出信息、插件钩子的调用情况等，从而更好地理解插件的工作原理和影响。这有助于开发者调试和优化自定义插件，提高构建过程的效率和质量。

总的来说，vite-plugin-inspect 插件提供了一种方便的方式来检查和调试 Vite 构建过程中的插件，帮助开发者更好地理解和优化他们的自定义插件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

目测可以查看每个插件对源码的编译修改过程，和 svn 有点像，并且可以通过 source-map-visualization 来查看我们写的代码编译后对应的代码关系。

scss 编译成 css，然后编译成 js 返回，不过返回我们的文件后缀还是 scss，在 network 看的话。

并且 css 也会编译成 js 返回给我们。

自动导入默认是绝对路径导入的，编译后才变成相对路径。

ts 文件是 esbuild 编译的。

## yarn install 报错 There appears to be trouble with your network connection. Retrying 解决办法

https://blog.csdn.net/qq_45503196/article/details/127468032

当然，让我为您解释每一行命令的作用：

1. `yarn config list`:

   - 这个命令用于查看当前 yarn 配置的所有设置，包括代理、镜像源等信息。

2. `yarn config delete proxy`:

   - 这个命令用于删除 yarn 的代理设置，如果之前设置了代理，执行这个命令会将代理设置移除。

3. `npm config rm proxy`:

   - 这个命令用于删除 npm 的代理设置，如果之前设置了 npm 的代理，执行这个命令会将代理设置移除。

4. `npm config rm https-proxy`:

   - 这个命令用于删除 npm 的 HTTPS 代理设置，如果之前设置了 npm 的 HTTPS 代理，执行这个命令会将 HTTPS 代理设置移除。

5. `yarn config set registry https://registry.npm.taobao.org`:

   - 这个命令用于将 yarn 的包管理器镜像源设置为淘宝镜像源，这样在安装包时会从淘宝镜像源下载，可以加快包的下载速度。

通过执行这些命令，您可以管理代理设置并将包管理器的镜像源设置为淘宝镜像源，以提高包的下载效率。希望这些解释对您有帮助。如果您有任何其他问题，请随时告诉我。

很好的问题!让我来解释一下 npm 和 yarn 设置代理以及 HTTPS 代理的用途:

1. **设置代理的用途**:

   - 代理服务器可以帮助我们绕过一些网络限制,比如某些地区无法直接访问某些网站或资源。
   - 通过设置代理,我们可以将对这些受限资源的请求转发到代理服务器,由代理服务器来访问这些资源,然后将结果返回给我们。
   - 对于 npm 和 yarn 来说,设置代理可以帮助我们绕过网络限制,从而更顺利地下载所需的包和依赖。

2. **HTTPS 代理的用途**:

   - HTTPS 是一种加密的网络传输协议,用于保护网络通信的安全性。
   - 当我们需要访问使用 HTTPS 协议的资源时,如果直接使用 HTTP 代理可能会出现问题。
   - 此时我们需要设置 HTTPS 代理,让代理服务器能够正确地处理 HTTPS 协议,确保我们能够安全地访问这些资源。
   - 对于 npm 和 yarn 来说,如果需要下载使用 HTTPS 协议的包和依赖,设置 HTTPS 代理就变得很重要。

总的来说,设置代理和 HTTPS 代理可以帮助我们绕过网络限制,更顺利地使用 npm 和 yarn 下载所需的包和依赖。这在某些受限网络环境下非常有用。希望这个解释对您有帮助!如果还有其他问题,欢迎继续询问。

代理是为了脱离网络的限制，以及网站屏蔽。 代理相当于一个中间人的角色可以隐藏真实的 ip 地址，同时还可以绕过可能存在的网络限制。

https://blog.csdn.net/lihefei_coder/article/details/119906244

https://wenku.baidu.com/view/72a0355430d4b14e852458fb770bf78a65293afe.html?_wkts_=1714213019069&bdQuery=npm%E4%BB%A3%E7%90%86%E4%BD%9C%E7%94%A8

如果您已经将 npm 镜像源设置为国内镜像（比如淘宝镜像或者 cnpm），通常情况下是不需要再配置代理地址的。国内镜像源已经帮助您加速了对 npm 包的访问，通常可以满足大部分用户的需求。

但是，如果您在使用国内镜像时仍然遇到网络访问问题，比如下载速度很慢或者无法连接到镜像源，这时可能需要考虑配置代理地址来帮助解决网络问题。代理服务器可以帮助您绕过网络限制或提高下载速度，有助于解决一些网络访问方面的困难。

总的来说，如果您使用了国内镜像并且网络访问正常，通常情况下是不需要额外配置代理地址的。但如果遇到网络问题，可以考虑配置代理来解决。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

## vite 初始化与钩子

https://blog.csdn.net/xiangzhihong8/article/details/130931082

https://blog.csdn.net/u012384510/article/details/124287604

## 为什么已经使用了 Components 插件来自动导入 vue 组件了，但是 autoImport 里还有 include 声明 vue 文件呢？

因为 autoimport 中导入的一些 js 与组件 不属于 components 的范畴 比如 elmessage。

## 为什么已经安装了 element 图标库 使用自动导入图标时候还会自动安装 ep 图标库呢

后经过我测试 不需要安装 element 图标库了。

## inset boxshadow 内阴影 外阴影看起来会改变盒子大小 内阴影不会 阴影本身不会改变元素大小 0 0 0 npx 看起来像是边框

## flex 和 line-height 不会影响不同文字大小在同一容器内垂直位置上居中对齐。

也就是说垂直居中 使用 line-height 不能让文字每一段文字 字号不同大小写不同，但都对盒子中心居中对齐. 文字默认有自己的对齐方式，就是根据文字基线来。

而 flex align-items center 也不能保证 所有文字垂直居中对齐，文字有自己的高度。但总体还是大差不差的。

总结 数字 大写字母 汉字 使用 line-height + **vertical-align**: **middle**;是可以实现文字居中的效果和 flex ac 一样 但小写字母不同 小写字母只是 显示小但是默认其高度是和大写字母一样高的 导致看起来 没有居中对齐而是偏下了，最好的所有文字居中对齐 还得是 flex

https://www.cnblogs.com/BigFatStar/p/13442914.html

## flex 只能保证子盒子位置 但是不能保证子盒子内部的盒子位置

## 自动导入的一些补充

https://blog.csdn.net/weixin_45366616/article/details/134469304

https://blog.csdn.net/qq_38845858/article/details/137112474

https://blog.csdn.net/qq_42611074/article/details/123036252

## template 中函数传参细节

如果 template 中函数传参用到了 ref 那么实参拿到的也是 ref 解包后的参数 不需要.value 了

## ts 变量后边的问号和感叹号区别

例如 form？.xxx 意思是 form 存在才调用后面方法，不存在不调用，!号意思是此时一定不为空直接调用

?.是 js 的不是 ts 的，我才知道

## ？。和？？

在 JavaScript 中，`?.` 和 `??` 是两种比较新的语法，分别表示可选链操作符（Optional Chaining Operator）和空值合并操作符（Nullish Coalescing Operator）。

1. **可选链操作符 `?.`**:

   - 可选链操作符 `?.` 用于简化访问深层对象属性时的代码，避免出现 `TypeError` 错误。
   - 当使用 `?.` 时，如果对象的前一个属性为 `null` 或 `undefined`，则整个表达式会立即返回 `undefined`，而不会继续访问后面的属性。
   - 例如：`obj?.prop1?.prop2`，如果 `obj` 或 `prop1` 为 `null` 或 `undefined`，则表达式会返回 `undefined`，而不会抛出错误。

2. **空值合并操作符 `??`**:

   - 空值合并操作符 `??` 用于提供一种更严格的空值判断，只有在值为 `null` 或 `undefined` 时才会返回其右侧的值。
   - 与传统的逻辑或操作符 `||` 不同，空值合并操作符 `??` 不会将空字符串 `''`、数字 `0` 或布尔值 `false` 视为 `null` 或 `undefined`。
   - 例如：`const result = a ?? b`，如果 `a` 的值为 `null` 或 `undefined`，则 `result` 的值为 `b`，否则为 `a` 的值。

这两种操作符的引入使得 JavaScript 代码更加简洁和易读，同时提高了处理空值和深层属性访问的便利性。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

??对比||的优点是，??只有在一边是 null 和 undefined 的时候才会返回另一侧的值 而|| 则必须另一侧的值不为能转成布尔 false 的值才返回，前者对比后者是可以返回布尔值 空字符串 0 等的 而后者不行。 好处是如果后端返回我们是 0 或者"" 我们也可以认为他返回值了 而不是没有。

## autoimport 配置中 imports 不能直接自动导入只包含一个 export default 的包

比如 axios lodash 这种包只默认导出了一个 export default 会报错 除非手动写成对象形式才行

另外 ts 导出的文件 只可以默认在 ts 类型的中 默认导入 js 不行 同理配置的 tsconfig 中@ 这种别名 也只能在支持 ts 的文件中用 js 不行，除非手动在 tsconfig.json 中设置 allowJStrue

目前发现类型是无法自动导入的，无论是 element 的还是自己定义的以后尝试网上有没有解决办法。

## checkJs 和 allowJs

在 TypeScript 的 `tsconfig.json` 配置文件中，`allowJs` 和 `checkJs` 是两个不同的选项，它们分别用于处理 JavaScript 文件的情况。

1. **`allowJs` 选项**：

   - `allowJs` 是一个布尔类型的选项，用于指定是否允许在 TypeScript 项目中包含 JavaScript 文件（.js 文件）。
   - 当 `allowJs` 设置为 `true` 时，TypeScript 编译器将允许在项目中引入 JavaScript 文件，并对这些 JavaScript 文件进行类型检查和编译。
   - 这个选项通常用于逐步迁移现有的 JavaScript 项目到 TypeScript，或者允许在 TypeScript 项目中使用一些第三方库的 JavaScript 版本。

2. **`checkJs` 选项**：

   - `checkJs` 也是一个布尔类型的选项，用于指定是否对 JavaScript 文件进行类型检查。
   - 当 `checkJs` 设置为 `true` 时，TypeScript 编译器将对引入的 JavaScript 文件进行类型检查，类似于对 TypeScript 文件的处理。
   - 这个选项可以帮助在引入 JavaScript 文件时提供更好的类型检查和代码质量保证。

综合来说，`allowJs` 用于控制是否允许引入 JavaScript 文件，而 `checkJs` 用于控制是否对这些 JavaScript 文件进行类型检查。在需要逐步迁移项目或者引入第三方 JavaScript 库时，可以结合使用这两个选项来更好地管理 TypeScript 项目中的 JavaScript 文件。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

## 有时候自动导入没有生效，原因可能是代码没有编译由于其他报错，需要重新编译一下就自动解决了

## elementplus 中的表单验证 ref 通过 ref 使用泛型可以 通过 Ref 就报错 哦 原因是因为忘记默认 undefined 了

## setInterval 类型是 NodeJs.timeout 赋值给变量复制成这个|null

## axios 返回值类型设置

https://juejin.cn/post/6969070102868131853

## vue3+ts 在获取接口响应数据时，在 ts 中报错 类型“AxiosResponse ＜ any, any ＞”上不存在属性“state”

https://blog.csdn.net/m0_57033755/article/details/128547409

declare module "axios" 扩展 axios

## upload 组件注意事项

upload 组件 file-list 参数不要用 v-model 绑定，要用自定义属性，否则不好控制 file-list 内容 因为 onchange 事件执行在前 v-model 执行在后,另外如果不想让默认的上传列表出来 不能直接设置 file-list = [] 而是要手动 on-change 里设置 file-list = []

## elementplus 表单重置事件

elementplus 表单重置事件 不是重置成表单默认值，而是重置成当前这个表单创建时的初始值。
假如表单创建的时候 form 的值已经变化了 则以 form 的当前值为初始值

## 选中当前元素的后一个兄弟元素与 has

https://blog.csdn.net/sdgfafg_25/article/details/137006174

:has() 可以选择括号內部指定元素的父元素

比如 :has(p) 意思是所有元素内部包含 p 元素的父元素

:has(>p) 意思是所有 一级子元素是 p 的父元素

选择直接（一级）后代元素包含 `<p>`元素的父级标签名是 `div`父元素：

```css
div: has(> p);
```

:has(+ p) 表示 p 前的兄弟元素唯一一个

:has(~p) 表示 p 前全部的兄弟元素

## 文字颜色变化也可以做过度效果 用过度或者@property 或者动画

@property 的用法和正常修改属性一样 hover 的时候只会修改当前的 css 变量 而非全局的 全局的照常用

## 设置盒子宽度从中间往两边展开 简单 flex aligncenter 布局 或者 margin 0 auto 只要让元素在父元素中心 他边宽自然由中心往两侧

## declare module 'axios'

https://blog.51cto.com/u_16213444/7044433

不要忘记导入 AxiosRequestConfig 类型 否则会默认认为 config 是一个 any 类型 从而报错

```typescript
declare module "axios" {
  interface AxiosInstance {
    // config confiog配置类型
    (config: AxiosRequestConfig): Promise<any>
  }
}
```

不能在 axios 类型扩展的时候使用 ResponseType 类型 因为 axios 中有这个 默认会使用这个 不用我们自己定义的

这里的 any 可以换成任意 interface 这样我们 then 的时候 的数据就是这个类型了 舒服了 这样我们解包的 data 就不会被认错 不知道是不是解包的了。

不过 http 封装的地方 use 响应拦截器的回调的第一个参数倒是不知道如果设置 data 类型 不过也无所谓 因为 axios 默认了那个类型是 any 且不会被 ts 报错。

当我们把 promise `<any> 换成interface后 那么 use 响应拦截器第一个参数会和axios.then 的res的类型 保持一致 虽然接口名不同 但类型一样 并且可以获得类型提示。`

另外 想要扩展 module 的时候一并扩展其中的 interface 则要写在 module 中 定义 interface 定义外面无效。

## 判断当前路由是否存在项目中

好多种做法第一种 hasRoute 这个缺点是只能通过路由 name

第二种直接通过 routes 去 some

第三种 **currentRoute** 的 component 是否存在

## TS \_参数 表示这个参数用不到

## history 模式后端配置

这段代码是一个 Nginx 服务器配置文件的一部分，用于配置一个简单的 Web 服务器。让我为您解释一下这段代码的各个部分：

1. `server`：这是 Nginx 配置文件中定义一个服务器块的关键字，表示接下来是一个服务器的配置信息。
2. `listen 8080`：这一行指定了服务器监听的端口号为 8080，表示服务器将会在 8080 端口上接收传入的请求。
3. `server_name localhost`：这一行指定了服务器的域名为 localhost，表示服务器将会响应来自 localhost 的请求。
4. `location /`：这是一个 Nginx 配置中的 location 块，用于匹配请求的 URL 路径。
5. `root 'E:\dist'`：这一行指定了服务器的根目录为 'E:\dist'，表示当匹配到该 location 时，Nginx 会在 'E:\dist' 目录下查找相应的文件。
6. `index /index.html`：这一行指定了默认的索引文件为 /index.html，表示当请求的路径是一个目录时，默认会返回 index.html 文件。
7. `try_files $uri $uri/ /index.html`：这一行定义了 Nginx 在尝试查找文件时的策略。它会依次尝试查找与请求 URI 匹配的文件（$uri）、目录（$uri/），如果都找不到，则返回 /index.html 文件。

综合起来，这段配置文件的作用是配置一个 Nginx 服务器，监听在 8080 端口上，当收到来自 localhost 的请求时，会在 'E:\dist' 目录下查找相应的文件，如果找不到则返回 index.html 文件。这样可以实现一个简单的静态文件服务器，用于提供 Web 页面的访问。希望这个解释对您有帮助！如果您有任何其他问题，请随时告诉我。

https://blog.csdn.net/muzidigbig/article/details/121892336

## 谷歌浏览器禁止跨域解决办法

https://blog.csdn.net/qq_17627195/article/details/129203873

## flex 布局 父元素不设置宽度 默认会铺满 但是子元素默认是内容宽度

## 扩展 window 对象

```typescript
declare global {
  interface Window {
    $message: MessageApiInjection
  }
}
```

https://juejin.cn/post/7154527027599507486

https://www.jb51.net/javascript/320281bmm.htm

declare global 是扩展全局作用域 可以扩展 window String 以及第三方库全局类型

当使用第三方库时,如果该库没有提供类型定义文件(`.d.ts`),可以使用 `declare global` 来声明它的全局类型。

浏览器中有 self 和 globalThis 他们在浏览器中都指向 window

nodejs 有 global 和 globalThis 他指向 node 全局变量 如下

```javascript
<ref *1> Object [global] {
  global: [Circular *1],
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  queueMicrotask: [Function: queueMicrotask],
  structuredClone: [Getter/Setter],
  atob: [Getter/Setter],
  btoa: [Getter/Setter],
  performance: [Getter/Setter],
  fetch: [Function: fetch],
  crypto: [Getter]
}
```

```typescript
declare global {
  interface Window {
    $message: MessageApiInjection
    $appName: string
    $showLoading: () => void
    $hideLoading: () => void
  }
  // 拓展一个全局可用的函数 本质上其还是在window上,只不过上面这种写法使用时前面必须加window，而后者不需要
  function globalFunction(): void
  interface Global {
    myCustomProperty: string
    myCustomMethod(): void
  }
}
```

总结起来，`self` 在浏览器环境中指向全局的 `window` 对象，`global` 是非标准的全局对象，而 `globalThis` 是在 ECMAScript 标准中引入的通用全局对象，可用于访问全局作用域无论是在浏览器还是其他 JavaScript 运行时环境中。

因此我们扩展 window 变量的时候，需要 declare global 因为 window 属于 global 的子集

https://www.jianshu.com/p/3e3029000629

ts enum 枚举不仅会定义类型 还会导出一个对象 但 interface 不会

并没找到 globalThis 变量的拓展方法 只有 window 和全局的拓展

globalThis 可以在浏览器 webworker nodejs 三端通用 分别指向他们对应的全局变量

## TS — 命名空间的定义

https://blog.csdn.net/sjsjsjsj1010/article/details/129988212

命名空间最终会转换成一个对象

## 同时配置 alias 目录和相对路径目录相同时 vite 优先使用前者 除非手动指定相对路径./ 不写./ 默认前者

## new URL 定义文件导入路径的时候，正常应该.href，如果没有.href，使用的时候 template 中会自动使用.href 但 ts 会报错。

## 浏览器会把 0.1 和 0.9 的 border 渲染成 1px 想要小数 border 需要用盒子宽度做 比如 before 伪元素

https://www.cnblogs.com/ranyonsue/p/17236067.html

## flex: 0 0 xxpx / 3 的原理是什么

flex 属性是一个整合属性包括了[flex-grow**](https://m.baidu.com/s?word=flex-grow&sa=re_dqa_zy)、[flex-shrink**](https://m.baidu.com/s?word=flex-shrink&sa=re_dqa_zy)和[flex-basis**](https://m.baidu.com/s?word=flex-basis&sa=re_dqa_zy)三个部分

flex-grow 表示当前元素 占用父元素剩余空间的比例

[flex-shrink](https://m.baidu.com/s?word=flex-shrink&sa=re_dqa_zy) 表示缩放比例

flex-basis 表示当前元素占主轴大小的初始值,优先级高于 width 低于 flex-grow

https://answer.baidu.com/answer/land?params=1U1qENvXv%2BoPp5DJ4v%2FK3vpMBZGBNI8sHOVbdbTJD4ZjvJonwTdcCm0RMR1jIYHhQmhaKhxEJeyhIGvs82SMzc9aKE9xLmO7Jsu5RCAqTk3xVKaNd5tJYFznubx7kxuCRQxCpbrxlz%2BKxD%2BSjEKZ1Ha87Zrc04Z771JCa0RvQSQGdJm7qL7dm80HT5KCPMykFLvcJMEA5B47VdrTUvot8A%3D%3D&from=dqa&lid=d86e765d0056df00&word=css%20flex%E5%B1%9E%E6%80%A7

## new URL 也可编译 tsconfig 中的 alias src 也可以 background 也可以 除了 cesium 中的路径不行

也就是配置的路径

## html 横向纵向滚动条样式分别设置

在 WebKit 浏览器中，实际上并没有 `::-webkit-scrollbar-y-thumb` 和 `::-webkit-scrollbar-x-thumb` 这样的伪元素。要设置滚动条的滑块样式，您需要使用通用的 `::-webkit-scrollbar-thumb` 伪元素，并结合 `orientation` 属性来区分纵向和横向滚动条。

以下是正确的示例代码：

```css
/* 纵向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  width: 12px; /* 纵向滚动条宽度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 纵向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:vertical {
  background: #888; /* 纵向滚动条滑块颜色 */
}

/* 横向滚动条样式 */
/* WebKit浏览器 */
::-webkit-scrollbar {
  height: 12px; /* 横向滚动条高度 */
}
::-webkit-scrollbar-track {
  background: #f1f1f1; /* 横向滚动条背景颜色 */
}
::-webkit-scrollbar-thumb:horizontal {
  background: #888; /* 横向滚动条滑块颜色 */
}
```

通过在 `::-webkit-scrollbar-thumb` 中使用 `:vertical` 和 `:horizontal` 伪类，可以分别设置纵向和横向滚动条的滑块样式。这样就可以实现分开设置纵向和横向滚动条样式的效果。

## 有时候设置 flex align-items center 发现图片和文字无法居中对齐。

原因是因为字体会有自己的 line-height 默认的， 在这个 line-height 里文字可能不是在最中心的，因此最好单独设置 line-height 与父盒子相等，不过要视情况而定。

https://blog.csdn.net/lucklymm/article/details/125523258

## flex 多行布局 侧轴样式设置

https://blog.csdn.net/shulianghan/article/details/130547207

align-content 样式说明

## 盒子装载图片时出现的盒子比图片实际偏高的问题

https://blog.csdn.net/m0_51404378/article/details/121095574

## 监听滚动事件与设置固钉 原生写法

```typescript
const quickActions = ref<HTMLElement>()
onMounted(() => {
  bodyHeight.value = document.body.clientHeight + "px"
  // scroll事件的触发对象只能是 window document 或者有滚动条的盒子
  window.addEventListener("scroll", function () {
    // 根据滚动 不停修改滚动条位置
    quickActions.value!.style.top = `calc(${window.scrollY}px + 50vh - ${
      quickActions.value!.offsetHeight / 2
    }px)`
  })
  quickActions.value!.setAttribute(
    "style",
    `top: calc(50vh - ${quickActions.value!.offsetHeight / 2}px)`
  )
})
```

## nth-child 和 nth-of-type

nth-child 想要选中某个元素 前面跟想要选中的元素 意思是选中这个父元素中第 n 个元素且这个元素是 我们前面规定的元素。 位置+类型必须一致

而 nth-of-type 放在需要被选中的元素后面使用 意思是父盒子中第几个当前类型的元素被使用，它指的是当前元素。位置不一致 类型一致就行 因为位置是父元素中第 n 个类型符合的元素

nth-last-child 和 nth-last-of-type 是从后往前数。

## 前端配置 VITE_APP_BASE_API 作用

开发环境默认配代理路径就行，开发时会请求本机地址然后通过代理访问后端服务。

生产环境上线地址配置为空 或者/ 默认就会请求项目的服务器所在地址 后端会通过 nginx 转发到真实的后端服务地址。

如果后端不想 nginx 转发，则需要我们上线时把地址写死（那不还是会出现跨域问题），能后端会把不同地址都配置成请求他本地测试吧。

## z-index 只能搭配 定位使用 绝对定位 相对定位 固定定位

相同父元素下 z-index 值越大 优先级约高 不同父元素下 先比较父元素的 z-index 谁大谁优先级高

## typscript 的面向对象以及多态重载说明

https://blog.csdn.net/hzether/article/details/134889424

多态就是继承与方法重写

重载就是根据参数不同执行方法的分支也会有所不同

ts 更多使用教程

https://blog.csdn.net/qq_47040462/article/details/132367100

## 前端工程化学习笔记

https://www.kancloud.cn/cyyspring/webpack/3079670

nodejs 中 全局作用域下 this 指向空对象 mjs 下指向 undefined

core-js 是完全模块化的 javascript 标准库。 包含 ECMA-262 至今为止大部分特性的 polyfill，如 promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的 WHATWG / W3C 特性的 polyfill，如 WHATWG URL。 它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入 core-js，仍然使用最新特性的 ES 写法编码即可；也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入 core-js 的相关 module，并可能还需要通过手工调用 module 完成编码，没法直接使用最新 ES 的写法。它是一个完全模块化的库，所有的 polyfill 实现，都有一个单独的 module 文件，既可以一劳永逸地把所有 polyfill 全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的 core-js 的 modules 文件。

注意 core.js 与 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill 的关系

babel-plugin-transform-runtime 是用来编译转换代码的 用到一些 ES 的方法 他会自动从 babel-runtime 中导入使用工具函数 以及其他一些 babel-runtime/corejs 中的 polyfill

babel-polyfill 基于 core-js 他是对 es6+方法的转换用 es5 的语法去实现他们，以及内置对象身上的方法。

`import "@bable/polyfill"` 的方式来实现针对 api 层面的“抹平”。然而从 babel v7.4.0 开始官方就不建议采取这样的方式了。

因为不能按需导入+污染全局变量。

现在 Babel7 的 presets 对 babel-polyfill 做了处理，新增"useBuiltIns": "usage"，这样只会加载代码中用到的部分，完美的按需加载，但是依然会污染全局变量。

babel-runtime 中也包含 polyfill，准确来说是 core-js，也就意味着 babel-runtime 和 babel-polyfill 二者有其一就可以了。

`babel-runtime` 不能转码实例方法比如

```
!!!'.repeat(3);
'hello'.includes('h');
```

这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。

随着历史进程的发展，新一代的 [babel-prenset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmaster%2Fpackages%2Fbabel-preset-env "https://github.com/babel/babel/tree/master/packages/babel-preset-env")出现了。

babel-runtime 使用与性能优化

https://juejin.cn/post/6844903615212027917

用了 babel 还需要 polyfill 吗？？？ https://juejin.cn/post/6845166891015602190?searchId=20240425105812792820EAF0C597F91626

关于 babel(精华又通俗) https://juejin.cn/post/6844904199554072583

结合 Babel 7.4.0 谈一下 Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879

babel-polyfill VS babel-runtime VS babel-preset-env

https://juejin.cn/post/6844903602822053895

前端工程化（7）：你所需要知道的最新的 babel 兼容性实现方案

https://juejin.cn/post/6976501655302832159

webpack 入门之 js 处理(babel、babel polyfill)

https://juejin.cn/post/7126465727178997791?searchId=20240425105812792820EAF0C597F91626

结合 Babel 7.4.0 谈一下 Babel-runtime 和 Babel-polyfill

https://juejin.cn/post/6844903869353295879?searchId=20240425105812792820EAF0C597F91626

实例探究 Babel 及 Babel 与 Webpack、Vue 之间的关系

https://juejin.cn/post/7051555571451265038?searchId=20240425105812792820EAF0C597F91626

@babel/preset-env 只支持语法转换比如箭头函数转普通函数，let const 转 var。 api 则需要 core-js 或者 babel/polyfill 或者 babel/runtime-corejs 来转换了。

@babel/preset-env babel7.0.0 之前的话一开始如果只使用 core2 的话 无法 polyfill 内置方法，还需要安装 babel/polyfill。 如果使用 core3 则不需要使用 babel/polyfill

并且 babel/runtime-corejs3 可以模拟实例或者说原型对象上的方法，而 babel/runtime-corejs2 不可以。

babel/polyfill 虽然也可以 但是被废弃了。

babel 一开始是会编译代码的，随着新版 babel 的发布，babel 的编译功能交给了插件，自身只作为一个平台，如果不安装任何插件 babel 编译的结果和源码是一样的。

配置 babel 有两种，插件(`plugin`)或者预设(`preset`)。 编译时插件会先执行，预设后执行。

@babel/preset-env 就是一个预设。他默认不会转义内置方法，需要搭配 babel-polyfill，他会对高级语法进行降级

babel/runtime-corejs2 不支持实例方法，3 支持。

babel/core 在转义代码的时候 是要使用插件去处理的。

`@babel/preset-env`本身在语法转换的时候，会使用一些辅助函数来实现一些语法的模拟。而事实的确，这只是一种语法转换。 也就是说 class 辅助函数是 `@babel/preset-env` 语法降级时候定义的。

`_classCallCheck` 是 Babel 编译后代码中的一个辅助函数，用于实现类的构造函数中的类似于 ES6 类中 `this` 的检查和初始化。这个函数通常是由 Babel 插件 `@babel/plugin-transform-runtime` 插入到编译后的代码中的。

在 ES6 类中，如果没有正确使用 `super` 关键字调用父类的构造函数，或者在构造函数中没有正确初始化 `this`，就会导致错误。为了处理这种情况，Babel 在编译 ES6 类时会插入 `_classCallCheck` 函数来确保正确的类继承和初始化。

因此，`_classCallCheck` 并不是 JavaScript 或 ES6 标准中的原生方法，而是 Babel 在编译过程中生成的辅助函数之一，用于确保类的正确使用和初始化。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

在使用 Babel 进行 JavaScript 编译时，`babel-runtime`、`babel-plugin-transform-runtime` 和 `babel-polyfill` 是三个常用的工具或插件，它们在项目中扮演着不同的角色：

1. **babel-runtime**：

   - `babel-runtime` 是 Babel 提供的一个运行时库，用于支持编译后代码的运行。它包含了一些 Babel 编译后代码中使用的辅助函数，例如 `_classCallCheck`、`_extends` 等。
   - `_classCallCheck`、`_extends`不是 babel-runtime 生成的，而是 babel 语法转换时自己生成的，但是 babel-runtime 中提供了封装好的函数供导入用。
   - 使用 `babel-runtime` 可以避免在每个编译后的文件中重复生成这些辅助函数，减小编译后文件的体积。
   - 通常通过安装 `@babel/runtime` 包来使用 `babel-runtime`。

2. **babel-plugin-transform-runtime**：

   - `babel-plugin-transform-runtime` 是一个 Babel 插件，用于在编译过程中将代码中的公共辅助函数替换为 `@babel/runtime` 包中的对应函数。
   - 这个插件可以帮助减小编译后代码的体积，并且避免在每个文件中重复生成相同的辅助函数。
   - 通过在 Babel 配置中添加该插件，可以实现对编译后代码的优化。

3. **babel-polyfill**：

   - `babel-polyfill` 是一个用于提供对新的 JavaScript 特性的兼容性支持的包。它会在全局作用域中注入一些缺失的 ECMAScript 特性和内置对象的方法，以便在旧版本的浏览器中运行新的 JavaScript 代码。
   - 使用 `babel-polyfill` 可以解决一些新特性在旧浏览器中不被支持的问题，但它会增加项目的体积。
   - 在使用 `babel-polyfill` 时，需要在代码中引入它，通常是在应用程序的入口文件中引入。

总结：

- `babel-runtime` 是 Babel 提供的运行时库，包含一些辅助函数。
- `babel-plugin-transform-runtime` 是一个 Babel 插件，用于优化编译后代码中的辅助函数。
- `babel-polyfill` 是用于提供对新特性的兼容性支持的包，在旧浏览器中运行新的 JavaScript 代码时可能会用到。

希望这个解释对您有帮助。如果您有任何其他问题或需要进一步解释，请随时告诉我。

## HTML+CSS 动画网

https://uiverse.io/Amerss/massive-robin-70

https://zhuanlan.zhihu.com/p/683609906

## 扩展 axios 请求 config 类型

https://www.cnblogs.com/qh1688/p/17457625.html

直接在扩展 axios module 的时候 export interface 想要扩展的属性就完事了 因为 interface 本身就支持多个 interface 合并

## VSCode 噴 Unknown at rule @tailwind 解決方式

https://israynotarray.com/tailwindcss/20220405/1504568293/

## tailwind 样式与自定义样式冲突解决办法

tailwind 样式导入放最前面，让自己的覆盖他

## css 的 attr()方法

可以通过 attr 使用当前元素身上的的属性 但测试目前好像只有 content 属性支持这个方法。

## unity 打包出来的 h5 文件和 cesium 一样，需要本地托管一个服务才能跑起来，直接双击 html 运行的话不可以会报警告。

我知道了 通过 xhr 或者 fetch 去请求本地文件 如果是 http https 请求给通过，如果是 file 模式本地会报错

Access to XMLHttpRequest at 'file:///C:/Users/Administrator/Desktop/study-jk/%E6%B5%8B%E8%AF%95js%E7%9A%84%E8%AF%BB%E5%8F%96/a.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

这是浏览器为了安全设计的。

https://www.cnblogs.com/tuyile006/p/15619697.html

## 定位一些踩坑

定位的元素 如果不设置宽高 默认是被内容撑开 没内容那宽高就是 0

如果定位的盒子 宽高是由内容撑开的 而恰好装他的父盒子没有宽高且必须是定位（单纯没有宽高不行），因为定位是相对于父元素的，那么定位的子盒子中的内容会竖着显示，如果是英文不受影响，因为英文单词很长本身就不会自动换行，中文的话会竖着显示，一行显示一个字，如果有逗号则最多显示两个字。 具体原因尚不明确。火狐也是这样。

如果子元素有长单词 那么子元素宽度会被撑开，即便设置了**word-wrap**: **break-word**; 也不能影响被撑开的子元素。

首先元素宽度不够 文字是的确会默认换行的，子元素遵循子绝父相，如果父元素没有定位则向上找，而向上找不存在文字伸展不开，但如果父元素宽度 0 且定位 那么子元素确实内容伸不开会换行。 因为他宽度不能超过父元素。

汉字之间会被视为一个个独立的字符，每个字符都会占据一定的宽度。由于汉字的宽度一般大于字母和数字，因此当一行放不下更多的汉字时，汉字就会自动换行。

英文和数字不会自动换行 需要设置 **word-wrap**: **break-word**;

word-break 属性规定自动换行的处理方法。

| normal    | 使用浏览器默认的换行规则。     |
| --------- | ------------------------------ |
| break-all | 允许在单词内换行。             |
| keep-all  | 只能在半角空格或连字符处换行。 |

word-wrap word-wrap 属性允许长单词或 URL 地址换行到下一行。

white-space 属性设置如何处理元素内的空白。

white-space 管的文字一行上不会换行强制不换行 遇到空白不会换行。word-warp 管的是长单词该不该换行，二者功能不重叠。

## 一些面试题

https://zhuanlan.zhihu.com/p/69723829?utm_id=0

## 浏览器加载图片和视频的时候默认的处理方式

图片和视频由于都是二进制流，因此浏览器默认是下载一点就展示一点。

## 「白话前端」快速区分 webGL，webGPU，unity3D 和 UE4

https://baijiahao.baidu.com/s?id=1782882451057013215&wfr=spider&for=pc

## el-table 覆盖了 el-image 处理办法

https://blog.csdn.net/CycleByle/article/details/135993703

https://blog.csdn.net/yusha123/article/details/106327893/

## 解决 VUE keyup.enter 和 blur 绑定同一事件，触发两次的问题

https://blog.csdn.net/qq_46264882/article/details/119344643

https://www.cnblogs.com/imPedro/p/12811781.html

https://www.jb51.net/article/265737.htm

## 为什么 el-input 的 blur 事件 是 input 触发的 click 也是 input 触发的

因为这些事件都是 element ui 自己封装的自定义事件 而不是原生事件，而这个自定义事件被子组件接受 子组件接受并触发传参的。 所以我们接受的也是 input

## getCurrentInstance

getCurrentInstance 获取的是当前组件的实例，在他的 appContext 属性里可以获取 app 应用的配置信息。

`getCurrentInstance().proxy` 是一个用于获取当前组件实例的代理对象的函数。它返回的是当前组件的代理对象，您可以通过这个代理对象访问组件实例的属性、方法以及生命周期钩子。

而我们可以通过 `proxy`访问到 app.config.globalProperties 上的属性，我想原因可能是 proxy 代理 访问某个属性触发 get 在 get 里进行了某些处理。

不过这个 proxy 代理的对象本身还是一个 defineProperty 对象。

## elementplus 2.6 以上版本 radio 通过 value 绑定值了 2.6 以下 label

el-select option 的 label 需要自定义属性绑定到 el-option 上 如果通过插槽不写自定义属性的话，那么选中 option 后 el-select 展示的是 value 而不是 label 因为 label 只是 option 的插槽 而 select 没办法拿对应的 value 去比对拿对应 item 项中指定 label 项的某个值作为 label

## vue 事件与原生事件传参

原生事件 addeventlistener 第一个参数是事件名称，第二个参数可以是一个 function 也可以是一个 function 名 也可以是一个函数执行产生另外的一个函数。onclick 同理。

绑定在 html 身上的原生事件 例如 onclick 必须是函数执行或者是表达式或者代码片段 而函数执行必须传参 函数形参才有参数。

而 vue 的事件 无论是 vue 原生事件还是自定义事件 既可以放函数名 也可以放函数调用 只放函数名的话，会执行函数，并可以接受参数 e，如果放的是函数表达式那么还可以放形参接受实参传递给函数式内部扩展参数，如果想要拓展自定义事件的回调函数中的参数，则可以采取自定义事件回调函数定义在事件触发的地方接受形参然后在函数内部书写真实函数并扩展参数。

记住函数调用才传实参，定义函数传形参。

## el-upload change 事件除了有自己的回调参数还有 event 事件对象 这个对象有三个 点击 change 和进度

## 上传 读取 文件转换这种 最好都封装成 promise 例如 file 转 base64

```javascript
export default function (file) {
  const reader = new FileReader()
  reader.readAsDataURL(file)
  return new Promise((resolve, reject) => {
    reader.onloadend = function () {
      resolve(reader.result)
    }
    reader.onerror = function (err) {
      reject(err)
    }
  })
}
```

## loading=lazy

在 HTML 中，`loading` 和 `loading="lazy"` 是 `<img>` 标签的两个属性，用于优化页面加载性能和用户体验：

1. `loading` 属性：

   - `loading` 属性用于指定在图片加载过程中显示的加载行为。它可以设置为以下三种值之一：
     - `auto`：默认值，浏览器自动选择加载行为。
     - `eager`：立即加载图片，不考虑视口内外。
     - `lazy`：延迟加载图片，只有当图片进入视口时才开始加载。

2. `loading="lazy"`：

   - `loading="lazy"` 是 `loading` 属性的一种取值，表示延迟加载图片。当设置为 `lazy` 时，浏览器会等到图片进入视口范围内时才开始加载图片，从而减少页面的初始加载时间和带宽占用。
   - 使用 `loading="lazy"` 可以帮助提高页面的加载性能，特别是对于包含大量图片的页面或长页面来说，延迟加载图片可以减少不必要的网络请求和加快页面加载速度。

总的来说，`loading` 和 `loading="lazy"` 属性可以帮助优化页面加载性能，提升用户体验。通过合理设置加载行为，可以在保证页面内容完整性的前提下，尽可能减少不必要的资源加载，从而加快页面加载速度。希望这个解释对您有帮助，如果有任何疑问，请随时告诉我。

## el-upload 上传图片够数了就隐藏掉上传按钮的做法

官方并未提供这个属性，因此必须我们自己去想办法，首先是 v-bind css 绑定给 el-upload 类 当上传添加到 filelist 或者 form 中后 则修改 v-bind 的值 删除时再修改，这种做法在低版本的 vue 比如 3.3.9 中不生效 编译后的 css 变量 不存在。

https://www.jianshu.com/p/e93259c4ee3e

不是低版本 vue 的问题 而是 append-to-body 的问题

第二种做法 https://blog.csdn.net/qq_62262918/article/details/135026917

通过 disabled 属性 来给 el-upload 增加类 然后 disabled 的类设置隐藏。 这种缺点是图片无法删除了

## Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead

避免依赖于枚举组件实例上的键的应用程序逻辑。密钥在生产模式中将为空，以避免性能开销

我本来以为是什么问题呢，后来发现是这一句代码出了警告

这里咱们通过 const { proxy } = getCurrentInstance(); 获取了当前组件的实例，只能从组件实例身上拿去属性，而不能对他执行逻辑操作，否则 vue 就会弹出警告。

这里应该是 proxy 进行了处理 只要去遍历或者其他一些逻辑操作 就会报出警告 目前测试 修改 新增 删除属性不会报错 遍历会报错 forin keys 获取所有属性标识符等都会 这里暂时不知道是如何做到的，了解即可。

猜测是对 proxy 整个对象进行了检测或者什么的吧，自己写的 handle 没有触发。

```javascript
console.log(Object.getOwnPropertyDescriptors(proxy))
```

## el-upload 默认不自带图片放大预览 需要手动使用

难道我的记忆出现错乱？

## el-upload filelist 作用

图片预览列表理论来说是用不到 filelist 这个自定义属性的，但是为什么我们需要他呢，是因为只要上传图片别管成功没成功默认 elementplus 都会把本地图片作为 list-file 显示在 文件列表，前提是没有写 file-list 这个属性，当我们有了文件服务器 则每张图片上传时需要判断是否成功了有才会往 filelist 里 push 然后绑定给 upload 组件实时显示图片

但是也需要 filelist 因为编辑页面会重服务器拿 然后渲染

## el-form resetFields 没有重置

原因 1 model 没有设置

原因 2 每个 item 的 prop 没有设置

## dialog closed 事件触发条件

1 点击 x

2 设置 v-model 得那个值为 false

## axios 响应拦截器说明

axios 相应拦截器成功函数执行时机是 status 为 200 成功的时候 而错误回调是 status 不等于 200 的时候

## 更多 axios 使用

http://www.axios-js.com/zh-cn/docs/ 文档比较老，有些配置或许不能用了

https://blog.csdn.net/u010494753/article/details/135583465

这里是 xhr fetch 和 axios 分别取消请求的方式

xhr.**abort**(**)**;//取消请求

fetch 是通过**new**AbortController(**)**;

axios 通过 axios.**CancelToken**.**source**(**)**;

## JavaScript 包管理工具对比：npm、Yarn、pnpm 和 Bower

https://juejin.cn/post/7261783831057121335?searchId=202405081024293AB014D7C535BEF0DA76

Bower 简介

https://juejin.cn/post/6844904158395367431?searchId=202405081024293AB014D7C535BEF0DA76

npm、bower、jamjs 等包管理器，哪个比较好用？ - 尤雨溪的回答 - 知乎
https://www.zhihu.com/question/24414899/answer/28021471

npm1、npm2 采用递归管理，npm3、npm3+、yarn 依赖扁平化管理消除依赖提升。

pnpm 依赖策略：消除依赖提升、规范拓扑结构

https://blog.csdn.net/snowball_li/article/details/124787870

https://blog.csdn.net/m0_69551472/article/details/136932567

pnpm 会在这个存储目录中创建 hard links，这样多个项目可以共享同一份依赖包的实际文件，而不是每个项目都存储一个副本，从而节省磁盘空间。

https://baijiahao.baidu.com/s?id=1786851423161937048&wfr=spider&for=pc

幽灵依赖 是什么

## 成为一名前端架构师

https://juejin.cn/post/6844904054896721934?searchId=202405081024293AB014D7C535BEF0DA76

## pnpm 构建 vue3 项目+eslint .prettier 配置

https://blog.csdn.net/weixin_59816940/article/details/131395326

## 传参是传参，event 是 event，函数没有传参的情况下，传参数默认是事件对象，函数如果回调有参数那么以实参为准此时可以通过 event 来访问事件对象，另外 vue 的无论是自定义事件还是原生事件，无论传不传事件对象，最终通过 event 都能够获取正确的事件对象。

除非这个事件找不到事件触发对象，比如计时器，就算是我们用 watch 监听数据变化发生的事件，vue 也会找到触发这个数据变化的操作事件传递 event

## vuedraggableplus change 和 move 事件说明

onMove 拖拽移动的时候触发 触发频率和 onchange 一样必须换位置才会触发。但 onMove 可以去控制 拖拽生不生效 return false 不生效 return true 生效

onUpdate 必须是松开鼠标了才触发。 需要注意的是 move 无法获取到被拖得元素以及要放得元素得位置

为什么不能用 onUpdate 或者 记录位置 原因是因为 如果是从第一个拖拽和第三个交换 那么第二个会跑到第一个去 此时第一个不再是之前得第三个 而是第二个 那么我们存的新旧的就变成 第二个和第一个 然后再还原的时候 就变成了第二个第三个之交换位置 第一个值跑第二去了的 bug

## Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组。

这个数组可以解构 key 是索引 0 所在的元素 value 是索引 1 所在的元素

## pinia vuex 这种都是面向对象的编程思维。

属性 方法，方法修改属性，一个对象就是一个独立运行的模块。

## js 获取浏览器高度和宽度

https://www.cnblogs.com/easirm/p/4205155.html

https://cloud.tencent.com/developer/article/2107920

scrollheight 获取对象的滚动高度 和 scrollTop 的区别

window.getComputeStyle(obj).height

## 计算机组成原理 栈堆 线程进程 对象

## defineEmits 可以不传参数 但 defineProps 必须传

不传参数得缺点是没有类型提示。

## el 表单组件 model-value 与 v-model 的区别 在于前者是受控模式 后者是双向数据绑定

前者受数据绑定状态 比如 switch 只有数据修改了 switch 才会变 而后者数据和状态同时变 属于非受控模式

https://cloud.tencent.com/developer/article/2414134

受控与非受控。

## el 级联选择器 配置父子不关联和 是否数据返回数组

在 props 这个自定义属性里。 而不是组件身上

el 级联选择器获取 当前选择的 node ref.getCheckedNodes() 获得的是一个数组 数组第一项也仅有一项是当前选择的 node 其内部又 parent 可以看父级 node 也有 children 看子 node

## el-form 中只有一个 el-input 的时候 回车触发页面刷新表单提交

https://blog.csdn.net/weixin_46504400/article/details/138300630

是因为 el-form 一个比较智能的判断 如果表单上只有一个输入框 则在输入框上按回车 表单就会自动提交 且刷新界面

老实说 挺奇葩的 这个智能的判断 很多时候都会成为智障 因为大部分人都不需要这个功能 且很多时候会给大家带来问题 这个问题还不容易发现

解决办法就是 在 el-form 上加上@submit.native.prevent 防止事件冒泡

## el-form rules 的 trigger 时机

无论是 change 还是 blur 触发时机都是针对 表单的触发事件 比如 blur 比如 change 而动态增加移除表单组件 不会触发

## v-model 可以绑定响应式对象的值，也可以绑定响应式数组的值

v-model 不能用于 v-for 或 v-slot 作用域变量，因为它们不可写，但是可以绑定 v-for 的 item 内部的值。

如果 v-for 的响应式数组 里的每一个索引对应的是字符串而不是对象 那么通过 v-mode 绑定数组[index]后也是双向绑定的

## elementplus 中的 el-tree 收缩树所有节点的做法

```javascript
for (const key in tree.value.store.nodesMap) {
  if (Object.hasOwnProperty.call(tree.value.store.nodesMap, key)) {
    const element = tree.value.store.nodesMap[key]
    element.expanded = false
  }
}
```

## 我们定义的一些 css 类可能会和 tailwindcss 产生冲突

https://blog.csdn.net/weixin_51076986/article/details/132564486

https://article.juejin.cn/post/7251609043953188925

我的意见是要不给自己的样式全部加 important

要不就一开始用 tailwindcss 不要中途用。

tailwindcss 需要搭配 postcss 用 并且安装完毕这两个依赖 需要去配置一下

postcss.config.js

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}
```

tailwind.config.js

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx,vue}"],
  theme: {
    extend: {}
  },
  plugins: []
}
```

## proxy 的 rewrite 第二个 参数 写多少个// 都无所谓 vite 会自动处理

## v-model 也会触发依赖收集 前提是 这个数据获取的方式必须触发 proxy 的 get 也就是响应式数据 而直接 v-model = 数值的话 则不行

v-for 循环时 input v-model 双向绑定时遇到的。 自定义属性也同理

## 路由 404 的另外一种实现方式

一种是我们在路由导航守卫里做，如果当前的路由获取不到则跳转 404 另外一种更简单直接指定所有路由跳转 404 使用 path**:**'/:pathMatch(._)_'**,** 但是他的优先级低于我们通过路径配置的路由 因此他常用作匹配未定义的路由 跳转 404.

```javascript
const routes = router.getRoutes()
const isTrue = routes.some((item) => item.path === to.path)
if (!isTrue) {
  router.push("/notfound")
}
```

路由如果重复定义，以第一次为准。

在开发中，当前已存在的的 api 或者方法的性能大概率是要比我们手写的性能更好的。但也不一定绝对。

https://blog.csdn.net/XiugongHao/article/details/132715778 path: '/:pathMatch(.)\*'作用

https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-Not-found-%E8%B7%AF%E7%94%B1

pathMatch 是参数，这个可以是任意值 只不过最终存在路由的 params 中的 key 有所区别。

是的 路由传参的时候 这个类似于形参占位符可以是任意字符串。

传参不同 匹配路由也不同 也可通过传参去区分匹配路由

https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html

路由有两种跳转方式 一种是 path 一种是对象 对象里可以使用 name 和 params 跳转 也可对象里用 path

在路由配置中，"sensitive" 和 "strict" 是两个常见的选项，用于控制路由匹配的敏感度和严格性。

1. Sensitive（敏感）：当设置路由的 sensitive 选项为 true 时，路由匹配将会对大小写敏感。也就是说，如果路由路径中包含大写或小写字母，那么只有大小写完全匹配时才会触发路由匹配。默认情况下，路由匹配是不区分大小写的。
2. Strict（严格）：当设置路由的 strict 选项为 true 时，路由匹配将会对路径末尾的斜杠进行严格匹配。也就是说，如果路由路径以斜杠结尾，那么只有在路由配置中也以斜杠结尾时才会触发路由匹配。默认情况下，路由匹配是不严格匹配路径末尾斜杠的。

通过设置 sensitive 和 strict 选项，您可以更精细地控制路由匹配的行为，以满足特定的需求和约束条件。

希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

## host: true 和 host: '0.0.0.0'

在计算机网络中，"0.0.0.0"是一个特殊的 IP 地址，代表所有不符合以上规则的 IP 包。在网络编程中，"0.0.0.0"可以被看作是一个空接口，用于表示所有不符合以上 IP 包的所有 IP 地址。

在编程语境中，"0.0.0.0"可以用于表示当前设备在网络上的任何可用接口。

而在配置文件中，"host: true"通常用于某些配置文件中，比如 Docker Compose，表示绑定到宿主机的所有接口上。

"host: true"和"host: '0.0.0.0'"的区别在于，"host: true"绑定的是宿主机的所有接口上，而"host: '0.0.0.0'"绑定的是宿主机的所有网络接口上，但不包括 localhost(127.0.0.1)。

在 Vue 项目中，将 host 设置为 '0.0.0.0' 可以使得项目可以通过局域网进行访问，而不设置或者设置为其他值可能导致只能通过本地访问而无法通过局域网访问的原因如下：

1. **绑定到所有网络接口**：'0.0.0.0' 是一个特殊的 IP 地址，表示绑定到所有可用的网络接口。当将 host 设置为 '0.0.0.0' 时，Vue 项目会监听来自所有网络接口的请求，包括本地和局域网的请求，从而使得局域网中的其他设备可以访问到该项目。
2. **默认绑定到本地**：如果不设置 host 或者设置为默认值（通常是 'localhost' 或者 '127.0.0.1'），Vue 项目会默认只监听来自本地的请求，而不会监听来自局域网的请求。这就导致了只能在本地访问项目，而无法通过局域网进行访问。

因此，通过将 host 设置为 '0.0.0.0'，Vue 项目会监听来自所有网络接口的请求，包括局域网中的请求，使得局域网中的其他设备可以访问到该项目。这就解释了为什么设置为 '0.0.0.0' 可以实现局域网访问，而不设置或者设置为其他值则无法实现局域网访问的原因。

希望这个解释能够帮助您理解为什么将 host 设置为 '0.0.0.0' 可以实现局域网访问。如果您有任何其他问题，请随时告诉我。

明白了,当这俩设置其中一个得时候,此时咱们的项目会绑定到本机所有的网络接口,当局域网通过本机 ip 访问我们得时候,我们就把项目通过局域网传输给对方查看.

localhost 是一个网络术语，通常用于指代本地主机或本地计算机。当您在浏览器或计算机中访问 localhost 时，实际上是在访问您自己的计算机上运行的服务或应用程序。

具体来说，localhost 通常对应的是 IP 地址 127.0.0.1，这是一个特殊的 IP 地址，用于表示本地主机。当您访问 localhost 或 127.0.0.1 时，您的计算机会尝试连接到自己的网络接口，从而访问本地运行的服务或应用程序。

因此，localhost 主要用于在本地计算机上访问本地部署的服务，进行开发、测试或调试。通过访问 localhost，您可以与本地主机上运行的应用程序进行交互，而无需通过网络连接到其他计算机或服务器。

总的来说，localhost 是一个方便的方式，让您可以在本地计算机上访问本地部署的服务或应用程序，是开发和测试过程中常用的工具之一。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

指定服务器应该监听哪个 IP 地址。 如果将此设置为 `0.0.0.0` 或者 `true` 将监听所有地址，包括局域网和公网地址。 ------vite 官网

https://cn.vitejs.dev/config/server-options.html#server-host

本地服务器和局域网服务 都可以本机直接访问,而项目上线则需要通过公网 ip 访问.

## el-upload v-model 注意事项

v-model:file-list 和:file-list 如果直接绑定 reactive([])的数据，那么操控数据源不会影响 dom 更新 而包一层 data 就可以了

upload 组件 api 写的 on-change 等事件都可以用@xxx 绑定

## vite 的 proxy 代理

本质上是一个 node 插件/包 node-http-proxy proxy 里 changeOrigin 是允许使用 target 作为目标 url 这里可以配置 timeout 响应超时事件。

## axios 取消请求也不会触发请求失败拦截器 但会触发请求拦截

请求拦截里 是请求发出前做什么配置 如果这里抛出错误什么的请求不会发出 并且请求得 then 和 catch 也不会拦截到任何东西 因为压根请求就没有发出，因此也没有成功和失败得状态了。 一般可以在请求拦截器里配 token 当然 create 得时候也可以配置。

## vscode 里的 eslint 插件和 vue 项目里安装的 eslint 的关系是什么。

首先没有安装 eslint 插件的话 项目里的 eslint 不会实时报错 只能在执行 lint 命令的时候才会报错,因为插件负责的就是编译时报错，.eslintrc.cjs 是项目 eslint 插件的配置文件。

ts 插件同理。

.eslintrc.cjs 和.`prettier`.cjs 都不需要启动项目 就能格式化代码。

执行项目的 lint 命令也需要这个配置文件。并且一些简单错误 lint 执行的时候也会帮我们修复比如单引号双引号等。

不装 eslint-vue-plugin 则无法 eslint .vue 文件

但如果有 typescript-eslint/parser 则可以解析 ts 的.vue 文件 但依然无法解析 js 的 vue 文件。

1. `eslint-config-prettier` ：这是一个 ESLint 配置规则的包，它将禁用与 Prettier 冲突的 ESLint 规则。使用 `eslint-config-prettier` 可以确保 ESLint 规则与 Prettier 的代码格式化规则保持一致，避免二者之间的冲突。
2. `eslint-plugin-prettier` ：这是一个 ESLint 插件，它将 Prettier 应用到 ESLint 中。它会使用 Prettier 来格式化代码，并将格式化结果作为 ESLint 的一项规则来检查代码。使用 `eslint-plugin-prettier` 可以在代码检查的同时，自动格式化代码，使其符合 Prettier 的规则。

通常情况下，您需要同时安装这两个包来实现 ESLint 和 Prettier 的集成。首先，使用 `eslint-config-prettier` 禁用与 Prettier 冲突的 ESLint 规则，然后使用 `eslint-plugin-prettier` 将 Prettier 应用到 ESLint 中，以便在代码检查时自动格式化代码。

但是测试移除了 `eslint-plugin-prettier` 并没有啥实质性的影响 yarn lint 还是保存都会格式化代码。 我看 npm 官方文档说 `eslint-plugin-prettier`作用是将 Prettier 作为 ESLint 规则运行，并将差异报告为单个 ESLint 问题。那我们没有测试出的原因可能是 eslint 配置后的规则本身就覆盖 prettier 了？导致他移除了也没啥影响吗？

但是我看代码中 eslint 规则的报错的确是 eslint-plugin-prettier 提示的，那有可能是 prettier 插件中自带了 eslint-plugin-prettier

移除@vue/eslint-config-prettier 的话 会失去 prettier 的功能. 并且失去 eslint 编译时报错的功能。在命令行的情况下，但可以保存执行 prettier 格式化代码。

Prettier 插件可以格式化代码，也可配置保存自动格式化代码。

需要配置.prettierrc 文件 然后全局的代码都可以自动保存格式化了。 一种是.prettierrc 一种是自带的 tsjs 格式化。

我们安装 Prettier 插件后,可以有两种格式化代码的方式，第一种是配置 vscode 的 json 然后需要在 prettier.configPath 选项下配置一个.prettierrc 文件 然后每一次保存的时候，会自动根据.prettierrc 文件去格式化代码，这种做法缺点是如果我们 vue 项目里安装了 eslint 和 prettier 依赖的话 由于顺序问题会先执行项目里的 prettier 再执行 插件的 prettier 导致多次格式化最终还是会报错。 解决办法是删掉 prettier 文件。另外 vue 的官方插件 vue office 也会格式化代码和项目里的 prettier 冲突。 因此我们格式化代码也不要用它就用 prettier 并且是没有配置.prettierrc 的 prettierrc 插件。

另外，除了配置在 vscode 的 json 中，.prettierrc 还可以放到某个项目的根目录下，这样也会执行格式化 并且是局部的 放在哪个根目录就只格式化那个根目录。 并且 prettierrc 插件不仅会格式化 vue js 等文件连 md 文档也会 ts json 不会。

另外格式化的优先级是以当前文件配置开始到 vscode 配置的。 后面的覆盖前面的。

而本项目的依赖 prettierrc 优先级优于 本项目里的.prettierrc 文件。

另外如果 eslint 插件禁用的话 项目代码不会有错误提示，但是格式化代码照常格式化这是由于咱们项目里 有.prettierrc.cjs 这也是 prettierrc 插件的配置文件。如果禁用 prettierrc 插件的话 那么项目会采用 eslint-prettierrc 来格式化代码 优先用这个。 如果这个被禁用则用 prettierrc 插件格式化代码。如果二者都开着则两个都会使用格式化代码。

即便我们删除 prettierrc.cjs 也会触发 prettierrc 插件格式化 这是由于 node_modules 下也有配置文件。

有时候这俩格式化代码都通过了 但是 ts 会报错。

eslint-config-prettierrc 不依赖.prettierrc.cjs 也不依赖.eslintrc.cjs 中 rules，但依赖 extends 没有这个 vscode 就不会提示错误了。

因此我们可以得出结论 eslint 插件和 prettierrc 插件二者只要配置了 对应的配置文件那么就能工作，前者负责报错，后者负责格式化代码，但如果我们想要功能更为强大得报错与格式化代码比如支持 vue ts 等等文件得格式化 以及自动帮我们整理好规则的话则需要手动去安装 eslint 与 prettierrc 的依赖在项目中并配置。

另外 eslint 的依赖需要 eslint 插件才能运行否则报错，而 eslint-config-prettierrc 不需要 prettierrc 插件 eslint 生效就能格式化代码了，如果 eslint 不生效则需要 prettierrc 插件和.prettierrc 来格式化代码。

prettierrc 插件 默认可以格式化代码？ 没有配置的话，回头试试。

插件都是编译时和保存时自动使用，而配置是执行命令时才调用。

## UI 风格汇：材料设计（Material Design），是对扁平风格的延展。

https://blog.csdn.net/2401_82616673/article/details/136993945

https://baike.baidu.com/item/Material%20Design/16011141

一种设计风格 类似的 ui 库有 Vuetify Varlet Quasar

一个比较显著的特点是 这种风格的 ui 组件库的按钮 点击是有涟漪效果的。

比较讲究**平面化与阴影效果** 以及过渡动画和响应式的 UI 设计风格

https://www.51cto.com/article/742102.html

## 将一个本地的的项目关联推送到远程仓库

首先在本地仓库里 git init 初始化本地仓库后才可以提交代码

git add .

git commit -m info

```
git remote add origin 远程仓库地址
```

```
git push -u origin "master"
```

后面每次提交代码都可以 git push 了

remote add 把远程仓库地址添加到本地。使本地仓库和远程仓库产生关联

origin 远程仓库的别名 url 地址

git push -u origin "master" **将本地仓库数据推送到远程仓库**

**origin 为远程仓库的名称，可以自定义**

https://blog.csdn.net/mi_lu_yuan/article/details/132467412

不知道切换分支推送的时候 是否也需要 git push -u origin 分支地址一次

## Git 拉取请求：Git pull Request

https://blog.csdn.net/mzgxinhua/article/details/135095992

https://www.cnblogs.com/kingpong/articles/16501021.html

这里的拉去请求 使用场景是 别人新建了一个分支并且推送到了远程，（他没有去本地分支合并然后 push）而我们本地没有那个分支，想要将别人的代码 远程合并到 master 分支时候，这样我们 pull master 的时候就能拉到别人分支的代码了。

Git pull request 是一种常用的协作方式，通常用于开源项目或团队合作中。下面是对 Git pull request 的解释：

1. **创建分支**：首先，您需要在本地仓库中创建一个新的分支，用于进行特性开发或修复工作。您可以使用 `git checkout -b <branch-name>` 命令来创建并切换到新的分支。
2. **提交更改**：在新的分支上进行代码修改、添加、删除等操作，并使用 `git add` 和 `git commit` 命令将更改提交到本地仓库。
3. **推送分支**：将本地的新分支推送到远程仓库，使用 `git push origin <branch-name>` 命令将新分支推送到远程仓库。
4. **创建 Pull Request**：在远程仓库中打开一个 Pull Request（PR），将您的新分支与目标分支（通常是主分支）进行比较。在 PR 中可以添加描述、更改说明等信息。
5. **讨论和审查**：团队成员可以在 PR 中进行讨论、提出建议或进行代码审查，确保代码质量和功能完整性。
6. **合并 Pull Request**：如果 PR 经过审查并通过了所有的检查，负责人或项目维护者可以选择合并该 PR，将您的更改合并到目标分支中。

通过使用 Git pull request，可以方便地进行代码审查、讨论和合并，保证团队协作的顺利进行，并确保代码质量和项目稳定性。希望这个解释对您有帮助。如果您有任何其他问题，请随时告诉我。

如果是本地的分支，也就是我创建了新分支 那么我可以直接在本地合并分支后 push 到远程。

git 中为什么是 pull request 而不是 push request？ - 周越的回答 - 知乎
https://www.zhihu.com/question/334230718/answer/743900086

## Git 中 fork, clone,branch 有什么区别?

https://blog.csdn.net/weixin_40808668/article/details/133987915

## vite preview 和 vite

前者是运行编译打包后的项目 后者是编译前的 前者有文件指纹和 asset 中文件打包后名字改变后的文件导入。

## v-if 和 v-show 对于事件触发顺序的影响

v-if 移除 dom 和新增 dom 是异步的，这个我们都知道，因此如果做那种 hover 下拉菜单的时候，会出现这种情况，父级菜单移动到子级菜单的时候 由于父级菜单和子级菜单是连着的 事件的触发顺序是 父级 onmouseleave-> 子 onmouseenter 在父的 onmouseleave 种我们将子的显示状态切换成 false 但是由于 v-if 是异步移除 dom 的，由于我们速度很快，再加上异步销毁子，导致我们明明切换了子的显示状态为 false 但依然触发了 子的 onmouseenter 事件。理论来说我们是不希望这样的。我们只希望鼠标从父亲移开只触发 onMouseleave 不触发子的 onmouseenter。

而使用 v-show 去控制子显示与隐藏的话 也是异步的 但是同样的操作 不仅会触发子的 onmouseenter 还会触发 onmouseleave 当它消失的时候，歪打正着，如果我们触发了 onmouseleave，反倒还帮我们隐藏了三级菜单

如何让一级菜单移走 进入了二级菜单 但二级菜单不销毁呢，做法是当我们移入二级菜单的时候加一个全局变量 如 isleaveTwo 来作为我们是否一如二级菜单的依据，然后在一级菜单里的 leave 事件里判断（这里需要一个异步判断，原因如前：因为二级菜单的 enter 执行是一定在一级的 leave 后 而 isleaveTwo 状态修改是在子 enter 事件种 这里不异步的话 leave 的时候 isleaveTwo 状态永远没有变化。异步的选择方式可以是计时器可以是帧动画。）

## vue template 模板中 的元素除了能绑定 class style data-xx 等等原生属性 还可以通过 onclick onmouseenter 正常绑定事件 到时候会当成原生去解析。

那 template 种的内容会当作原生 html 解析的

并且这个事件和 vue 的@事件还不会冲突 这个事件先执行然后执行 vue 的@事件

## mouseenter mousemove 这种事件 不是 hover 事件。

mouseenter 和 mouseover 的区别

https://blog.csdn.net/qq_66442729/article/details/134523171

mouseover 绑定在父元素身上 从子元素移到父元素也会触发一次事件 但 enter 不会 enter 只会在进入时触发一次 leave 同理。

mouseover 还会冒泡 从父元素移动到子元素 子元素会冒泡 触发一次父元素的 mouseover 而 enter 不会，冒泡吗，很正常类比 click 绑定父元素 点击其中子元素也执行一样。

https://blog.csdn.net/weixin_47450807/article/details/123381092

## 绝对定位的元素 height:100%的说明

绝对定位 height 100%如果祖先元素中有相对定位的元素 则以相对定位的元素的高度\*100% 否则以 100vh 为参照。 宽度同理。 top left 值同理 这里是可视区域宽高 什么是可视区域 不算滚动条卷去的部分。

因此如果我们要考虑到滚动的话这里就不能用 left 50% transform translate-50%来写居中了 除非祖先元素是定位.

## 多级联动下拉菜单的解题思路

一定要是嵌套的写法，一级采单嵌套二级 二级嵌套三级 三级套四级

这么写好处是鼠标无论从三级或者四级或者二级移出到菜单外的时候，会自动关闭全部菜单，而无需手动去控制祖先级别菜单隐藏，这是因为由于结构是嵌套的，因此事件触发也是嵌套的 鼠标从 3 级出到外部的时候 同样是移除了 2 级和 1 级 导致他俩也触发各自的 leave 事件 关闭各自的子级，因此需要去绑定每一级的移除事件 因为要判断移除后是否又回到了上一级菜单，如果是则不关闭全部菜单，而是只关闭这一级的下一级菜单。

不能用菜单每一级都是独立然后用一个大盒子包起来的写法，这么写会有问题，导致外面大盒子触发的事件在后，内部盒子触发在前，导致事件冲突，因此最好的做法还是嵌套。 要不就嵌套，要不就分开写，然后分别控制他们移入移出以及移入到上下级时的事件，会很麻烦很麻烦，层级少还行层级多搞不定。

onmouseleave 当鼠标从自身元素移出时触发，如果三个相同大小的元素嵌套则会分别触发三个移出事件（前提三个分别绑定了）

和 mouseover 的区别 嵌套的时候 如果从父移到子 会触发父的 out 事件 但是 leave 不会

从子移到父也不会触发父的 enter 而 over 会触发。

也就是说 leave 和 enter 会把子也看作是自己的一部分。 而 over 和 out 会把子看作是独立的。

## 组件二次封装注意事项

slot 作用域插槽传参的时候 和正常 v-bind 传值一样 可以传多个 但是 template 使用的时候是一个对象接受的。

```javascript
  <n-modal v-bind="$attrs" preset="dialog">
    <template v-for="(item, index) in $slots" :key="index" #[item]="props">
	<!-- 为什么这里是v-for template 而不是直接slot v-for呢是因为 如果直接v-for slot 那么传过来的插槽全部都会在这里的default渲染 -->
      <!-- props可能是多个 这里用v-bind -->
      <slot :name="item" v-bind="props"></slot>
    </template>
  </n-modal>
```

## naiveui 自动导入的时候需要手动声明 dialog message 等四个方法 他们和 elementui 一样既用到方法也用到组件。 其他的可以直接光组件就行。

naiveui 的 modal 组件我二次封装插槽那里报错了。

vite 自动导入插件 如果一个方法有同名方法 具体导入哪一个 不知道 vite 是如何进行判断的，因此尽量避免定义同名函数

## 自动导入的两种方式 如果是 export 则直接导入 如果是 export default 则需要使用导出的文件名使用它。

## vue3 setup 语法中 使用 swiper

https://blog.csdn.net/weixin_51924709/article/details/125919323

## 多行省略无论设不设置 省略号都会显示省略号 如果想要设置多行溢出不显示省略号 做法是设置元素高度 然后 overflow hidden 正好显示两行的高度就行

## apifox 和一些 node 插件可以自动根据接口返回生成 ts 类型。

## 变量：类型 是全局的 而类型断言是只要那行代码执行的时候可以断言成某个类型

变量声明类型 函数也要声明参数类型 就算是你调用函数时传的实参声明类型了 那形参也要声明类型 这是因为如果想要函数调用时声明类型 需要泛型,泛型的用法需要复习。
