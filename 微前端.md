# 微前端

微前端的灵感来源自后端的微服务，在一个单页面应用中请求的接口，背后的后端应用则是数量庞大的微服务集群。

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。

微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，这样才能确保微应用真正具备独立开发、独立运行的能力。

- **技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权；**
- **独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；**
- **增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略；**
- **独立运行时每个微应用之间状态隔离，运行时状态不共享。**

## 微服务

每个 springboot 项目都可以看作是一个微服务中的一个服务模块 多个 springboot 项目可以受 springcloud 管理

SpringBoot 和 SpringCloud 是两个独立的项目，但是 SpringCloud 构建在 SpringBoot 之上，并且依赖于 SpringBoot 中的很多核心功能。如果要使用 SpringCloud 来构建分布式应用程序，就必须要使用 SpringBoot 来作为基础框架。因此，可以说 SpringCloud 是针对微服务架构的补充和加强，与 SpringBoot 可以协同使用来构建高可用性、可伸缩性和易维护性的分布式系统。

https://xie.infoq.cn/article/5c859dda520e4b3bf47b62ea7

## 微前端框架

三大微前端框架，谁是你的理想型？

https://juejin.cn/post/7309477710523269174

### qiankun

qiankun 方案是基于 single-spa 的微前端方案。

> single-spa 官网：https://single-spa.js.org/docs/getting-started-overview
>
> 什么是 single-spa：https://blog.csdn.net/qq_35876316/article/details/143475963
>
> single-spa 源码解析：https://www.cnblogs.com/kongshu-612/p/18336868
>
> single-spa 是如何运行的？：https://juejin.cn/post/7123861138164432926
>
> 一张图简述 single-spa 原理：https://juejin.cn/post/7369436144197648418?searchId=202412022113552D2FF4F19806AD12BC92
>
> 深入微前端（一）：single-spa 入门、实战、手写实现与分析：https://juejin.cn/post/7418876519815413794?searchId=202412022113552D2FF4F19806AD12BC92#heading-6
>
> 微前端框架 之 single-spa 从入门到精通：https://zhuanlan.zhihu.com/p/463654743

single-spa 缺点是没有 js 隔离与 css 隔离需要手动处理而 qiankun 基于这个进行了封装,简化了微应用的注册方式，增加了微应用的沙箱管理(js、css 隔离)与全局状态共享机制，并且 qiankun 内部实现了一个解析 html 字符串获取静态资源地址的解析库 import-html-entry，方便微应用接入与资源预加载。

###### popstate,pushState 和 replaceState 这几种方法或事件的作用?

https://zhuanlan.zhihu.com/p/665529595

single-spa 的核心就是通过拦截与监听浏览器的路由事件 然后对子应用进行挂载与卸载的。

它要求所有的应用自己抽象成那四个方法。而且所有的应用都在同一个 js 的上下文中执行，所有很容易会出现互相打架的情况。qiankun 提供的 js 沙盒，就是为了这个准备的。对应用之间做了隔离。

##### single-spa 的缺陷

> 对子应用的侵入性太强

single-spa 采用 `JS Entry` 的方式接入子应用，这就要求整个子应用要打包成一个 JS 文件，常见的打包优化基本上都没了，比如：按需加载、首屏资源加载优化、css 独立打包等优化措施。

> 样式隔离问题和 JS 隔离

全局样式和全局对象（window）的污染

> 资源预加载 和 应用间通信

子应用已经被整个打包成 js 文件，所以做不到让浏览器在后台悄悄的加载其它子应用的静态资源

正是因为有以上这些问题，所以实际开发中我们一般不会直接使用 `single-spa`，而是采用更成熟完善的微前端解决方案：`qiankun`（乾坤）；在下一篇，我们会详细展开对 `qiankun` 的介绍和源码分析，以及在实际应用中可能遇到的挑战和解决方案。

> 也就是说 single-spa 最终打包完毕的子应用是 js 文件，并且需要去手动为每个子应用去处理增加对应的生命周期函数，用起来比较麻烦，还会污染 window 对象，没有 css 的隔离 另外 single-spa 每次只能有一个子应用被加载，加载另一个就要卸载之前的。具体加载哪个子应用是 activeWhen 决定的

#### 修改 webpack 配置的作用

你提供的代码片段是用于配置 Webpack 的，通常在 Vue.js 项目的 `vue.config.js` 文件中使用。这个配置主要用于定义 Webpack 如何打包你的项目，并指定打包后的输出格式和名称。下面是对这段代码的详细解释：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="299e0c80-fb73-418f-a3fa-3bdad513b00b" tasktype="FREE_INPUT"><code class="language-jsx"><span>module</span><span class="token">.</span><span class="token property-access">exports</span><span></span><span class="token">=</span><span></span><span class="token">defineConfig</span><span class="token">(</span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">configureWebpack</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">output</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">library</span><span class="token">:</span><span> packageName</span><span class="token">,</span><span></span><span class="token">// 打包以后对外暴露的名称</span><span>
</span><span></span><span class="token literal-property">libraryTarget</span><span class="token">:</span><span></span><span class="token">"umd"</span><span></span><span class="token">// 打包的类型</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

##### 解释

1. **`module.exports`** :

- 这是 Node.js 中用于导出模块的方式。在这里，你导出了一个配置对象，该对象会被 Vue CLI 使用来配置 Webpack。

1. **`defineConfig`** :

- 这是一个辅助函数，通常来自 `@vue/cli-service`，用于定义配置对象。它可以提供更好的 TypeScript 支持和类型检查。

1. **`configureWebpack`** :

- 这是一个属性，允许你直接修改 Webpack 的配置。你可以传递一个对象或一个函数来覆盖或扩展 Webpack 的默认配置。

1. **`output`** :

- 这是 Webpack 配置中的一个关键部分，用于指定打包后的输出文件的相关信息。

1. **`library`** :

- 这个属性指定了打包后的库对外暴露的名称。当你将你的项目打包成一个库时，其他项目可以通过这个名称来引用你的库。
- 例如，如果你设置 `library: 'MyLibrary'`，那么在浏览器环境中，你可以通过 `window.MyLibrary` 来访问你的库。

1. **`libraryTarget`** :

- 这个属性指定了打包后的库的类型。常见的值包括：
  - **`var`** : 通过一个变量暴露库。例如，`var MyLibrary = _entry_return_`。
  - **`umd`** : 通用模块定义（Universal Module Definition），兼容 AMD、CommonJS 和全局变量。这是最常见的选择之一，因为它可以在多种环境中使用。
  - **`commonjs`** : 适用于 CommonJS 环境，如 Node.js。
  - **`commonjs2`** : 类似于 `commonjs`，但暴露的是 `module.exports`。
  - **`amd`** : 适用于 AMD 模块加载器，如 RequireJS。
  - **`this`** : 通过 `this` 对象暴露库。例如，`this["MyLibrary"] = _entry_return_`。
  - **`window`** : 通过 `window` 对象暴露库。例如，`window["MyLibrary"] = _entry_return_`。
  - **`global`** : 通过 `global` 对象暴露库。例如，`global["MyLibrary"] = _entry_return_`。
  - **`assign`** : 直接赋值给一个对象。例如，`MyLibrary = _entry_return_`。

##### 示例

假设你的项目名称是 `my-package`，并且你想将其打包成一个 UMD 模块，你可以这样配置：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="299e0c80-fb73-418f-a3fa-3bdad513b00b" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token">const</span><span> packageName </span><span class="token">=</span><span></span><span class="token">'my-package'</span><span class="token">;</span><span>
</span>
<span>module</span><span class="token">.</span><span class="token property-access">exports</span><span></span><span class="token">=</span><span></span><span class="token">defineConfig</span><span class="token">(</span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">configureWebpack</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">output</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">library</span><span class="token">:</span><span> packageName</span><span class="token">,</span><span></span><span class="token">// 打包以后对外暴露的名称</span><span>
</span><span></span><span class="token literal-property">libraryTarget</span><span class="token">:</span><span></span><span class="token">"umd"</span><span></span><span class="token">// 打包的类型</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

这样配置后，当你运行 `npm run build` 或 `yarn build` 时，生成的文件将会是一个 UMD 格式的库，可以通过 `my-package` 这个名称来访问。

##### 总结

- **`library`** : 指定打包后的库对外暴露的名称。
- **`libraryTarget`** : 指定打包后的库的类型，这里设置为 `umd`，使其可以在多种环境中使用。

#### 前端 BEM 命名方式

https://baike.baidu.com/item/BEM/23772830?fr=aladdin

https://bemcss.com/

> BEM 命名是希望每个元素都有自己的 BEMclass 方便维护与修改 element-plus 的样式也遵循这个规则

> 组件的 css 最好写在组件内部并且脱离原子化，否则组件被其他项目使用还要导入对应 css。

#### html-entry 和 js-entry

js-entry 是把应用打包成 js 文件，通常是 app.js 因此不存在代码分割的功能，而 html-entry 是以 html 文件为入口，而 html 文件里可以导入 js 与 css，因此可以做到代码分割。

#### webpack 打包的文件入口文件中导出的方法会挂载到 window 上

vite 好像不会

#### 微前端 -- 乾坤（一）

https://www.jianshu.com/p/4978d6e54937

这里对乾坤的两种沙箱机制进行了源码分析 一种是快照 一种是代理。

js-entry 与 html-entry 的区别 乾坤 无界用的都是后者 entry 是入口

js-entry 打包出的项目像是 npm 包 不含有 html 页面的

不太理解文章中为什么说 js-entry 会影响按需加载 我自己测试 webpack 打包后 import 导入的文件 依然会拆分成 2 个

在 vite 中如果 文件改动了 每次 build 都会生成新的文件指纹

我修改了 vitebuild 的方式 无论是 crossenv 还是 mode 都切换成 development 发现最终打包出的都有指纹 而 webpack 打包的如果是 development 的话就不会有指纹 并且即便我修改了文件 无论用生产环境还是开发打包都不会修改文件名 奇怪了 这里记下来。

如果 vite dev mode 选择 prod 服务启动后页面会不展示 crossenv 才是真正修改打包方式的 mode 是选择环境变量的

#### 微前端之 qiankun 介绍和简单使用

https://developer.aliyun.com/article/1116714

乾坤有支持 vite 的插件。

子应用配置时需要通过变量来区分是直接运行的还是作为子应用运行的。

新建 public-path.js 文件导入，通过判断 window 属性来设置运行时资源路径。

#### 微前端（qiankun）vue2、vue3 微应用嵌入

https://blog.csdn.net/yzding1225/article/details/136155557

乾坤需要调用子应用的 mount 来挂在组件 而不是直接走 app.mount 来挂载 可以通过乾坤的 api 来判断是否独立运行再决定是直接渲染还是暴露生命周期渲染。

乾坤卸载应用时需要手动调用组件卸载方法。app.unmount()

乾坤的全局状态使用 不知道是不是只能通过 onGlobalStateChange 去拿而不能通过 window 直接拿呢？以后用到再说吧。

是的 无论子应用还是基座应用都要通过 onGlobalStateChange 监听全局状态变化。 它的模式是发布订阅模式。

#### [浅谈 qiankun 微前端](https://www.cnblogs.com/wangxinyubokeyuan/p/18292511 "发布于 2024-07-10 11:23")

https://www.cnblogs.com/wangxinyubokeyuan/p/18292511

#### [qiankun 微前端实例化使用](https://www.cnblogs.com/codeOnMar/p/17860009.html "发布于 2023-12-19 16:01")

https://www.cnblogs.com/codeOnMar/p/17860009.html

这里有个问题 就是只有子应用才需要接入 public-path.js 基座不需要 文章里写的有问题 https://qiankun.umijs.org/zh/guide/tutorial

官网也说了

public-path.js 作用 https://webpack.docschina.org/guides/public-path/#on-the-fly

经过我测试基座拿不到 window.**POWERED_BY_QIANKUN**

#### 微前端框架 之 qiankun

https://blog.csdn.net/fmk1023/article/details/114276311

#### qiankun 2.x 运行时沙箱 源码分析

https://juejin.cn/post/6885214342552223757

### 无界微前端

https://wujie-micro.github.io/doc/guide/

无界最终运行出来的时候，dom 运行在 webcomponent 中的 其内部有一个完整的 html-body-app 而 js 是运行在一个新建的与主应用同源的 iframe 中，其中的 document 地址是真正的子应用地址(不知道怎么做到 iframe 的 src 与 document 的地址不同的)

wujie 的保活是只卸载 dom 的挂载不卸载 iframe

子应用切换路由时 参数是作为 query 写入到地址栏的

#### 无界子应用样式丢失问题

https://github.com/Tencent/wujie/issues/434

就是不知道这个 lastInsertedStyle 作用是什么

#### 无界预加载说明

无界预加载会减少子应用的首屏展示时间（提前下载，但不执行）

但是会占用网络资源，导致主应用加载时间变长

预加载时机：动态导入的路由组件加载时，加载子应用的 document

这里会发现加载子应用 document 请求了两次 第一次请求的是主应用 host 第二次才是子应用的（无界自身问题）

无论是否使用了 wujie-vue 只要制定了 preload 便会下载子应用 document

setupApp 是对子应用进行一些提前配置 配置的内容无需再次写在 preload 里或者 wujie-vue 上了

startApp 暂时不知道应用场景

#### wujie-vue v-show v-if 说明

如果使用 v-if 切换 wujievue 那么 每次 wujievue 销毁与创建都会去再次加载 document（除第一次外后续是直接去请求子应用的 document）执行 浪费性能 正确做法是 使用 v-show（缺点有缓存，如果切换前后指向子应用同一个路由那么那个页面等于一直保活状态）

#### wujie bus 事件触发注意事项

emit 事件执行的前提是 必须先有 on 监听 否则会报错 xx 事件订阅为空 也就是说必须先有订阅者才能发布事件

因此如果想要让子应用可以根据父应用的路由变化 从而修改子应用的路由 是需要让父应用的 emit 执行在子应用初始化后的 能想到的方式就是 父应用直接 on 一个事件 等子应用初始化完毕了 emit 触发这个父应用的 on 事件 再事件回调里 再根据 path 去 emit 一个事件告诉子应用 on 事件此时路由可以 push

push 最好先执行 然后再 让 v-show 的值切换为 true 因为需要加载组件

on 和 emit 都是同步的 这就意味着 子应用的 on 一定要在 emit 之前 这样 emit 触发告诉父应用子应用已启动并且 on 也已订阅完毕了 此时可以监听到父应用 on ready 里的 emit 发布

#### wujie select 和 tooltip 错位解决办法

https://github.com/Tencent/wujie/issues/123

子应用加

```css
div[id^="el-popper-container-"] {
  position: relative;
}
```

#### 盘点一下用了这么长时间遇到的 Wujie 无界微前端的坑

https://juejin.cn/post/7444134659719610380#heading-12

#### 生产环境如果遇到请求子应用跨域的情况的话，需要后端对子应用的 url 进行跨域处理

接口跨域也一样

`{ "Access-Control-Allow-Credentials": true, "Access-Control-Allow-Origin": req.headers.origin || "*", "Access-Control-Allow-Headers": "X-Requested-With,Content-Type", "Access-Control-Allow-Methods": "PUT,POST,GET,DELETE,OPTIONS", "Content-Type": "application/json; charset=utf-8", }`

这段配置是用于设置HTTP响应头，主要用于跨域资源共享（CORS, Cross-Origin Resource Sharing）的场景。以下是每个字段的具体解释：

* **Access-Control-Allow-Credentials: true**
  * 允许浏览器在请求中包含用户凭证信息（如 cookies、HTTP 认证信息等）。当这个值为 `true` 时，`Access-Control-Allow-Origin` 不能设置为 `*`，而必须指定一个明确的域名。
* **Access-Control-Allow-Origin: req.headers.origin || "*"**
  * 指定允许访问资源的源（协议 + 域名 + 端口号）。如果使用的是 `req.headers.origin`，则表示允许来自请求源的访问；如果是 `"*"`, 则表示允许所有源访问。由于上面设置了 `Access-Control-Allow-Credentials` 为 `true`，这里应该是一个具体的源而不是 `*`。
* **Access-Control-Allow-Headers: "X-Requested-With,Content-Type"**
  * 指定预检请求中允许的实际请求的头信息。这里允许了 `X-Requested-With` 和 `Content-Type` 两个头信息。
* **Access-Control-Allow-Methods: "PUT,POST,GET,DELETE,OPTIONS"**
  * 指定预检请求中允许的实际请求的方法。这里允许了 `PUT`、`POST`、`GET`、`DELETE` 和 `OPTIONS` 方法。
* **Content-Type: "application/json; charset=utf-8"**
  * 指定响应的内容类型为 JSON 格式，并且字符编码为 UTF-8。

### 总结

这段配置主要用于解决前后端分离项目中的跨域问题，确保前端可以安全地从不同源发起带有凭证信息的请求，并且服务器能够正确处理这些请求。需要注意的是，当 `Access-Control-Allow-Credentials` 设置为 `true` 时，`Access-Control-Allow-Origin` 不能为 `*`，需要指定具体的源。

**Access-Control-Allow-Origin:"*" 不能和**Access-Control-Allow-Credentials: true 一起用 因为 前者无法携带cookie跨域需要具体域名

#### 微前端之使用无界集成可能出现的问题总结

https://blog.csdn.net/BradenHan/article/details/136519604

#### 无界三种运行模式

https://wujie-micro.github.io/doc/guide/mode.html

我使用的跟保活模式很像来切换路由。

单例模式和重建模式没看明白。

#### 路由同步

https://wujie-micro.github.io/doc/guide/sync.html

#### wujie使用子应用时 wangeditor不兼容

尝试了很多办法感觉最靠谱的还是不用它哈哈

### Garfish Framework

字节得微前端框架
