# 微前端

微前端的灵感来源自后端的微服务，在一个单页面应用中请求的接口，背后的后端应用则是数量庞大的微服务集群。

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。

微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，这样才能确保微应用真正具备独立开发、独立运行的能力。

- **技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权；**
- **独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；**
- **增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略；**
- **独立运行时每个微应用之间状态隔离，运行时状态不共享。**

## 微服务

每个 springboot 项目都可以看作是一个微服务中的一个服务模块 多个 springboot 项目可以受 springcloud 管理

SpringBoot 和 SpringCloud 是两个独立的项目，但是 SpringCloud 构建在 SpringBoot 之上，并且依赖于 SpringBoot 中的很多核心功能。如果要使用 SpringCloud 来构建分布式应用程序，就必须要使用 SpringBoot 来作为基础框架。因此，可以说 SpringCloud 是针对微服务架构的补充和加强，与 SpringBoot 可以协同使用来构建高可用性、可伸缩性和易维护性的分布式系统。

https://xie.infoq.cn/article/5c859dda520e4b3bf47b62ea7

## 微前端框架

三大微前端框架，谁是你的理想型？

https://juejin.cn/post/7309477710523269174

### qiankun

qiankun 方案是基于 single-spa 的微前端方案。

> single-spa 官网：https://single-spa.js.org/docs/getting-started-overview
>
> 什么是 single-spa：https://blog.csdn.net/qq_35876316/article/details/143475963
>
> single-spa 源码解析：https://www.cnblogs.com/kongshu-612/p/18336868
>
> single-spa 是如何运行的？：https://juejin.cn/post/7123861138164432926
>
> 一张图简述 single-spa 原理：https://juejin.cn/post/7369436144197648418?searchId=202412022113552D2FF4F19806AD12BC92
>
> 深入微前端（一）：single-spa 入门、实战、手写实现与分析：https://juejin.cn/post/7418876519815413794?searchId=202412022113552D2FF4F19806AD12BC92#heading-6
>
> 微前端框架 之 single-spa 从入门到精通：https://zhuanlan.zhihu.com/p/463654743
>
> single-spa是如何运行的？：
>
> https://juejin.cn/post/7123861138164432926

single-spa 缺点是没有 js 隔离与 css 隔离需要手动处理而 qiankun 基于这个进行了封装,简化了微应用的注册方式，增加了微应用的沙箱管理(js、css 隔离)与全局状态共享机制，并且 qiankun 内部实现了一个解析 html 字符串获取静态资源地址的解析库 import-html-entry，方便微应用接入与资源预加载。

###### popstate,pushState 和 replaceState 这几种方法或事件的作用?

https://zhuanlan.zhihu.com/p/665529595

single-spa 的核心就是通过拦截与监听浏览器的路由事件 然后对子应用进行挂载与卸载的。

它要求所有的应用自己抽象成那四个方法。而且所有的应用都在同一个 js 的上下文中执行，所有很容易会出现互相打架的情况。qiankun 提供的 js 沙盒，就是为了这个准备的。对应用之间做了隔离。

##### single-spa 的缺陷

> 对子应用的侵入性太强

single-spa 采用 `JS Entry` 的方式接入子应用，这就要求整个子应用要打包成一个 JS 文件，常见的打包优化基本上都没了，比如：按需加载、首屏资源加载优化、css 独立打包等优化措施。

> 样式隔离问题和 JS 隔离

全局样式和全局对象（window）的污染

> 资源预加载 和 应用间通信

子应用已经被整个打包成 js 文件，所以做不到让浏览器在后台悄悄的加载其它子应用的静态资源

正是因为有以上这些问题，所以实际开发中我们一般不会直接使用 `single-spa`，而是采用更成熟完善的微前端解决方案：`qiankun`（乾坤）；在下一篇，我们会详细展开对 `qiankun` 的介绍和源码分析，以及在实际应用中可能遇到的挑战和解决方案。

> 也就是说 single-spa 最终打包完毕的子应用是 js 文件，并且需要去手动为每个子应用去处理增加对应的生命周期函数，用起来比较麻烦，还会污染 window 对象，没有 css 的隔离 另外single-spa每次只能有一个子应用被加载，加载另一个就要卸载之前的。具体加载哪个子应用是activeWhen决定的

#### 修改webpack配置的作用

你提供的代码片段是用于配置 Webpack 的，通常在 Vue.js 项目的 `vue.config.js` 文件中使用。这个配置主要用于定义 Webpack 如何打包你的项目，并指定打包后的输出格式和名称。下面是对这段代码的详细解释：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="299e0c80-fb73-418f-a3fa-3bdad513b00b" tasktype="FREE_INPUT"><code class="language-jsx"><span>module</span><span class="token">.</span><span class="token property-access">exports</span><span></span><span class="token">=</span><span></span><span class="token">defineConfig</span><span class="token">(</span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">configureWebpack</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">output</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">library</span><span class="token">:</span><span> packageName</span><span class="token">,</span><span></span><span class="token">// 打包以后对外暴露的名称</span><span>
</span><span></span><span class="token literal-property">libraryTarget</span><span class="token">:</span><span></span><span class="token">"umd"</span><span></span><span class="token">// 打包的类型</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

##### 解释

1. **`module.exports`** :

* 这是 Node.js 中用于导出模块的方式。在这里，你导出了一个配置对象，该对象会被 Vue CLI 使用来配置 Webpack。

1. **`defineConfig`** :

* 这是一个辅助函数，通常来自 `@vue/cli-service`，用于定义配置对象。它可以提供更好的 TypeScript 支持和类型检查。

1. **`configureWebpack`** :

* 这是一个属性，允许你直接修改 Webpack 的配置。你可以传递一个对象或一个函数来覆盖或扩展 Webpack 的默认配置。

1. **`output`** :

* 这是 Webpack 配置中的一个关键部分，用于指定打包后的输出文件的相关信息。

1. **`library`** :

* 这个属性指定了打包后的库对外暴露的名称。当你将你的项目打包成一个库时，其他项目可以通过这个名称来引用你的库。
* 例如，如果你设置 `library: 'MyLibrary'`，那么在浏览器环境中，你可以通过 `window.MyLibrary` 来访问你的库。

1. **`libraryTarget`** :

* 这个属性指定了打包后的库的类型。常见的值包括：
  * **`var`** : 通过一个变量暴露库。例如，`var MyLibrary = _entry_return_`。
  * **`umd`** : 通用模块定义（Universal Module Definition），兼容 AMD、CommonJS 和全局变量。这是最常见的选择之一，因为它可以在多种环境中使用。
  * **`commonjs`** : 适用于 CommonJS 环境，如 Node.js。
  * **`commonjs2`** : 类似于 `commonjs`，但暴露的是 `module.exports`。
  * **`amd`** : 适用于 AMD 模块加载器，如 RequireJS。
  * **`this`** : 通过 `this` 对象暴露库。例如，`this["MyLibrary"] = _entry_return_`。
  * **`window`** : 通过 `window` 对象暴露库。例如，`window["MyLibrary"] = _entry_return_`。
  * **`global`** : 通过 `global` 对象暴露库。例如，`global["MyLibrary"] = _entry_return_`。
  * **`assign`** : 直接赋值给一个对象。例如，`MyLibrary = _entry_return_`。

##### 示例

假设你的项目名称是 `my-package`，并且你想将其打包成一个 UMD 模块，你可以这样配置：

<pre><div class="answer-code-wrap"><div class="answer-code-wrap-header"><div class="answer-code-wrap-header-left">javascript</div><div class="answer-code-wrap-header-right"><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-insert-line1"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-copy-line"></use></svg></span></span><span class="ai-button noBg false selected dark undefined"><span role="img" class="anticon yunxiao-icon undefined"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#yunxiao-additive-code-file-line"></use></svg></span></span></div></div><div node="[object Object]" class="answer-code-wrap-body" requestid="299e0c80-fb73-418f-a3fa-3bdad513b00b" tasktype="FREE_INPUT"><code class="language-jsx"><span class="token">const</span><span> packageName </span><span class="token">=</span><span></span><span class="token">'my-package'</span><span class="token">;</span><span>
</span>
<span>module</span><span class="token">.</span><span class="token property-access">exports</span><span></span><span class="token">=</span><span></span><span class="token">defineConfig</span><span class="token">(</span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">configureWebpack</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">output</span><span class="token">:</span><span></span><span class="token">{</span><span>
</span><span></span><span class="token literal-property">library</span><span class="token">:</span><span> packageName</span><span class="token">,</span><span></span><span class="token">// 打包以后对外暴露的名称</span><span>
</span><span></span><span class="token literal-property">libraryTarget</span><span class="token">:</span><span></span><span class="token">"umd"</span><span></span><span class="token">// 打包的类型</span><span>
</span><span></span><span class="token">}</span><span class="token">,</span><span>
</span><span></span><span class="token">}</span><span>
</span><span></span><span class="token">}</span><span class="token">)</span><span class="token">;</span></code></div></div></pre>

这样配置后，当你运行 `npm run build` 或 `yarn build` 时，生成的文件将会是一个 UMD 格式的库，可以通过 `my-package` 这个名称来访问。

##### 总结

* **`library`** : 指定打包后的库对外暴露的名称。
* **`libraryTarget`** : 指定打包后的库的类型，这里设置为 `umd`，使其可以在多种环境中使用。

#### 前端BEM命名方式

https://baike.baidu.com/item/BEM/23772830?fr=aladdin

https://bemcss.com/

> BEM命名是希望每个元素都有自己的BEMclass方便维护与修改  element-plus的样式也遵循这个规则

> 组件的css最好写在组件内部并且脱离原子化，否则组件被其他项目使用还要导入对应css。

#### html-entry和js-entry

js-entry是把应用打包成js文件，通常是app.js因此不存在代码分割的功能，而html-entry是以html文件为入口，而html文件里可以导入js与css，因此可以做到代码分割。

#### webpack打包的文件入口文件中导出的方法会挂载到window上

vite好像不会
