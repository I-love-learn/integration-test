{"version":3,"file":"TestTwo_chunk.js","sources":["../../src/hooks/index.ts","../../src/views/TestTwo.vue"],"sourcesContent":["\r\nfunction getDict(params: { dictType: string }): Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve({\r\n        code: 0,\r\n        data: [\r\n          {\r\n            dictCode: '1',\r\n            dictLabel: '男',\r\n            dictValue: '1'\r\n          },\r\n          {\r\n            dictCode: '2',\r\n            dictLabel: '女',\r\n            dictValue: '2'\r\n          }\r\n        ]\r\n      })\r\n    }, 5000);\r\n  })\r\n}\r\n\r\nexport function useAnalysisDict(): (value: string | number | undefined, dictCode: string) => string {\r\n  let string = ref('')\r\n  return function (value: string | number | undefined, dictCode: string):string {\r\n    if (!value) {\r\n      return string.value\r\n    }\r\n    console.log(value);\r\n    \r\n    let dictData\r\n    getDict({dictType:dictCode}).then((res) => {\r\n      if (res.code === 0) {\r\n        dictData = res.data\r\n\r\n        dictData.some((item: { dictCode: string | number, dictLabel: string,dictValue:string }) => {\r\n          if (value == item.dictValue) {\r\n            string.value = item.dictLabel\r\n          }\r\n        }\r\n        )\r\n      }\r\n    })\r\n    console.log(string);\r\n    // 之所以这里的string 我们需要用 ref而不是直接字符串 原因是因为 这里string的return是 同步的 而string的赋值是异步的 只有响应式对象 重新赋值后才会更新 而我们使用的其实是上一次的ref的值\r\n    return string.value\r\n  }\r\n}","<script setup lang=\"ts\">\r\n// 一个文件夹下同时有 同名js和ts 省略文件后缀 优先导入js\r\nimport { useAnalysisDict } from \"@/hooks/index.ts\"\r\n// import \"element-plus/dist/index.css\"\r\nimport \"element-plus/theme-chalk/el-select.css\"\r\nimport { ElSelect, ElInputNumber } from \"element-plus\"\r\nconst flag = ref(0)\r\n\r\nconst count = ref(1)\r\nfunction compute(value) {\r\n  return value + 1\r\n}\r\n\r\nconst count1 = reactive({\r\n  a: 1\r\n})\r\nconst handlePlus = function (value) {\r\n  return value + 1\r\n}\r\nconst count1plus = computed(() => handlePlus(count1.a))\r\n// 计算属性的函数会触发更新吗\r\nconst sexCode = reactive({\r\n  data: \"\"\r\n})\r\nconst sex = useAnalysisDict()\r\n\r\nsetTimeout(() => {\r\n  sexCode.data = \"1\"\r\n}, 2000)\r\n\r\n// 响应式数据的值 一直重新赋值 会触发更新不  不会 只会第一次值更新的时候 触发更新。 这也就说的通了 那里的return 的 string.value 其实是上一次函数执行的值，\r\n\r\nvar timer = setInterval(() => {\r\n  count.value = 1\r\n}, 2000)\r\n\r\nonMounted(() => {\r\n  console.log(\"页面进入了\")\r\n})\r\n\r\nfunction lose() {\r\n  console.log(\"进入\")\r\n  show.value = true\r\n}\r\nfunction _blur() {\r\n  console.log(\"离开\")\r\n}\r\nconst show = ref(false)\r\n\r\nconst num1 = ref(\"\")\r\nconst num2 = ref(\"\")\r\n\r\nconst num3 = ref(\"123\")\r\nconst num4 = ref(\"\")\r\n\r\n// v-model 是数据和界面 双向数据绑定 如果不用v-model 用:value的话 如果是原生的input 那么界面展示的还是我们输入的内容 只不过 data数据不会变化 如果是el-input 因为他是组件的自定义属性 则输入不了内容 只有属性变化才会改变\r\n// value我们输入的 如果value绑定的那个属性变化 则界面也会更新 如果那个属性不符合规则没变化 或者没绑定value则界面也会更新 因为原生的input 展示的value是 e.traget.value 是以这个为准的  当绑定了value 每当value的值改变e.traget.value也会同步更新 否则就是e.target.value更新而value不变\r\nfunction input(e) {\r\n  console.log(e.data)\r\n  console.log(e.target.value)\r\n\r\n  let regex = /^([0-9]\\d*(.\\d*)?)|(0.\\d*[1-9][0-9])|(0.\\d*[1-9])$/\r\n  // 让他可以检测小数点 但是小数点又不可以乱放\r\n  console.log(regex.test(e.data))\r\n\r\n  if (!regex.test(e.data)) {\r\n    // console.log(e.target.value.replace(e.data, \"\"))\r\n    // 这么写的话 输入汉字的时候 会清空 e.target已有的值\r\n    e.target.value = num3.value\r\n  } else {\r\n    num3.value = e.target.value\r\n  }\r\n  // value\r\n  // 不能这么写呢 因为.和负号的输入位置无法判断\r\n  // num3.value = e.target.value.replace(\r\n  //   /^-{2,}|(?<!\\d)\\.|\\.(?!\\d)|[^0-9\\.\\-]/g,\r\n  //   \"\"\r\n  // )\r\n}\r\n\r\nconst pos = reactive({\r\n  top: 0,\r\n  left: 0,\r\n  width: \"100px\",\r\n  height: \"100px\",\r\n  backgroundColor: \"red\",\r\n  transition: \"none\"\r\n})\r\n\r\n// function addToShopCart(params: { skuId: number; count: number }) {\r\n//   const a = {\r\n//     ...params,\r\n//     code: 0\r\n//   }\r\n//   return new Promise((resolve) => {\r\n//     setTimeout(() => {\r\n//       resolve(a)\r\n//     }, 100)\r\n//   })\r\n// }\r\n\r\n// function startAnimal(e) {\r\n//   const ary = [\r\n//     { num: 1, id: 1 },\r\n//     { num: 2, id: 2 }\r\n//   ]\r\n//   const asyncArray = []\r\n//   ary.forEach((element) => {\r\n//     if (element.num > 0) {\r\n//       asyncArray.push(\r\n//         addToShopCart({\r\n//           skuId: element.id,\r\n//           count: element.num\r\n//         })\r\n//       )\r\n//     }\r\n//   })\r\n\r\n//   Promise.all(asyncArray).then((res) => {\r\n//     const flag = res.some((item) => {\r\n//       return item.code === 0\r\n//     })\r\n//     if (flag) {\r\n//       pos.left = e.clientX - 25 + \"px\"\r\n//       pos.top = e.clientY - 25 + \"px\"\r\n//       pos.transition = \"none\"\r\n//       const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n//       // requestAnimationFrame(() => {\r\n//       //   console.log(dom)\r\n\r\n//       //   pos.left = dom.x + \"px\"\r\n//       //   pos.top = dom.y + \"px\"\r\n//       //   pos.transition = \"all 5s\"\r\n//       // })\r\n\r\n//       requestAnimationFrame(() => {\r\n//         // 多次点击startAnimal 动画只执行第一次 原因是 动画还没来得及执行 pos.left = dom.x + \"px\" pos.top = dom.y + \"px\" 下一帧就要执行 pos.left = dom.x + \"px\"     pos.top = dom.y + \"px\" 然后动画就会继续执行 后者 前者跳过了\r\n//         pos.left = dom.x + \"px\"\r\n//         pos.top = dom.y + \"px\"\r\n//         pos.transition = \"all 5s\"\r\n//       })\r\n//     }\r\n//   })\r\n// }\r\n\r\nfunction addToShopCart(params: { skuId: number; count: number }) {\r\n  const a = {\r\n    ...params,\r\n    code: 0\r\n  }\r\n  return Promise.resolve(a)\r\n}\r\n\r\nfunction startAnimal(e) {\r\n  const ary = [\r\n    { num: 1, id: 1 },\r\n    { num: 2, id: 2 }\r\n  ]\r\n  const asyncArray = []\r\n  ary.forEach((element) => {\r\n    if (element.num > 0) {\r\n      asyncArray.push(\r\n        addToShopCart({\r\n          skuId: element.id,\r\n          count: element.num\r\n        })\r\n      )\r\n    }\r\n  })\r\n  Promise.all(asyncArray).then((res) => {\r\n    const flag = res.some((item) => {\r\n      return item.code === 0\r\n    })\r\n    if (flag) {\r\n      pos.left = e.clientX - 25 + \"px\" // 1\r\n      pos.top = e.clientY - 25 + \"px\" // 2\r\n      pos.transition = \"none\" // 3\r\n      const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n      // requestAnimationFrame(() => {\r\n      //   console.log(dom)\r\n\r\n      //   pos.left = dom.x + \"px\"\r\n      //   pos.top = dom.y + \"px\"\r\n      //   pos.transition = \"all 5s\"\r\n      // })\r\n      // 有一种感觉 就是如果 promise.all 接受的异步任务 不是放到当前微任务队列完成的 而是放在下一个宏任务的微队列运行的话 则 会无视掉上面的 1 2 3代码 首次执行时  后面每次执行才会 执行 123的代码\r\n      requestAnimationFrame(() => {\r\n        // 多次点击startAnimal 动画只执行第一次 原因是 动画还没来得及执行 pos.left = dom.x + \"px\" pos.top = dom.y + \"px\" 下一帧就要执行 pos.left = dom.x + \"px\"     pos.top = dom.y + \"px\" 然后动画就会继续执行 后者 前者跳过了\r\n        pos.left = dom.x + \"px\"\r\n        pos.top = dom.y + \"px\"\r\n        pos.transition = \"all 5s\"\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\n// function startAnimal(e) {\r\n//   new Promise((res, rej) => {\r\n//     setTimeout(() => {\r\n//       res(123)\r\n//     }, 1000)\r\n//   }).then(() => {\r\n//     requestAnimationFrame(() => {\r\n//       pos.left = e.clientX - 25 + \"px\" // 1\r\n//       pos.top = e.clientY - 25 + \"px\" // 2\r\n//       pos.transition = \"none\" // 3\r\n//       // 这么写就好了\r\n//       requestAnimationFrame(() => {\r\n//         const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n//         console.log(dom)\r\n\r\n//         pos.left = dom.x + \"px\"\r\n//         pos.top = dom.y + \"px\"\r\n//         pos.transition = \"all 5s cubic-bezier(0.5, -0.5, 1, 1)\"\r\n//       })\r\n//     })\r\n//     // const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n//     // @ 和getBoundingClientRect() 无关\r\n//     // const dom = {\r\n//     //   x: 1100,\r\n//     //   y: 400\r\n//     // }\r\n//     // requestAnimationFrame(() => {\r\n//     //   console.log(dom)\r\n\r\n//     // pos.left = dom.x + \"px\"\r\n//     // pos.top = dom.y + \"px\"\r\n//     // pos.transition = \"all 5s\"\r\n//     // })\r\n//     // 有一种感觉 就是如果 promise.all 接受的异步任务 不是放到当前微任务队列完成的 而是放在下一个宏任务的微队列运行的话 则 会无视掉上面的 1 2 3代码 首次执行时  后面每次执行才会 执行 123的代码\r\n//     // 几乎不出闪现\r\n//     // requestAnimationFrame(() => {\r\n//     //   // 多次点击startAnimal 动画只执行第一次 原因是 动画还没来得及执行 pos.left = dom.x + \"px\" pos.top = dom.y + \"px\" 下一帧就要执行 pos.left = dom.x + \"px\"     pos.top = dom.y + \"px\" 然后动画就会继续执行 后者 前者跳过了\r\n//     //   pos.left = dom.x + \"px\"\r\n//     //   pos.top = dom.y + \"px\"\r\n//     //   pos.transition = \"all 5s\"\r\n//     // })\r\n//     // 大概率出 闪现 也就是我们希望的效果 火狐的话几乎都是闪现  浏览器的处理不同\r\n\r\n//     // 也就是说promise中调用requestAnimationFrame的话 为了确保动画的流畅性 好像只会记录元素的起始位置和结束位置产生动画 而不像计时器会跳跃 （猜测）\r\n\r\n//     // 知道了 是vue的问题 vue是异步更新队列的也就是说 pos的属性虽然改变了 但是 dom还没有更新\r\n//     // setTimeout(() => {\r\n//     //   pos.left = dom.x + \"px\"\r\n//     //   pos.top = dom.y + \"px\"\r\n//     //   pos.transition = \"all 5s\"\r\n//     // }, 0)\r\n//   })\r\n// }\r\n\r\n// function startAnimal(e) {\r\n//   new Promise((res, rej) => {\r\n//     setTimeout(() => {\r\n//       res(123)\r\n//     }, 1000)\r\n//   }).then(() => {\r\n//     requestAnimationFrame(() => {\r\n//       pos.left = e.clientX - 25 + \"px\" // 1\r\n//       pos.top = e.clientY - 25 + \"px\" // 2\r\n//       pos.transition = \"none\" // 3\r\n//       // 这么写就好了\r\n//       requestAnimationFrame(() => {\r\n//         const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n//         console.log(dom)\r\n\r\n//         pos.left = dom.x + \"px\"\r\n//         pos.top = dom.y + \"px\"\r\n//         pos.transition = \"all 5s cubic-bezier(0.5, -0.5, 1, 1)\"\r\n//       })\r\n//     })\r\n//     // const dom = document.querySelector(\"#warp\").getBoundingClientRect()\r\n//     // @ 和getBoundingClientRect() 无关\r\n//     // const dom = {\r\n//     //   x: 1100,\r\n//     //   y: 400\r\n//     // }\r\n//     // requestAnimationFrame(() => {\r\n//     //   console.log(dom)\r\n\r\n//     // pos.left = dom.x + \"px\"\r\n//     // pos.top = dom.y + \"px\"\r\n//     // pos.transition = \"all 5s\"\r\n//     // })\r\n//     // 有一种感觉 就是如果 promise.all 接受的异步任务 不是放到当前微任务队列完成的 而是放在下一个宏任务的微队列运行的话 则 会无视掉上面的 1 2 3代码 首次执行时  后面每次执行才会 执行 123的代码\r\n//     // 几乎不出闪现\r\n//     // requestAnimationFrame(() => {\r\n//     //   // 多次点击startAnimal 动画只执行第一次 原因是 动画还没来得及执行 pos.left = dom.x + \"px\" pos.top = dom.y + \"px\" 下一帧就要执行 pos.left = dom.x + \"px\"     pos.top = dom.y + \"px\" 然后动画就会继续执行 后者 前者跳过了\r\n//     //   pos.left = dom.x + \"px\"\r\n//     //   pos.top = dom.y + \"px\"\r\n//     //   pos.transition = \"all 5s\"\r\n//     // })\r\n//     // 大概率出 闪现 也就是我们希望的效果 火狐的话几乎都是闪现  浏览器的处理不同\r\n\r\n//     // 也就是说promise中调用requestAnimationFrame的话 为了确保动画的流畅性 好像只会记录元素的起始位置和结束位置产生动画 而不像计时器会跳跃 （猜测）\r\n\r\n//     // 知道了 是vue的问题 vue是异步更新队列的也就是说 pos的属性虽然改变了 但是 dom还没有更新\r\n//     // setTimeout(() => {\r\n//     //   pos.left = dom.x + \"px\"\r\n//     //   pos.top = dom.y + \"px\"\r\n//     //   pos.transition = \"all 5s\"\r\n//     // }, 0)\r\n//   })\r\n// }\r\n\r\nfunction handleAnimal() {\r\n  const con = document.querySelector(\".con\")\r\n  const ball = document.querySelector(\".ball\")\r\n\r\n  ball.style.transform = \"translateY(0)\"\r\n  con.style.transform = \"translateX(0)\"\r\n  // 动态 transform 不会触发元素的重新渲染\r\n  ball.clientWidth //，加入这个代码，让页面重新渲染，从而达到有过渡的效果。\r\n\r\n  ball.style.transform = \"translateY(300px)\"\r\n  con.style.transform = \"translateX(100px)\"\r\n}\r\n\r\nonUpdated(() => {\r\n  console.log(\"更新了\")\r\n})\r\nconst message = ref(\"Hello, Vue 3!\")\r\n\r\nfunction changeMessage() {\r\n  message.value = \"Message changed!\"\r\n}\r\n// 正常是会触发 updated与beforeUpdate的 state改变的时候\r\nonUpdated(() => {\r\n  console.log(\"Component updated!\")\r\n})\r\nonBeforeUpdate(() => {\r\n  console.log(\"Component before update!\")\r\n})\r\n\r\n// 上传\r\nconst src = ref(\"\")\r\n\r\nfunction upload(e) {\r\n  const file = e.target.files[0]\r\n  // 可以预览 甚至不需要转base64\r\n  // src.value = window.URL.createObjectURL(file)\r\n\r\n  // 同理 base64 也可下载 这俩都可以用同样的功能 细节有所差别\r\n  const fr = new FileReader()\r\n  const a = document.createElement(\"a\")\r\n  a.download = \"zy.png\"\r\n  a.href = fr.readAsDataURL(file)\r\n  a.click()\r\n}\r\n\r\nconst radioModel = ref(0)\r\nconst radioModel2 = ref(0)\r\n\r\nconst react = reactive({\r\n  data: {\r\n    b: 1\r\n  }\r\n})\r\n// template未用到的响应式数据 不会触发 updated\r\n// setInterval(() => {\r\n//   react.data++\r\n// }, 1000)\r\nonUpdated(() => {\r\n  console.log(\"更新了\")\r\n})\r\n\r\nconst value = ref(1)\r\n\r\nfunction change() {\r\n  nextTick(() => {\r\n    value.value++\r\n    console.log(value.value, \"我还没更新呢\")\r\n  })\r\n  value.value++\r\n}\r\nwatch(value, (newValue, oldValue) => {\r\n  console.log(\"value更新了\")\r\n})\r\n\r\nconst time = ref()\r\n</script>\r\n\r\n<template>\r\n  <div class=\"common-layout\">\r\n    <el-container>\r\n      <el-aside width=\"400px\">\r\n        <div>\r\n          <el-button @click=\"flag = 1\" type=\"primary\"\r\n            >测试 响应式对象作为函数参数传递 是否触发更新</el-button\r\n          >\r\n          <el-button @click=\"flag = 2\" type=\"primary\"\r\n            >测试 input focus 何时失去焦点</el-button\r\n          >\r\n          <el-button @click=\"flag = 3\" type=\"primary\"\r\n            >el-input 输入正数包括小数的写法</el-button\r\n          >\r\n          <el-button @click=\"flag = 4\" type=\"primary\"\r\n            >动画过渡问题测试</el-button\r\n          >\r\n          <el-button @click=\"flag = 5\" type=\"primary\">抛物线过度测试</el-button>\r\n          <el-button @click=\"flag = 6\" type=\"primary\"\r\n            >updated生命周期不执行</el-button\r\n          >\r\n          <el-button @click=\"flag = 7\" type=\"primary\"\r\n            >FileReader.readAsDataURL(file)和URL createObjectURL()</el-button\r\n          >\r\n          <el-button @click=\"flag = 8\" type=\"primary\"\r\n            >手动导入和自动导入同时存在样式丢失了</el-button\r\n          >\r\n          <el-button @click=\"flag = 9\" type=\"primary\"\r\n            >el-radio 不带group的用法</el-button\r\n          >\r\n          <el-button @click=\"router.push(undefined)\" type=\"primary\"\r\n            >测试跳转undefined （会直接报错）</el-button\r\n          >\r\n          <el-button @click=\"flag = 10\" type=\"primary\"\r\n            >template没用到的proxy 会触发updated吗</el-button\r\n          >\r\n          <el-button @click=\"flag = 11\" type=\"primary\">测试watch时机</el-button>\r\n          <el-button @click=\"flag = 12\" type=\"primary\"\r\n            >datepicker可以跨年选吗</el-button\r\n          >\r\n        </div>\r\n      </el-aside>\r\n      <el-main>\r\n        <template v-if=\"flag === 1\">\r\n          <div>{{ compute(count) }}</div>\r\n          <div>\r\n            会触发更新 因为也会收集依赖 当数据变化 会重新创建虚拟dom\r\n            然后会重新执行函数\r\n          </div>\r\n\r\n          <p>{{ count1plus }}</p>\r\n          <div>\r\n            计算属性的回调函数中 用到的函数 中的参数是响应式对象\r\n            当响应式对象更新的时候 计算属性也会重新计算\r\n          </div>\r\n\r\n          <p>{{ sex(sexCode.data, \"sex\") }}</p>\r\n        </template>\r\n        <template v-else-if=\"flag === 2\">\r\n          <input type=\"text\" @focus=\"lose\" />\r\n\r\n          <div class=\"modal\" v-if=\"show\"></div>\r\n          <el-input type=\"text\" @focus=\"lose\" @blur=\"_blur\"></el-input>\r\n          <el-dialog v-model=\"show\"></el-dialog>\r\n        </template>\r\n        <template v-else-if=\"flag === 3\">\r\n          <el-input type=\"number\" v-model.number=\"num1\" />\r\n          <input type=\"number\" v-model.number=\"num2\" />\r\n\r\n          <p>\r\n            elementplus 如果设置了.number修饰符\r\n            当然这是elementplus自定义的修饰符 它可以屏蔽掉 汉字输入 不过\r\n            原生的不行 因为原生的只支持 数值字符串转数值 但是如果输入汉字字母\r\n            则还是字符串 因此原生要搭配type=number用 并且element.number不支持.\r\n            支持-号 原生增加type=number后 可以输入小数 还可以输入 + - ++ +- -+\r\n            --这种无意义的符号 也就是说 如果想要输入整数 则el-input的\r\n            .number够用 如果想要输入小数或者正数 则要自己判断了\r\n          </p>\r\n\r\n          <input type=\"text\" :value=\"num3\" @input=\"input\" />\r\n          <el-input type=\"text\" :model-value=\"num4\" />\r\n        </template>\r\n        <template v-else-if=\"flag === 4\">\r\n          <div class=\"btn-warp\">\r\n            <div style=\"position: fixed\" :style=\"pos\"></div>\r\n            <el-button type=\"primary\" @click=\"startAnimal\"\r\n              >点我出现动画</el-button\r\n            >\r\n\r\n            <div\r\n              style=\"\r\n                position: fixed;\r\n                width: 100px;\r\n                height: 100px;\r\n                right: 300px;\r\n                top: 200px;\r\n                background-color: red;\r\n              \"\r\n              id=\"warp\"\r\n            ></div>\r\n          </div>\r\n        </template>\r\n        <template v-else-if=\"flag === 5\">\r\n          <div class=\"con\">\r\n            <div class=\"ball\"></div>\r\n          </div>\r\n\r\n          <button @click=\"handleAnimal\">执行抛物线动画</button>\r\n        </template>\r\n        <template v-else-if=\"flag === 6\">\r\n          <div>\r\n            插槽使用的响应式数据变化只会触发子组件updated生命周期\r\n            而不会触发父组件的 也就是说 子组件内部更新 父组件不会触发更新钩子\r\n            父组件state变化影响到子组件的 才会父子都触发updated钩子\r\n            <div>\r\n              <slot-test>\r\n                <h1>{{ message }}</h1>\r\n                <button @click=\"changeMessage\">Change Message</button>\r\n              </slot-test>\r\n            </div>\r\n          </div>\r\n        </template>\r\n        <template v-else-if=\"flag === 7\">\r\n          <div>\r\n            <input type=\"file\" @change=\"upload\" />\r\n\r\n            <img :src=\"src\" alt=\"\" width=\"500\" height=\"500\" />\r\n          </div>\r\n        </template>\r\n        <template v-else-if=\"flag === 8\">\r\n          <el-select></el-select>\r\n          <el-input-number></el-input-number>\r\n        </template>\r\n\r\n        <template v-else-if=\"flag === 9\">\r\n          <div>\r\n            <el-radio value=\"1\" v-model=\"radioModel\" label=\"1\"></el-radio>\r\n            <el-radio value=\"2\" v-model=\"radioModel\" label=\"2\"></el-radio>\r\n            <el-radio value=\"1\" v-model=\"radioModel2\" label=\"1\"></el-radio>\r\n            <el-radio value=\"2\" v-model=\"radioModel2\" label=\"2\"></el-radio>\r\n          </div>\r\n        </template>\r\n        <template v-else-if=\"flag === 10\">\r\n          <h2>{{ react.data.b }}</h2>\r\n          <!-- 直接替换数据是会更新了 -->\r\n          <button @click=\"react.data = { b: 2 }\">点击</button>\r\n        </template>\r\n        <template v-else-if=\"flag === 11\">\r\n          <div>\r\n            <el-button @click=\"change\">点击</el-button>\r\n          </div>\r\n          <div>\r\n            watch的执行时间 如果nexttick写在数据改变前\r\n            则watch执行时机在nexttick之后 如果nexttick写在数据改变后\r\n            则watch执行时机在nexttick之前 感觉更像是数据改变的时候\r\n            新创建了一个nexttick1放在 nexttick后执行了\r\n          </div>\r\n        </template>\r\n        <template v-else-if=\"flag === 12\">\r\n          unlink-panels取消两个面板的联动\r\n          <el-date-picker\r\n            v-model=\"time\"\r\n            unlink-panels\r\n            type=\"daterange\"\r\n            placeholder=\"选择日期\"\r\n          ></el-date-picker>\r\n\r\n          可以 但是操作麻烦\r\n        </template>\r\n      </el-main>\r\n    </el-container>\r\n  </div>\r\n</template>\r\n\r\n<style lang=\"scss\">\r\n.common-layout {\r\n  height: 100vh;\r\n}\r\n.con {\r\n  width: 50px;\r\n  height: 50px;\r\n  border-radius: 50%;\r\n  left: 100px;\r\n  top: 300px;\r\n  position: fixed;\r\n  transition: 2s linear;\r\n}\r\n\r\n.ball {\r\n  width: 50px;\r\n  height: 50px;\r\n  border-radius: 50%;\r\n  background: #0d84ff;\r\n  position: absolute;\r\n  transition: 2s cubic-bezier(0.5, -0.5, 1, 1);\r\n}\r\n.modal {\r\n  position: fixed;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n</style>\r\n"],"names":["getDict","params","resolve","reject","useAnalysisDict","string","ref","value","dictCode","dictData","res","item","flag","count","compute","count1","reactive","handlePlus","count1plus","computed","sexCode","sex","onMounted","lose","show","_blur","num1","num2","num3","num4","input","e","regex","pos","addToShopCart","a","startAnimal","ary","asyncArray","element","dom","handleAnimal","con","ball","onUpdated","message","changeMessage","onBeforeUpdate","src","upload","file","fr","radioModel","radioModel2","react","change","nextTick","watch","newValue","oldValue","time"],"mappings":"6jCACA,SAASA,GAAQC,EAA4C,CAC3D,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,WAAW,IAAM,CACPD,EAAA,CACN,KAAM,EACN,KAAM,CACJ,CACE,SAAU,IACV,UAAW,IACX,UAAW,GACb,EACA,CACE,SAAU,IACV,UAAW,IACX,UAAW,GACb,CACF,CAAA,CACD,GACA,GAAI,CAAA,CACR,CACH,CAEO,SAASE,IAAoF,CAC9F,IAAAC,EAASC,EAAI,EAAE,EACZ,OAAA,SAAUC,EAAoCC,EAAyB,CAC5E,GAAI,CAACD,EACH,OAAOF,EAAO,MAEhB,QAAQ,IAAIE,CAAK,EAEb,IAAAE,EACJ,OAAAT,GAA2B,EAAE,KAAMU,GAAQ,CACrCA,EAAI,OAAS,IACfD,EAAWC,EAAI,KAEND,EAAA,KAAME,GAA4E,CACrFJ,GAASI,EAAK,YAChBN,EAAO,MAAQM,EAAK,UAExB,CAAA,EAEF,CACD,EACD,QAAQ,IAAIN,CAAM,EAEXA,EAAO,KAAA,CAElB,27BC1CM,MAAAO,EAAON,EAAI,CAAC,EAEZO,EAAQP,EAAI,CAAC,EACnB,SAASQ,EAAQP,EAAO,CACtB,OAAOA,EAAQ,CACjB,CAEA,MAAMQ,EAASC,EAAS,CACtB,EAAG,CAAA,CACJ,EACKC,EAAa,SAAUV,EAAO,CAClC,OAAOA,EAAQ,CAAA,EAEXW,EAAaC,GAAS,IAAMF,EAAWF,EAAO,CAAC,CAAC,EAEhDK,EAAUJ,EAAS,CACvB,KAAM,EAAA,CACP,EACKK,EAAMjB,KAEZ,WAAW,IAAM,CACfgB,EAAQ,KAAO,KACd,GAAI,EAIK,YAAY,IAAM,CAC5BP,EAAM,MAAQ,GACb,GAAI,EAEPS,GAAU,IAAM,CACd,QAAQ,IAAI,OAAO,CAAA,CACpB,EAED,SAASC,GAAO,CACd,QAAQ,IAAI,IAAI,EAChBC,EAAK,MAAQ,EACf,CACA,SAASC,GAAQ,CACf,QAAQ,IAAI,IAAI,CAClB,CACM,MAAAD,EAAOlB,EAAI,EAAK,EAEhBoB,EAAOpB,EAAI,EAAE,EACbqB,EAAOrB,EAAI,EAAE,EAEbsB,EAAOtB,EAAI,KAAK,EAChBuB,EAAOvB,EAAI,EAAE,EAInB,SAASwB,EAAMC,EAAG,CACR,QAAA,IAAIA,EAAE,IAAI,EACV,QAAA,IAAIA,EAAE,OAAO,KAAK,EAE1B,IAAIC,EAAQ,qDAEZ,QAAQ,IAAIA,EAAM,KAAKD,EAAE,IAAI,CAAC,EAEzBC,EAAM,KAAKD,EAAE,IAAI,EAKfH,EAAA,MAAQG,EAAE,OAAO,MAFpBA,EAAA,OAAO,MAAQH,EAAK,KAU1B,CAEA,MAAMK,EAAMjB,EAAS,CACnB,IAAK,EACL,KAAM,EACN,MAAO,QACP,OAAQ,QACR,gBAAiB,MACjB,WAAY,MAAA,CACb,EA0DD,SAASkB,EAAcjC,EAA0C,CAC/D,MAAMkC,EAAI,CACR,GAAGlC,EACH,KAAM,CAAA,EAED,OAAA,QAAQ,QAAQkC,CAAC,CAC1B,CAEA,SAASC,EAAYL,EAAG,CACtB,MAAMM,EAAM,CACV,CAAE,IAAK,EAAG,GAAI,CAAE,EAChB,CAAE,IAAK,EAAG,GAAI,CAAE,CAAA,EAEZC,EAAa,CAAA,EACfD,EAAA,QAASE,GAAY,CACnBA,EAAQ,IAAM,GACLD,EAAA,KACTJ,EAAc,CACZ,MAAOK,EAAQ,GACf,MAAOA,EAAQ,GAAA,CAChB,CAAA,CAEL,CACD,EACD,QAAQ,IAAID,CAAU,EAAE,KAAM5B,GAAQ,CAIpC,GAHaA,EAAI,KAAMC,GACdA,EAAK,OAAS,CACtB,EACS,CACJsB,EAAA,KAAOF,EAAE,QAAU,GAAK,KACxBE,EAAA,IAAMF,EAAE,QAAU,GAAK,KAC3BE,EAAI,WAAa,OACjB,MAAMO,EAAM,SAAS,cAAc,OAAO,EAAE,sBAAsB,EASlE,sBAAsB,IAAM,CAEtBP,EAAA,KAAOO,EAAI,EAAI,KACfP,EAAA,IAAMO,EAAI,EAAI,KAClBP,EAAI,WAAa,QAAA,CAClB,CACH,CAAA,CACD,CACH,CA8GA,SAASQ,GAAe,CAChB,MAAAC,EAAM,SAAS,cAAc,MAAM,EACnCC,EAAO,SAAS,cAAc,OAAO,EAE3CA,EAAK,MAAM,UAAY,gBACvBD,EAAI,MAAM,UAAY,gBAEjBC,EAAA,YAELA,EAAK,MAAM,UAAY,oBACvBD,EAAI,MAAM,UAAY,mBACxB,CAEAE,EAAU,IAAM,CACd,QAAQ,IAAI,KAAK,CAAA,CAClB,EACK,MAAAC,EAAUvC,EAAI,eAAe,EAEnC,SAASwC,GAAgB,CACvBD,EAAQ,MAAQ,kBAClB,CAEAD,EAAU,IAAM,CACd,QAAQ,IAAI,oBAAoB,CAAA,CACjC,EACDG,GAAe,IAAM,CACnB,QAAQ,IAAI,0BAA0B,CAAA,CACvC,EAGK,MAAAC,EAAM1C,EAAI,EAAE,EAElB,SAAS2C,EAAOlB,EAAG,CACjB,MAAMmB,EAAOnB,EAAE,OAAO,MAAM,CAAC,EAKvBoB,EAAK,IAAI,WACThB,EAAI,SAAS,cAAc,GAAG,EACpCA,EAAE,SAAW,SACXA,EAAA,KAAOgB,EAAG,cAAcD,CAAI,EAC9Bf,EAAE,MAAM,CACV,CAEM,MAAAiB,EAAa9C,EAAI,CAAC,EAClB+C,EAAc/C,EAAI,CAAC,EAEnBgD,EAAQtC,EAAS,CACrB,KAAM,CACJ,EAAG,CACL,CAAA,CACD,EAKD4B,EAAU,IAAM,CACd,QAAQ,IAAI,KAAK,CAAA,CAClB,EAEK,MAAArC,EAAQD,EAAI,CAAC,EAEnB,SAASiD,GAAS,CAChBC,GAAS,IAAM,CACPjD,EAAA,QACE,QAAA,IAAIA,EAAM,MAAO,QAAQ,CAAA,CAClC,EACKA,EAAA,OACR,CACMkD,GAAAlD,EAAO,CAACmD,EAAUC,IAAa,CACnC,QAAQ,IAAI,UAAU,CAAA,CACvB,EAED,MAAMC,EAAOtD"}